import { readFile } from "fs/promises";
import path, { basename, dirname, normalize } from "path";
import pc from "picocolors";
import stripAnsi from "strip-ansi";
import { RuleResult } from "../rule-result.js";
import { Rule } from "../rule.js";
import { TsvHost } from "../tsv-host.js";
import { filterAsync } from "../utils.js";

export class CompileRule implements Rule {
  readonly name = "Compile";
  readonly description = "Compile TypeSpec";

  async execute(host: TsvHost, folder: string): Promise<RuleResult> {
    let success = true;
    let stdOutput = "";
    let errorOutput = "";

    if (await host.checkFileExists(path.join(folder, "main.tsp"))) {
      let [err, stdout, stderr] = await host.runCmd(
        `npm exec --no -- tsp compile --list-files --warn-as-error ${folder}`,
      );

      stdOutput += stdout;

      // Rule output is easier to read if "tsp compile" stderr is redirected to stdOutput
      stdOutput += stderr;

      if (
        stdout.toLowerCase().includes("no emitter was configured") ||
        stdout.toLowerCase().includes("no output was generated")
      ) {
        success = false;
        errorOutput += "No emitter was configured and/or no output was generated.";
      }

      if (!err) {
        // Check for *extra* typespec-generated swagger files under the output folder, which
        // indicates a mismatch between TypeSpec and swaggers.

        // Example 'stdout':
        //
        // TypeSpec compiler v0.67.2
        //
        // ../resource-manager/Microsoft.Contoso/stable/2021-11-01/contoso.json
        // ../resource-manager/Microsoft.Contoso/stable/2021-11-01/examples/Operations_List.json
        //
        // Compilation completed successfully.

        // Remove ANSI color codes, handle windows and linux line endings
        const lines = stripAnsi(stdout).split(/\r?\n/);

        // TODO: Use helpers in /.github once they support platform-specific paths
        const outputSwaggers = lines
          // Remove leading and trailing whitespace
          .map((l) => l.trim())
          // Skip blank lines
          .filter((l) => l !== "")
          // Skip first and last lines (version and success messages)
          .slice(1, -1)
          // Normalize to platform-specific path
          .map((l) => normalize(l))
          // Filter to JSON files
          .filter((p) => basename(p).toLowerCase().endsWith(".json"))
          // Exclude examples
          .filter((p) => !p.split(path.sep).includes("examples"));

        stdOutput += "\nGenerated Swaggers:\n";
        stdOutput += outputSwaggers.join("\n") + "\n";

        // ../resource-manager/Microsoft.Contoso
        const outputFolder = dirname(dirname(dirname(outputSwaggers[0])));
        const outputFilename = basename(outputSwaggers[0]);

        stdOutput += "\nOutput folder:\n";
        stdOutput += outputFolder + "\n";

        // Filter to only specs matching the folder and filename extracted from the first output-file.
        // Necessary to handle multi-project specs like keyvault.
        //
        // Globby only accepts patterns like posix paths.
        const pattern = path.posix.join(
          ...outputFolder.split(path.win32.sep),
          "**",
          outputFilename,
        );
        const allSwaggers = (await host.globby(pattern, { ignore: ["**/examples/**"] })).map((p) =>
          normalize(p),
        );

        // Filter to files generated by TypeSpec
        const tspGeneratedSwaggers = await filterAsync(allSwaggers, async (swaggerPath: string) => {
          const swaggerText = await readFile(swaggerPath, { encoding: "utf8" });
          const swaggerObj = JSON.parse(swaggerText);
          return swaggerObj["info"]?.["x-typespec-generated"];
        });

        stdOutput += `\nSwaggers matching output folder and filename:\n`;
        stdOutput += tspGeneratedSwaggers.join("\n") + "\n";

        const suppressedSwaggers = await filterAsync(
          tspGeneratedSwaggers,
          async (swaggerPath: string) => {
            const suppressions = await host.getSuppressions(swaggerPath);
            return suppressions.some(
              (s) => s.rules?.includes(this.name) && s.subRules?.includes("ExtraSwagger"),
            );
          },
        );

        stdOutput += `\nSwaggers excluded via suppressions.yaml:\n`;
        stdOutput += suppressedSwaggers.join("\n") + "\n";

        const remainingSwaggers = tspGeneratedSwaggers.filter(
          (s) => !suppressedSwaggers.includes(s),
        );

        stdOutput += `\nRemaining swaggers:\n`;
        stdOutput += remainingSwaggers.join("\n") + "\n";

        const extraSwaggers = remainingSwaggers.filter((s) => !outputSwaggers.includes(s));

        if (extraSwaggers.length > 0) {
          success = false;
          errorOutput += pc.red(
            `\nOutput folder '${outputFolder}' appears to contain TypeSpec-generated ` +
              `swagger files, not generated from the current TypeSpec sources. ` +
              `Perhaps you deleted a version from your TypeSpec, but didn't delete ` +
              `the associated swaggers?\n\n`,
          );
          errorOutput += pc.red(extraSwaggers.join("\n") + "\n");
        }
      } else {
        success = false;
        errorOutput += err.message;
      }
    }

    const clientTsp = path.join(folder, "client.tsp");
    if (await host.checkFileExists(clientTsp)) {
      let [err, stdout, stderr] = await host.runCmd(
        `npm exec --no -- tsp compile --no-emit --warn-as-error ${clientTsp}`,
      );
      if (err) {
        success = false;
        errorOutput += err.message;
      }
      stdOutput += stdout;
      errorOutput += stderr;
    }

    if (success) {
      const gitDiffResult = await host.gitDiffTopSpecFolder(host, folder);
      stdOutput += gitDiffResult.stdOutput;
      if (!gitDiffResult.success) {
        success = false;
        errorOutput += gitDiffResult.errorOutput;
        errorOutput += `\nFiles have been changed after \`tsp compile\`. Run \`tsp compile\` and ensure all files are included in your change.`;
      }
    }

    return {
      success: success,
      stdOutput: stdOutput,
      errorOutput: errorOutput,
    };
  }
}
