{
  "swagger": "2.0",
  "info": {
    "title": "Azure AI Search",
    "version": "2024-07-01",
    "description": "Client that can be used to manage and query indexes and documents, as well as\nmanage other resources, on a search service.",
    "x-typespec-generated": [
      {
        "emitter": "@azure-tools/typespec-autorest"
      }
    ]
  },
  "schemes": [
    "https"
  ],
  "produces": [
    "application/json"
  ],
  "consumes": [
    "application/json"
  ],
  "security": [
    {
      "ApiKeyAuth": []
    },
    {
      "OAuth2Auth": [
        "https://search.azure.com/.default"
      ]
    }
  ],
  "securityDefinitions": {
    "ApiKeyAuth": {
      "type": "apiKey",
      "name": "api-key",
      "in": "header"
    },
    "OAuth2Auth": {
      "type": "oauth2",
      "flow": "implicit",
      "authorizationUrl": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
      "scopes": {
        "https://search.azure.com/.default": ""
      }
    }
  },
  "tags": [],
  "paths": {
    "/datasources": {
      "get": {
        "operationId": "DataSources_List",
        "description": "Lists all datasources available for a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Selects which top-level properties to retrieve.\nSpecified as a comma-separated list of JSON property names,\nor '*' for all properties. The default is all properties.",
            "required": false,
            "type": "string"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/ListDataSourcesResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceListDataSources": {
            "$ref": "./examples/SearchServiceListDataSources.json"
          }
        }
      },
      "post": {
        "operationId": "DataSources_Create",
        "description": "Creates a new datasource.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "dataSource",
            "in": "body",
            "description": "The definition of the datasource to create.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchIndexerDataSource"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerDataSource"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateDataSource": {
            "$ref": "./examples/SearchServiceCreateDataSource.json"
          }
        }
      }
    },
    "/datasources('{dataSourceName}')": {
      "get": {
        "operationId": "DataSources_Get",
        "description": "Retrieves a datasource definition.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "dataSourceName",
            "in": "path",
            "description": "The name of the datasource.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerDataSource"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceGetDataSource": {
            "$ref": "./examples/SearchServiceGetDataSource.json"
          }
        }
      },
      "put": {
        "operationId": "DataSources_CreateOrUpdate",
        "description": "Creates a new datasource or updates a datasource if it already exists.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "name": "Prefer",
            "in": "header",
            "description": "For HTTP PUT requests, instructs the service to return the created/updated resource on success.",
            "required": true,
            "type": "string",
            "enum": [
              "return=representation"
            ],
            "x-ms-enum": {
              "modelAsString": false
            },
            "x-ms-client-name": "prefer"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "dataSourceName",
            "in": "path",
            "description": "The name of the datasource.",
            "required": true,
            "type": "string"
          },
          {
            "name": "dataSource",
            "in": "body",
            "description": "The definition of the datasource to create or update.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchIndexerDataSource"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerDataSource"
            }
          },
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerDataSource"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateOrUpdateDataSource": {
            "$ref": "./examples/SearchServiceCreateOrUpdateDataSource.json"
          }
        }
      },
      "delete": {
        "operationId": "DataSources_Delete",
        "description": "Deletes a datasource.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "dataSourceName",
            "in": "path",
            "description": "The name of the datasource.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "There is no content to send for this request, but the headers may be useful. "
          },
          "404": {
            "description": "The server cannot find the requested resource."
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceDeleteDataSource": {
            "$ref": "./examples/SearchServiceDeleteDataSource.json"
          }
        }
      }
    },
    "/indexers": {
      "get": {
        "operationId": "Indexers_List",
        "description": "Lists all indexers available for a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Selects which top-level properties to retrieve.\nSpecified as a comma-separated list of JSON property names,\nor '*' for all properties. The default is all properties.",
            "required": false,
            "type": "string"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/ListIndexersResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceListIndexers": {
            "$ref": "./examples/SearchServiceListIndexers.json"
          }
        }
      },
      "post": {
        "operationId": "Indexers_Create",
        "description": "Creates a new indexer.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexer",
            "in": "body",
            "description": "The definition of the indexer to create.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchIndexer"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SearchIndexer"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateIndexer": {
            "$ref": "./examples/SearchServiceCreateIndexer.json"
          }
        }
      }
    },
    "/indexers('{indexerName}')": {
      "get": {
        "operationId": "Indexers_Get",
        "description": "Retrieves an indexer definition.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexerName",
            "in": "path",
            "description": "The name of the indexer.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndexer"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceGetIndexer": {
            "$ref": "./examples/SearchServiceGetIndexer.json"
          }
        }
      },
      "put": {
        "operationId": "Indexers_CreateOrUpdate",
        "description": "Creates a new indexer or updates an indexer if it already exists.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "name": "Prefer",
            "in": "header",
            "description": "For HTTP PUT requests, instructs the service to return the created/updated resource on success.",
            "required": true,
            "type": "string",
            "enum": [
              "return=representation"
            ],
            "x-ms-enum": {
              "modelAsString": false
            },
            "x-ms-client-name": "prefer"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexerName",
            "in": "path",
            "description": "The name of the indexer.",
            "required": true,
            "type": "string"
          },
          {
            "name": "indexer",
            "in": "body",
            "description": "The definition of the indexer to create or update.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchIndexer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndexer"
            }
          },
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SearchIndexer"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateOrUpdateIndexer": {
            "$ref": "./examples/SearchServiceCreateOrUpdateIndexer.json"
          }
        }
      },
      "delete": {
        "operationId": "Indexers_Delete",
        "description": "Deletes an indexer.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexerName",
            "in": "path",
            "description": "The name of the indexer.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "There is no content to send for this request, but the headers may be useful. "
          },
          "404": {
            "description": "The server cannot find the requested resource."
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceDeleteIndexer": {
            "$ref": "./examples/SearchServiceDeleteIndexer.json"
          }
        }
      }
    },
    "/indexers('{indexerName}')/search.reset": {
      "post": {
        "operationId": "Indexers_Reset",
        "description": "Resets the change tracking state associated with an indexer.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexerName",
            "in": "path",
            "description": "The name of the indexer.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "There is no content to send for this request, but the headers may be useful. "
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceResetIndexer": {
            "$ref": "./examples/SearchServiceResetIndexer.json"
          }
        }
      }
    },
    "/indexers('{indexerName}')/search.run": {
      "post": {
        "operationId": "Indexers_Run",
        "description": "Runs an indexer on-demand.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexerName",
            "in": "path",
            "description": "The name of the indexer.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "The request has been accepted for processing, but processing has not yet completed."
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceRunIndexer": {
            "$ref": "./examples/SearchServiceRunIndexer.json"
          }
        }
      }
    },
    "/indexers('{indexerName}')/search.status": {
      "get": {
        "operationId": "Indexers_GetStatus",
        "description": "Returns the current status and execution history of an indexer.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexerName",
            "in": "path",
            "description": "The name of the indexer.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceGetIndexerStatus": {
            "$ref": "./examples/SearchServiceGetIndexerStatus.json"
          }
        }
      }
    },
    "/indexes": {
      "get": {
        "operationId": "Indexes_List",
        "description": "Lists all indexes available for a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Selects which top-level properties to retrieve.\nSpecified as a comma-separated list of JSON property names,\nor '*' for all properties. The default is all properties.",
            "required": false,
            "type": "string"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/ListIndexesResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceListIndexes": {
            "$ref": "./examples/SearchServiceListIndexes.json"
          }
        }
      },
      "post": {
        "operationId": "Indexes_Create",
        "description": "Creates a new search index.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "index",
            "in": "body",
            "description": "The definition of the index to create.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchIndex"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SearchIndex"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateIndex": {
            "$ref": "./examples/SearchServiceCreateIndex.json"
          }
        }
      }
    },
    "/indexes('{indexName}')": {
      "get": {
        "operationId": "Indexes_Get",
        "description": "Retrieves an index definition.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndex"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceGetIndex": {
            "$ref": "./examples/SearchServiceGetIndex.json"
          }
        }
      },
      "put": {
        "operationId": "Indexes_CreateOrUpdate",
        "description": "Creates a new search index or updates an index if it already exists.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "name": "allowIndexDowntime",
            "in": "query",
            "description": "Allows new analyzers, tokenizers, token filters, or char filters to be added to\nan index by taking the index offline for at least a few seconds. This\ntemporarily causes indexing and query requests to fail. Performance and write\navailability of the index can be impaired for several minutes after the index\nis updated, or longer for very large indexes.",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "Prefer",
            "in": "header",
            "description": "For HTTP PUT requests, instructs the service to return the created/updated resource on success.",
            "required": true,
            "type": "string",
            "enum": [
              "return=representation"
            ],
            "x-ms-enum": {
              "modelAsString": false
            },
            "x-ms-client-name": "prefer"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          },
          {
            "name": "index",
            "in": "body",
            "description": "The definition of the index to create or update.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchIndex"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndex"
            }
          },
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SearchIndex"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateOrUpdateIndex": {
            "$ref": "./examples/SearchServiceCreateOrUpdateIndex.json"
          }
        }
      },
      "delete": {
        "operationId": "Indexes_Delete",
        "description": "Deletes a search index and all the documents it contains. This operation is\npermanent, with no recovery option. Make sure you have a master copy of your\nindex definition, data ingestion code, and a backup of the primary data source\nin case you need to re-build the index.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "There is no content to send for this request, but the headers may be useful. "
          },
          "404": {
            "description": "The server cannot find the requested resource."
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceDeleteIndex": {
            "$ref": "./examples/SearchServiceDeleteIndex.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs": {
      "get": {
        "operationId": "Documents_SearchGet",
        "description": "Searches for documents in the index.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "search",
            "in": "query",
            "description": "A full-text search query expression; Use \"*\" or omit this parameter to match\nall documents.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "searchText"
          },
          {
            "name": "$count",
            "in": "query",
            "description": "A value that specifies whether to fetch the total count of results. Default is\nfalse. Setting this value to true may have a performance impact. Note that the\ncount returned is an approximation.",
            "required": false,
            "type": "boolean",
            "x-ms-client-name": "includeTotalResultCount"
          },
          {
            "name": "facet",
            "in": "query",
            "description": "The list of facet expressions to apply to the search query. Each facet\nexpression contains a field name, optionally followed by a comma-separated list\nof name:value pairs.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "x-ms-client-name": "facets"
          },
          {
            "name": "$filter",
            "in": "query",
            "description": "The OData $filter expression to apply to the search query.",
            "required": false,
            "type": "string"
          },
          {
            "name": "highlight",
            "in": "query",
            "description": "The list of field names to use for hit highlights. Only searchable fields can\nbe used for hit highlighting.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv",
            "x-ms-client-name": "highlightFields"
          },
          {
            "name": "highlightPostTag",
            "in": "query",
            "description": "A string tag that is appended to hit highlights. Must be set with\nhighlightPreTag. Default is &lt;/em&gt;.",
            "required": false,
            "type": "string"
          },
          {
            "name": "highlightPreTag",
            "in": "query",
            "description": "A string tag that is prepended to hit highlights. Must be set with\nhighlightPostTag. Default is &lt;em&gt;.",
            "required": false,
            "type": "string"
          },
          {
            "name": "minimumCoverage",
            "in": "query",
            "description": "A number between 0 and 100 indicating the percentage of the index that must be\ncovered by a search query in order for the query to be reported as a success.\nThis parameter can be useful for ensuring search availability even for services\nwith only one replica. The default is 100.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "The list of OData $orderby expressions by which to sort the results. Each\nexpression can be either a field name or a call to either the geo.distance() or\nthe search.score() functions. Each expression can be followed by asc to\nindicate ascending, and desc to indicate descending. The default is ascending\norder. Ties will be broken by the match scores of documents. If no OrderBy is\nspecified, the default sort order is descending by document match score. There\ncan be at most 32 $orderby clauses.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv",
            "x-ms-client-name": "orderBy"
          },
          {
            "name": "queryType",
            "in": "query",
            "description": "A value that specifies the syntax of the search query. The default is 'simple'.\nUse 'full' if your query uses the Lucene query syntax.",
            "required": false,
            "type": "string",
            "enum": [
              "simple",
              "full",
              "semantic"
            ],
            "x-ms-enum": {
              "name": "QueryType",
              "modelAsString": true,
              "values": [
                {
                  "name": "Simple",
                  "value": "simple",
                  "description": "Uses the simple query syntax for searches. Search text is interpreted using a\nsimple query language that allows for symbols such as +, * and \"\". Queries are\nevaluated across all searchable fields by default, unless the searchFields\nparameter is specified."
                },
                {
                  "name": "Full",
                  "value": "full",
                  "description": "Uses the full Lucene query syntax for searches. Search text is interpreted\nusing the Lucene query language which allows field-specific and weighted\nsearches, as well as other advanced features."
                },
                {
                  "name": "Semantic",
                  "value": "semantic",
                  "description": "Best suited for queries expressed in natural language as opposed to keywords.\nImproves precision of search results by re-ranking the top search results using\na ranking model trained on the Web corpus."
                }
              ]
            }
          },
          {
            "name": "scoringParameter",
            "in": "query",
            "description": "The list of parameter values to be used in scoring functions (for example,\nreferencePointParameter) using the format name-values. For example, if the\nscoring profile defines a function with a parameter called 'mylocation' the\nparameter string would be \"mylocation--122.2,44.8\" (without the quotes).",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi",
            "x-ms-client-name": "scoringParameters"
          },
          {
            "name": "scoringProfile",
            "in": "query",
            "description": "The name of a scoring profile to evaluate match scores for matching documents\nin order to sort the results.",
            "required": false,
            "type": "string"
          },
          {
            "name": "searchFields",
            "in": "query",
            "description": "The list of field names to which to scope the full-text search. When using\nfielded search (fieldName:searchExpression) in a full Lucene query, the field\nnames of each fielded search expression take precedence over any field names\nlisted in this parameter.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "searchMode",
            "in": "query",
            "description": "A value that specifies whether any or all of the search terms must be matched\nin order to count the document as a match.",
            "required": false,
            "type": "string",
            "enum": [
              "any",
              "all"
            ],
            "x-ms-enum": {
              "name": "SearchMode",
              "modelAsString": true,
              "values": [
                {
                  "name": "Any",
                  "value": "any",
                  "description": "Any of the search terms must be matched in order to count the document as a\nmatch."
                },
                {
                  "name": "All",
                  "value": "all",
                  "description": "All of the search terms must be matched in order to count the document as a\nmatch."
                }
              ]
            }
          },
          {
            "name": "scoringStatistics",
            "in": "query",
            "description": "A value that specifies whether we want to calculate scoring statistics (such as\ndocument frequency) globally for more consistent scoring, or locally, for lower\nlatency.",
            "required": false,
            "type": "string",
            "enum": [
              "local",
              "global"
            ],
            "x-ms-enum": {
              "name": "ScoringStatistics",
              "modelAsString": true,
              "values": [
                {
                  "name": "Local",
                  "value": "local",
                  "description": "The scoring statistics will be calculated locally for lower latency."
                },
                {
                  "name": "Global",
                  "value": "global",
                  "description": "The scoring statistics will be calculated globally for more consistent scoring."
                }
              ]
            }
          },
          {
            "name": "sessionId",
            "in": "query",
            "description": "A value to be used to create a sticky session, which can help to get more\nconsistent results. As long as the same sessionId is used, a best-effort\nattempt will be made to target the same replica set. Be wary that reusing the\nsame sessionID values repeatedly can interfere with the load balancing of the\nrequests across replicas and adversely affect the performance of the search\nservice. The value used as sessionId cannot start with a '_' character.",
            "required": false,
            "type": "string"
          },
          {
            "name": "$select",
            "in": "query",
            "description": "The list of fields to retrieve. If unspecified, all fields marked as\nretrievable in the schema are included.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "$skip",
            "in": "query",
            "description": "The number of search results to skip. This value cannot be greater than\n100,000. If you need to scan documents in sequence, but cannot use $skip due to\nthis limitation, consider using $orderby on a totally-ordered key and $filter\nwith a range query instead.",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "$top",
            "in": "query",
            "description": "The number of search results to retrieve. This can be used in conjunction with\n$skip to implement client-side paging of search results. If results are\ntruncated due to server-side paging, the response will include a continuation\ntoken that can be used to issue another Search request for the next page of\nresults.",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "semanticConfiguration",
            "in": "query",
            "description": "The name of the semantic configuration that lists which fields should be used\nfor semantic ranking, captions, highlights, and answers",
            "required": false,
            "type": "string"
          },
          {
            "name": "semanticErrorHandling",
            "in": "query",
            "description": "Allows the user to choose whether a semantic call should fail completely, or to\nreturn partial results (default).",
            "required": false,
            "type": "string",
            "enum": [
              "partial",
              "fail"
            ],
            "x-ms-enum": {
              "name": "SemanticErrorMode",
              "modelAsString": true,
              "values": [
                {
                  "name": "Partial",
                  "value": "partial",
                  "description": "If the semantic processing fails, partial results still return. The definition\nof partial results depends on what semantic step failed and what was the reason\nfor failure."
                },
                {
                  "name": "Fail",
                  "value": "fail",
                  "description": "If there is an exception during the semantic processing step, the query will\nfail and return the appropriate HTTP code depending on the error."
                }
              ]
            }
          },
          {
            "name": "semanticMaxWaitInMilliseconds",
            "in": "query",
            "description": "Allows the user to set an upper bound on the amount of time it takes for\nsemantic enrichment to finish processing before the request fails.",
            "required": false,
            "type": "integer",
            "format": "int32",
            "minimum": 700
          },
          {
            "name": "answers",
            "in": "query",
            "description": "This parameter is only valid if the query type is `semantic`. If set, the query\nreturns answers extracted from key passages in the highest ranked documents.\nThe number of answers returned can be configured by appending the pipe\ncharacter `|` followed by the `count-<number of answers>` option after the\nanswers parameter value, such as `extractive|count-3`. Default count is 1. The\nconfidence threshold can be configured by appending the pipe character `|`\nfollowed by the `threshold-<confidence threshold>` option after the answers\nparameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.",
            "required": false,
            "type": "string",
            "enum": [
              "none",
              "extractive"
            ],
            "x-ms-enum": {
              "name": "QueryAnswerType",
              "modelAsString": true,
              "values": [
                {
                  "name": "None",
                  "value": "none",
                  "description": "Do not return answers for the query."
                },
                {
                  "name": "Extractive",
                  "value": "extractive",
                  "description": "Extracts answer candidates from the contents of the documents returned in\nresponse to a query expressed as a question in natural language."
                }
              ]
            }
          },
          {
            "name": "captions",
            "in": "query",
            "description": "This parameter is only valid if the query type is `semantic`. If set, the query\nreturns captions extracted from key passages in the highest ranked documents.\nWhen Captions is set to `extractive`, highlighting is enabled by default, and\ncan be configured by appending the pipe character `|` followed by the\n`highlight-<true/false>` option, such as `extractive|highlight-true`. Defaults\nto `None`.",
            "required": false,
            "type": "string",
            "enum": [
              "none",
              "extractive"
            ],
            "x-ms-enum": {
              "name": "QueryCaptionType",
              "modelAsString": true,
              "values": [
                {
                  "name": "None",
                  "value": "none",
                  "description": "Do not return captions for the query."
                },
                {
                  "name": "Extractive",
                  "value": "extractive",
                  "description": "Extracts captions from the matching documents that contain passages relevant to\nthe search query."
                }
              ]
            }
          },
          {
            "name": "semanticQuery",
            "in": "query",
            "description": "Allows setting a separate search query that will be solely used for semantic\nreranking, semantic captions and semantic answers. Is useful for scenarios\nwhere there is a need to use different queries between the base retrieval and\nranking phase, and the L2 semantic phase.",
            "required": false,
            "type": "string"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchDocumentsResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexSearchDocumentsGet": {
            "$ref": "./examples/SearchIndexSearchDocumentsGet.json"
          },
          "SearchIndexSearchDocumentsSemanticGet": {
            "$ref": "./examples/SearchIndexSearchDocumentsSemanticGet.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs/$count": {
      "get": {
        "operationId": "Documents_Count",
        "description": "Queries the number of documents in the index.",
        "produces": [
          "text/plain",
          "application/json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexCountDocuments": {
            "$ref": "./examples/SearchIndexCountDocuments.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs/search.autocomplete": {
      "get": {
        "operationId": "Documents_AutocompleteGet",
        "description": "Autocompletes incomplete query terms based on input text and matching terms in\nthe index.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "search",
            "in": "query",
            "description": "The incomplete term which should be auto-completed.",
            "required": true,
            "type": "string",
            "x-ms-client-name": "searchText"
          },
          {
            "name": "suggesterName",
            "in": "query",
            "description": "The name of the suggester as specified in the suggesters collection that's part\nof the index definition.",
            "required": true,
            "type": "string"
          },
          {
            "name": "autocompleteMode",
            "in": "query",
            "description": "Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'\nto get shingles and 'oneTermWithContext' to use the current context while\nproducing auto-completed terms.",
            "required": false,
            "type": "string",
            "enum": [
              "oneTerm",
              "twoTerms",
              "oneTermWithContext"
            ],
            "x-ms-enum": {
              "name": "AutocompleteMode",
              "modelAsString": true,
              "values": [
                {
                  "name": "OneTerm",
                  "value": "oneTerm",
                  "description": "Only one term is suggested. If the query has two terms, only the last term is\ncompleted. For example, if the input is 'washington medic', the suggested terms\ncould include 'medicaid', 'medicare', and 'medicine'."
                },
                {
                  "name": "TwoTerms",
                  "value": "twoTerms",
                  "description": "Matching two-term phrases in the index will be suggested. For example, if the\ninput is 'medic', the suggested terms could include 'medicare coverage' and 'medical assistant'."
                },
                {
                  "name": "OneTermWithContext",
                  "value": "oneTermWithContext",
                  "description": "Completes the last term in a query with two or more terms, where the last two\nterms are a phrase that exists in the index. For example, if the input is 'washington medic', the suggested terms could include 'washington medicaid' and 'washington medical'."
                }
              ]
            }
          },
          {
            "name": "$filter",
            "in": "query",
            "description": "An OData expression that filters the documents used to produce completed terms\nfor the Autocomplete result.",
            "required": false,
            "type": "string"
          },
          {
            "name": "fuzzy",
            "in": "query",
            "description": "A value indicating whether to use fuzzy matching for the autocomplete query.\nDefault is false. When set to true, the query will find terms even if there's a\nsubstituted or missing character in the search text. While this provides a\nbetter experience in some scenarios, it comes at a performance cost as fuzzy\nautocomplete queries are slower and consume more resources.",
            "required": false,
            "type": "boolean",
            "x-ms-client-name": "useFuzzyMatching"
          },
          {
            "name": "highlightPostTag",
            "in": "query",
            "description": "A string tag that is appended to hit highlights. Must be set with\nhighlightPreTag. If omitted, hit highlighting is disabled.",
            "required": false,
            "type": "string"
          },
          {
            "name": "highlightPreTag",
            "in": "query",
            "description": "A string tag that is prepended to hit highlights. Must be set with\nhighlightPostTag. If omitted, hit highlighting is disabled.",
            "required": false,
            "type": "string"
          },
          {
            "name": "minimumCoverage",
            "in": "query",
            "description": "A number between 0 and 100 indicating the percentage of the index that must be\ncovered by an autocomplete query in order for the query to be reported as a\nsuccess. This parameter can be useful for ensuring search availability even for\nservices with only one replica. The default is 80.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "searchFields",
            "in": "query",
            "description": "The list of field names to consider when querying for auto-completed terms.\nTarget fields must be included in the specified suggester.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "$top",
            "in": "query",
            "description": "The number of auto-completed terms to retrieve. This must be a value between 1\nand 100. The default is 5.",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/AutocompleteResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexAutocompleteDocumentsGet": {
            "$ref": "./examples/SearchIndexAutocompleteDocumentsGet.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs/search.index": {
      "post": {
        "operationId": "Documents_Index",
        "description": "Sends a batch of document write actions to the index.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          },
          {
            "name": "batch",
            "in": "body",
            "description": "The batch of index actions.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/IndexBatch"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response containing the status of operations for all documents in the indexing\nrequest.",
            "schema": {
              "$ref": "#/definitions/IndexDocumentsResult"
            }
          },
          "207": {
            "description": "Response containing the status of operations for all documents in the indexing\nrequest.",
            "schema": {
              "$ref": "#/definitions/IndexDocumentsResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexIndexDocuments": {
            "$ref": "./examples/SearchIndexIndexDocuments.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs/search.post.autocomplete": {
      "post": {
        "operationId": "Documents_AutocompletePost",
        "description": "Autocompletes incomplete query terms based on input text and matching terms in\nthe index.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          },
          {
            "name": "autocompleteRequest",
            "in": "body",
            "description": "The definition of the Autocomplete request.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AutocompleteRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/AutocompleteResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexAutocompleteDocumentsPost": {
            "$ref": "./examples/SearchIndexAutocompleteDocumentsPost.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs/search.post.search": {
      "post": {
        "operationId": "Documents_SearchPost",
        "description": "Searches for documents in the index.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          },
          {
            "name": "searchRequest",
            "in": "body",
            "description": "The definition of the Search request.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchDocumentsResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexSearchDocumentsPost": {
            "$ref": "./examples/SearchIndexSearchDocumentsPost.json"
          },
          "SearchIndexSearchDocumentsSemanticPost": {
            "$ref": "./examples/SearchIndexSearchDocumentsSemanticPost.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs/search.post.suggest": {
      "post": {
        "operationId": "Documents_SuggestPost",
        "description": "Suggests documents in the index that match the given partial query text.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          },
          {
            "name": "suggestRequest",
            "in": "body",
            "description": "The Suggest request.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SuggestRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SuggestDocumentsResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexSuggestDocumentsPost": {
            "$ref": "./examples/SearchIndexSuggestDocumentsPost.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs/search.suggest": {
      "get": {
        "operationId": "Documents_SuggestGet",
        "description": "Suggests documents in the index that match the given partial query text.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "search",
            "in": "query",
            "description": "The search text to use to suggest documents. Must be at least 1 character, and\nno more than 100 characters.",
            "required": true,
            "type": "string",
            "x-ms-client-name": "searchText"
          },
          {
            "name": "suggesterName",
            "in": "query",
            "description": "The name of the suggester as specified in the suggesters collection that's part\nof the index definition.",
            "required": true,
            "type": "string"
          },
          {
            "name": "$filter",
            "in": "query",
            "description": "An OData expression that filters the documents considered for suggestions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "fuzzy",
            "in": "query",
            "description": "A value indicating whether to use fuzzy matching for the suggestions query.\nDefault is false. When set to true, the query will find terms even if there's a\nsubstituted or missing character in the search text. While this provides a\nbetter experience in some scenarios, it comes at a performance cost as fuzzy\nsuggestions queries are slower and consume more resources.",
            "required": false,
            "type": "boolean",
            "x-ms-client-name": "useFuzzyMatching"
          },
          {
            "name": "highlightPostTag",
            "in": "query",
            "description": "A string tag that is appended to hit highlights. Must be set with\nhighlightPreTag. If omitted, hit highlighting of suggestions is disabled.",
            "required": false,
            "type": "string"
          },
          {
            "name": "highlightPreTag",
            "in": "query",
            "description": "A string tag that is prepended to hit highlights. Must be set with\nhighlightPostTag. If omitted, hit highlighting of suggestions is disabled.",
            "required": false,
            "type": "string"
          },
          {
            "name": "minimumCoverage",
            "in": "query",
            "description": "A number between 0 and 100 indicating the percentage of the index that must be\ncovered by a suggestions query in order for the query to be reported as a\nsuccess. This parameter can be useful for ensuring search availability even for\nservices with only one replica. The default is 80.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "$orderby",
            "in": "query",
            "description": "The list of OData $orderby expressions by which to sort the results. Each\nexpression can be either a field name or a call to either the geo.distance() or\nthe search.score() functions. Each expression can be followed by asc to\nindicate ascending, or desc to indicate descending. The default is ascending\norder. Ties will be broken by the match scores of documents. If no $orderby is\nspecified, the default sort order is descending by document match score. There\ncan be at most 32 $orderby clauses.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv",
            "x-ms-client-name": "orderBy"
          },
          {
            "name": "searchFields",
            "in": "query",
            "description": "The list of field names to search for the specified search text. Target fields\nmust be included in the specified suggester.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "$select",
            "in": "query",
            "description": "The list of fields to retrieve. If unspecified, only the key field will be\nincluded in the results.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "$top",
            "in": "query",
            "description": "The number of suggestions to retrieve. The value must be a number between 1 and\n100. The default is 5.",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SuggestDocumentsResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexSuggestDocumentsGet": {
            "$ref": "./examples/SearchIndexSuggestDocumentsGet.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/docs('{key}')": {
      "get": {
        "operationId": "Documents_Get",
        "description": "Retrieves a document from the index.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "key",
            "in": "path",
            "description": "The key of the document to retrieve.",
            "required": true,
            "type": "string"
          },
          {
            "name": "$select",
            "in": "query",
            "description": "List of field names to retrieve for the document; Any field not retrieved will\nbe missing from the returned document.",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv",
            "x-ms-client-name": "selectedFields"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/LookupDocument"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchIndexGetDocument": {
            "$ref": "./examples/SearchIndexGetDocument.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/search.analyze": {
      "post": {
        "operationId": "Indexes_Analyze",
        "description": "Shows how an analyzer breaks text into tokens.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          },
          {
            "name": "request",
            "in": "body",
            "description": "The text and analyzer or analysis components to test.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AnalyzeRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/AnalyzeResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceIndexAnalyze": {
            "$ref": "./examples/SearchServiceIndexAnalyze.json"
          }
        }
      }
    },
    "/indexes('{indexName}')/search.stats": {
      "get": {
        "operationId": "Indexes_GetStatistics",
        "description": "Returns statistics for the given index, including a document count and storage\nusage.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/GetIndexStatisticsResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceGetIndexStatistics": {
            "$ref": "./examples/SearchServiceGetIndexStatistics.json"
          }
        }
      }
    },
    "/servicestats": {
      "get": {
        "operationId": "GetServiceStatistics",
        "description": "Gets service level statistics for a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchServiceStatistics"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceGetServiceStatistics": {
            "$ref": "./examples/SearchServiceGetServiceStatistics.json"
          }
        }
      }
    },
    "/skillsets": {
      "get": {
        "operationId": "Skillsets_List",
        "description": "List all skillsets in a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Selects which top-level properties to retrieve.\nSpecified as a comma-separated list of JSON property names,\nor '*' for all properties. The default is all properties.",
            "required": false,
            "type": "string"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/ListSkillsetsResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceListSkillsets": {
            "$ref": "./examples/SearchServiceListSkillsets.json"
          }
        }
      },
      "post": {
        "operationId": "Skillsets_Create",
        "description": "Creates a new skillset in a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "skillset",
            "in": "body",
            "description": "The skillset containing one or more skills to create in a search service.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchIndexerSkillset"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerSkillset"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateSkillset": {
            "$ref": "./examples/SearchServiceCreateSkillset.json"
          }
        }
      }
    },
    "/skillsets('{skillsetName}')": {
      "get": {
        "operationId": "Skillsets_Get",
        "description": "Retrieves a skillset in a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "skillsetName",
            "in": "path",
            "description": "The name of the skillset.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerSkillset"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceGetSkillset": {
            "$ref": "./examples/SearchServiceGetSkillset.json"
          }
        }
      },
      "put": {
        "operationId": "Skillsets_CreateOrUpdate",
        "description": "Creates a new skillset in a search service or updates the skillset if it\nalready exists.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "name": "Prefer",
            "in": "header",
            "description": "For HTTP PUT requests, instructs the service to return the created/updated resource on success.",
            "required": true,
            "type": "string",
            "enum": [
              "return=representation"
            ],
            "x-ms-enum": {
              "modelAsString": false
            },
            "x-ms-client-name": "prefer"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "skillsetName",
            "in": "path",
            "description": "The name of the skillset.",
            "required": true,
            "type": "string"
          },
          {
            "name": "skillset",
            "in": "body",
            "description": "The skillset containing one or more skills to create or update in a search\nservice.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchIndexerSkillset"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerSkillset"
            }
          },
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SearchIndexerSkillset"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateOrUpdateSkillset": {
            "$ref": "./examples/SearchServiceCreateOrUpdateSkillset.json"
          }
        }
      },
      "delete": {
        "operationId": "Skillsets_Delete",
        "description": "Deletes a skillset in a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "skillsetName",
            "in": "path",
            "description": "The name of the skillset.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "There is no content to send for this request, but the headers may be useful. "
          },
          "404": {
            "description": "The server cannot find the requested resource."
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceDeleteSkillset": {
            "$ref": "./examples/SearchServiceDeleteSkillset.json"
          }
        }
      }
    },
    "/synonymmaps": {
      "get": {
        "operationId": "SynonymMaps_List",
        "description": "Lists all synonym maps available for a search service.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "$select",
            "in": "query",
            "description": "Selects which top-level properties to retrieve.\nSpecified as a comma-separated list of JSON property names,\nor '*' for all properties. The default is all properties.",
            "required": false,
            "type": "string"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/ListSynonymMapsResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceListSynonymMaps": {
            "$ref": "./examples/SearchServiceListSynonymMaps.json"
          }
        }
      },
      "post": {
        "operationId": "SynonymMaps_Create",
        "description": "Creates a new synonym map.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "synonymMap",
            "in": "body",
            "description": "The definition of the synonym map to create.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SynonymMap"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SynonymMap"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateSynonymMap": {
            "$ref": "./examples/SearchServiceCreateSynonymMap.json"
          }
        }
      }
    },
    "/synonymmaps('{synonymMapName}')": {
      "get": {
        "operationId": "SynonymMaps_Get",
        "description": "Retrieves a synonym map definition.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "synonymMapName",
            "in": "path",
            "description": "The name of the synonym map.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SynonymMap"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceGetSynonymMap": {
            "$ref": "./examples/SearchServiceGetSynonymMap.json"
          }
        }
      },
      "put": {
        "operationId": "SynonymMaps_CreateOrUpdate",
        "description": "Creates a new synonym map or updates a synonym map if it already exists.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "name": "Prefer",
            "in": "header",
            "description": "For HTTP PUT requests, instructs the service to return the created/updated resource on success.",
            "required": true,
            "type": "string",
            "enum": [
              "return=representation"
            ],
            "x-ms-enum": {
              "modelAsString": false
            },
            "x-ms-client-name": "prefer"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "synonymMapName",
            "in": "path",
            "description": "The name of the synonym map.",
            "required": true,
            "type": "string"
          },
          {
            "name": "synonymMap",
            "in": "body",
            "description": "The definition of the synonym map to create or update.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SynonymMap"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SynonymMap"
            }
          },
          "201": {
            "description": "The request has succeeded and a new resource has been created as a result.",
            "schema": {
              "$ref": "#/definitions/SynonymMap"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceCreateOrUpdateSynonymMap": {
            "$ref": "./examples/SearchServiceCreateOrUpdateSynonymMap.json"
          }
        }
      },
      "delete": {
        "operationId": "SynonymMaps_Delete",
        "description": "Deletes a synonym map.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifMatch"
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value.",
            "required": false,
            "type": "string",
            "x-ms-client-name": "ifNoneMatch"
          },
          {
            "$ref": "#/parameters/Azure.Core.ClientRequestIdHeader"
          },
          {
            "name": "synonymMapName",
            "in": "path",
            "description": "The name of the synonym map.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "There is no content to send for this request, but the headers may be useful. "
          },
          "404": {
            "description": "The server cannot find the requested resource."
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "SearchServiceDeleteSynonymMap": {
            "$ref": "./examples/SearchServiceDeleteSynonymMap.json"
          }
        }
      }
    }
  },
  "definitions": {
    "AnalyzeRequest": {
      "type": "object",
      "description": "Specifies some text and analysis components used to break that text into tokens.",
      "properties": {
        "text": {
          "type": "string",
          "description": "The text to break into tokens."
        },
        "analyzer": {
          "$ref": "#/definitions/LexicalAnalyzerName",
          "description": "The name of the analyzer to use to break the given text. If this parameter is\nnot specified, you must specify a tokenizer instead. The tokenizer and analyzer\nparameters are mutually exclusive."
        },
        "tokenizer": {
          "$ref": "#/definitions/LexicalTokenizerName",
          "description": "The name of the tokenizer to use to break the given text. If this parameter is\nnot specified, you must specify an analyzer instead. The tokenizer and analyzer\nparameters are mutually exclusive."
        },
        "tokenFilters": {
          "type": "array",
          "description": "An optional list of token filters to use when breaking the given text. This\nparameter can only be set when using the tokenizer parameter.",
          "items": {
            "$ref": "#/definitions/TokenFilterName"
          }
        },
        "charFilters": {
          "type": "array",
          "description": "An optional list of character filters to use when breaking the given text. This\nparameter can only be set when using the tokenizer parameter.",
          "items": {
            "$ref": "#/definitions/CharFilterName"
          }
        }
      },
      "required": [
        "text"
      ]
    },
    "AnalyzeResult": {
      "type": "object",
      "description": "The result of testing an analyzer on text.",
      "properties": {
        "tokens": {
          "type": "array",
          "description": "The list of tokens returned by the analyzer specified in the request.",
          "items": {
            "$ref": "#/definitions/AnalyzedTokenInfo"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "tokens"
      ]
    },
    "AnalyzedTokenInfo": {
      "type": "object",
      "description": "Information about a token returned by an analyzer.",
      "properties": {
        "token": {
          "type": "string",
          "description": "The token returned by the analyzer."
        },
        "startOffset": {
          "type": "integer",
          "format": "int32",
          "description": "The index of the first character of the token in the input text."
        },
        "endOffset": {
          "type": "integer",
          "format": "int32",
          "description": "The index of the last character of the token in the input text."
        },
        "position": {
          "type": "integer",
          "format": "int32",
          "description": "The position of the token in the input text relative to other tokens. The first\ntoken in the input text has position 0, the next has position 1, and so on.\nDepending on the analyzer used, some tokens might have the same position, for\nexample if they are synonyms of each other."
        }
      },
      "required": [
        "token",
        "startOffset",
        "endOffset",
        "position"
      ]
    },
    "AsciiFoldingTokenFilter": {
      "type": "object",
      "description": "Converts alphabetic, numeric, and symbolic Unicode characters which are not in\nthe first 127 ASCII characters (the \"Basic Latin\" Unicode block) into their\nASCII equivalents, if such equivalents exist. This token filter is implemented\nusing Apache Lucene.",
      "properties": {
        "preserveOriginal": {
          "type": "boolean",
          "description": "A value indicating whether the original token will be kept. Default is false."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.AsciiFoldingTokenFilter"
    },
    "AutocompleteItem": {
      "type": "object",
      "description": "The result of Autocomplete requests.",
      "properties": {
        "text": {
          "type": "string",
          "description": "The completed term."
        },
        "queryPlusText": {
          "type": "string",
          "description": "The query along with the completed term."
        }
      },
      "required": [
        "text",
        "queryPlusText"
      ]
    },
    "AutocompleteMode": {
      "type": "string",
      "description": "Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'\nto get shingles and 'oneTermWithContext' to use the current context in\nproducing autocomplete terms.",
      "enum": [
        "oneTerm",
        "twoTerms",
        "oneTermWithContext"
      ],
      "x-ms-enum": {
        "name": "AutocompleteMode",
        "modelAsString": true,
        "values": [
          {
            "name": "OneTerm",
            "value": "oneTerm",
            "description": "Only one term is suggested. If the query has two terms, only the last term is\ncompleted. For example, if the input is 'washington medic', the suggested terms\ncould include 'medicaid', 'medicare', and 'medicine'."
          },
          {
            "name": "TwoTerms",
            "value": "twoTerms",
            "description": "Matching two-term phrases in the index will be suggested. For example, if the\ninput is 'medic', the suggested terms could include 'medicare coverage' and 'medical assistant'."
          },
          {
            "name": "OneTermWithContext",
            "value": "oneTermWithContext",
            "description": "Completes the last term in a query with two or more terms, where the last two\nterms are a phrase that exists in the index. For example, if the input is 'washington medic', the suggested terms could include 'washington medicaid' and 'washington medical'."
          }
        ]
      }
    },
    "AutocompleteRequest": {
      "type": "object",
      "description": "Parameters for fuzzy matching, and other autocomplete query behaviors.",
      "properties": {
        "search": {
          "type": "string",
          "description": "The search text on which to base autocomplete results."
        },
        "autocompleteMode": {
          "$ref": "#/definitions/AutocompleteMode",
          "description": "Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'\nto get shingles and 'oneTermWithContext' to use the current context while\nproducing auto-completed terms."
        },
        "filter": {
          "type": "string",
          "description": "An OData expression that filters the documents used to produce completed terms\nfor the Autocomplete result."
        },
        "fuzzy": {
          "type": "boolean",
          "description": "A value indicating whether to use fuzzy matching for the autocomplete query.\nDefault is false. When set to true, the query will autocomplete terms even if\nthere's a substituted or missing character in the search text. While this\nprovides a better experience in some scenarios, it comes at a performance cost\nas fuzzy autocomplete queries are slower and consume more resources."
        },
        "highlightPostTag": {
          "type": "string",
          "description": "A string tag that is appended to hit highlights. Must be set with\nhighlightPreTag. If omitted, hit highlighting is disabled."
        },
        "highlightPreTag": {
          "type": "string",
          "description": "A string tag that is prepended to hit highlights. Must be set with\nhighlightPostTag. If omitted, hit highlighting is disabled."
        },
        "minimumCoverage": {
          "type": "number",
          "format": "double",
          "description": "A number between 0 and 100 indicating the percentage of the index that must be\ncovered by an autocomplete query in order for the query to be reported as a\nsuccess. This parameter can be useful for ensuring search availability even for\nservices with only one replica. The default is 80."
        },
        "searchFields": {
          "type": "string",
          "description": "The comma-separated list of field names to consider when querying for\nauto-completed terms. Target fields must be included in the specified\nsuggester."
        },
        "suggesterName": {
          "type": "string",
          "description": "The name of the suggester as specified in the suggesters collection that's part\nof the index definition."
        },
        "top": {
          "type": "integer",
          "format": "int32",
          "description": "The number of auto-completed terms to retrieve. This must be a value between 1\nand 100. The default is 5."
        }
      },
      "required": [
        "search",
        "suggesterName"
      ]
    },
    "AutocompleteResult": {
      "type": "object",
      "description": "The result of Autocomplete query.",
      "properties": {
        "@search.coverage": {
          "type": "number",
          "format": "double",
          "description": "A value indicating the percentage of the index that was considered by the\nautocomplete request, or null if minimumCoverage was not specified in the\nrequest.",
          "x-ms-client-name": "coverage"
        },
        "value": {
          "type": "array",
          "description": "The list of returned Autocompleted items.",
          "items": {
            "$ref": "#/definitions/AutocompleteItem"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "value"
      ]
    },
    "AzureActiveDirectoryApplicationCredentials": {
      "type": "object",
      "description": "Credentials of a registered application created for your search service, used\nfor authenticated access to the encryption keys stored in Azure Key Vault.",
      "properties": {
        "applicationId": {
          "type": "string",
          "description": "An AAD Application ID that was granted the required access permissions to the\nAzure Key Vault that is to be used when encrypting your data at rest. The\nApplication ID should not be confused with the Object ID for your AAD\nApplication."
        },
        "applicationSecret": {
          "type": "string",
          "description": "The authentication key of the specified AAD application."
        }
      },
      "required": [
        "applicationId"
      ]
    },
    "AzureOpenAIEmbeddingSkill": {
      "type": "object",
      "description": "Allows you to generate a vector embedding for a given text input using the\nAzure OpenAI resource.",
      "properties": {
        "resourceUri": {
          "type": "string",
          "format": "uri",
          "description": "The resource URI of the Azure OpenAI resource."
        },
        "deploymentId": {
          "type": "string",
          "description": "ID of the Azure OpenAI model deployment on the designated resource."
        },
        "apiKey": {
          "type": "string",
          "description": "API key of the designated Azure OpenAI resource."
        },
        "authIdentity": {
          "$ref": "#/definitions/SearchIndexerDataIdentity",
          "description": "The user-assigned managed identity used for outbound connections."
        },
        "modelName": {
          "$ref": "#/definitions/AzureOpenAIModelName",
          "description": "The name of the embedding model that is deployed at the provided deploymentId\npath."
        },
        "dimensions": {
          "type": "integer",
          "format": "int32",
          "description": "The number of dimensions the resulting output embeddings should have. Only\nsupported in text-embedding-3 and later models."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill"
    },
    "AzureOpenAIModelName": {
      "type": "string",
      "description": "The Azure Open AI model name that will be called.",
      "enum": [
        "text-embedding-ada-002",
        "text-embedding-3-large",
        "text-embedding-3-small"
      ],
      "x-ms-enum": {
        "name": "AzureOpenAIModelName",
        "modelAsString": true,
        "values": [
          {
            "name": "TextEmbeddingAda002",
            "value": "text-embedding-ada-002",
            "description": "TextEmbeddingAda002 model."
          },
          {
            "name": "TextEmbedding3Large",
            "value": "text-embedding-3-large",
            "description": "TextEmbedding3Large model."
          },
          {
            "name": "TextEmbedding3Small",
            "value": "text-embedding-3-small",
            "description": "TextEmbedding3Small model."
          }
        ]
      }
    },
    "AzureOpenAIVectorizer": {
      "type": "object",
      "description": "Specifies the Azure OpenAI resource used to vectorize a query string.",
      "properties": {
        "azureOpenAIParameters": {
          "$ref": "#/definitions/AzureOpenAIVectorizerParameters",
          "description": "Contains the parameters specific to Azure OpenAI embedding vectorization."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/VectorSearchVectorizer"
        }
      ],
      "x-ms-discriminator-value": "azureOpenAI"
    },
    "AzureOpenAIVectorizerParameters": {
      "type": "object",
      "description": "Specifies the parameters for connecting to the Azure OpenAI resource.",
      "properties": {
        "resourceUri": {
          "type": "string",
          "format": "uri",
          "description": "The resource URI of the Azure OpenAI resource."
        },
        "deploymentId": {
          "type": "string",
          "description": "ID of the Azure OpenAI model deployment on the designated resource."
        },
        "apiKey": {
          "type": "string",
          "description": "API key of the designated Azure OpenAI resource."
        },
        "authIdentity": {
          "$ref": "#/definitions/SearchIndexerDataIdentity",
          "description": "The user-assigned managed identity used for outbound connections."
        },
        "modelName": {
          "$ref": "#/definitions/AzureOpenAIModelName",
          "description": "The name of the embedding model that is deployed at the provided deploymentId\npath."
        }
      }
    },
    "BM25SimilarityAlgorithm": {
      "type": "object",
      "description": "Ranking function based on the Okapi BM25 similarity algorithm. BM25 is a\nTF-IDF-like algorithm that includes length normalization (controlled by the 'b'\nparameter) as well as term frequency saturation (controlled by the 'k1'\nparameter).",
      "properties": {
        "k1": {
          "type": "number",
          "format": "double",
          "description": "This property controls the scaling function between the term frequency of each\nmatching terms and the final relevance score of a document-query pair. By\ndefault, a value of 1.2 is used. A value of 0.0 means the score does not scale\nwith an increase in term frequency."
        },
        "b": {
          "type": "number",
          "format": "double",
          "description": "This property controls how the length of a document affects the relevance\nscore. By default, a value of 0.75 is used. A value of 0.0 means no length\nnormalization is applied, while a value of 1.0 means the score is fully\nnormalized by the length of the document."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SimilarityAlgorithm"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.BM25Similarity"
    },
    "BinaryQuantizationCompression": {
      "type": "object",
      "description": "Contains configuration options specific to the binary quantization compression\nmethod used during indexing and querying.",
      "allOf": [
        {
          "$ref": "#/definitions/VectorSearchCompression"
        }
      ],
      "x-ms-discriminator-value": "binaryQuantization"
    },
    "BlobIndexerDataToExtract": {
      "type": "string",
      "description": "Specifies the data to extract from Azure blob storage and tells the indexer\nwhich data to extract from image content when \"imageAction\" is set to a value\nother than \"none\".  This applies to embedded image content in a .PDF or other\napplication, or image files such as .jpg and .png, in Azure blobs.",
      "enum": [
        "storageMetadata",
        "allMetadata",
        "contentAndMetadata"
      ],
      "x-ms-enum": {
        "name": "BlobIndexerDataToExtract",
        "modelAsString": true,
        "values": [
          {
            "name": "StorageMetadata",
            "value": "storageMetadata",
            "description": "Indexes just the standard blob properties and user-specified metadata."
          },
          {
            "name": "AllMetadata",
            "value": "allMetadata",
            "description": "Extracts metadata provided by the Azure blob storage subsystem and the\ncontent-type specific metadata (for example, metadata unique to just .png files\nare indexed)."
          },
          {
            "name": "ContentAndMetadata",
            "value": "contentAndMetadata",
            "description": "Extracts all metadata and textual content from each blob."
          }
        ]
      }
    },
    "BlobIndexerImageAction": {
      "type": "string",
      "description": "Determines how to process embedded images and image files in Azure blob\nstorage.  Setting the \"imageAction\" configuration to any value other than\n\"none\" requires that a skillset also be attached to that indexer.",
      "enum": [
        "none",
        "generateNormalizedImages",
        "generateNormalizedImagePerPage"
      ],
      "x-ms-enum": {
        "name": "BlobIndexerImageAction",
        "modelAsString": true,
        "values": [
          {
            "name": "None",
            "value": "none",
            "description": "Ignores embedded images or image files in the data set.  This is the default."
          },
          {
            "name": "GenerateNormalizedImages",
            "value": "generateNormalizedImages",
            "description": "Extracts text from images (for example, the word \"STOP\" from a traffic stop\nsign), and embeds it into the content field.  This action requires that\n\"dataToExtract\" is set to \"contentAndMetadata\".  A normalized image refers to\nadditional processing resulting in uniform image output, sized and rotated to\npromote consistent rendering when you include images in visual search results.\nThis information is generated for each image when you use this option."
          },
          {
            "name": "GenerateNormalizedImagePerPage",
            "value": "generateNormalizedImagePerPage",
            "description": "Extracts text from images (for example, the word \"STOP\" from a traffic stop\nsign), and embeds it into the content field, but treats PDF files differently\nin that each page will be rendered as an image and normalized accordingly,\ninstead of extracting embedded images.  Non-PDF file types will be treated the\nsame as if \"generateNormalizedImages\" was set."
          }
        ]
      }
    },
    "BlobIndexerPDFTextRotationAlgorithm": {
      "type": "string",
      "description": "Determines algorithm for text extraction from PDF files in Azure blob storage.",
      "enum": [
        "none",
        "detectAngles"
      ],
      "x-ms-enum": {
        "name": "BlobIndexerPDFTextRotationAlgorithm",
        "modelAsString": true,
        "values": [
          {
            "name": "None",
            "value": "none",
            "description": "Leverages normal text extraction.  This is the default."
          },
          {
            "name": "DetectAngles",
            "value": "detectAngles",
            "description": "May produce better and more readable text extraction from PDF files that have\nrotated text within them.  Note that there may be a small performance speed\nimpact when this parameter is used.  This parameter only applies to PDF files,\nand only to PDFs with embedded text.  If the rotated text appears within an\nembedded image in the PDF, this parameter does not apply."
          }
        ]
      }
    },
    "BlobIndexerParsingMode": {
      "type": "string",
      "description": "Represents the parsing mode for indexing from an Azure blob data source.",
      "enum": [
        "default",
        "text",
        "delimitedText",
        "json",
        "jsonArray",
        "jsonLines"
      ],
      "x-ms-enum": {
        "name": "BlobIndexerParsingMode",
        "modelAsString": true,
        "values": [
          {
            "name": "Default",
            "value": "default",
            "description": "Set to default for normal file processing."
          },
          {
            "name": "Text",
            "value": "text",
            "description": "Set to text to improve indexing performance on plain text files in blob storage."
          },
          {
            "name": "DelimitedText",
            "value": "delimitedText",
            "description": "Set to delimitedText when blobs are plain CSV files."
          },
          {
            "name": "Json",
            "value": "json",
            "description": "Set to json to extract structured content from JSON files."
          },
          {
            "name": "JsonArray",
            "value": "jsonArray",
            "description": "Set to jsonArray to extract individual elements of a JSON array as separate\ndocuments."
          },
          {
            "name": "JsonLines",
            "value": "jsonLines",
            "description": "Set to jsonLines to extract individual JSON entities, separated by a new line,\nas separate documents."
          }
        ]
      }
    },
    "CharFilter": {
      "type": "object",
      "description": "Base type for character filters.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        },
        "name": {
          "type": "string",
          "description": "The name of the char filter. It must only contain letters, digits, spaces,\ndashes or underscores, can only start and end with alphanumeric characters, and\nis limited to 128 characters."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type",
        "name"
      ]
    },
    "CharFilterName": {
      "type": "string",
      "description": "Defines the names of all character filters supported by the search engine.",
      "enum": [
        "html_strip"
      ],
      "x-ms-enum": {
        "name": "CharFilterName",
        "modelAsString": true,
        "values": [
          {
            "name": "HtmlStrip",
            "value": "html_strip",
            "description": "A character filter that attempts to strip out HTML constructs. See\nhttps://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.html"
          }
        ]
      }
    },
    "CjkBigramTokenFilter": {
      "type": "object",
      "description": "Forms bigrams of CJK terms that are generated from the standard tokenizer. This\ntoken filter is implemented using Apache Lucene.",
      "properties": {
        "ignoreScripts": {
          "type": "array",
          "description": "The scripts to ignore.",
          "items": {
            "$ref": "#/definitions/CjkBigramTokenFilterScripts"
          }
        },
        "outputUnigrams": {
          "type": "boolean",
          "description": "A value indicating whether to output both unigrams and bigrams (if true), or\njust bigrams (if false). Default is false."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.CjkBigramTokenFilter"
    },
    "CjkBigramTokenFilterScripts": {
      "type": "string",
      "description": "Scripts that can be ignored by CjkBigramTokenFilter.",
      "enum": [
        "han",
        "hiragana",
        "katakana",
        "hangul"
      ],
      "x-ms-enum": {
        "name": "CjkBigramTokenFilterScripts",
        "modelAsString": true,
        "values": [
          {
            "name": "Han",
            "value": "han",
            "description": "Ignore Han script when forming bigrams of CJK terms."
          },
          {
            "name": "Hiragana",
            "value": "hiragana",
            "description": "Ignore Hiragana script when forming bigrams of CJK terms."
          },
          {
            "name": "Katakana",
            "value": "katakana",
            "description": "Ignore Katakana script when forming bigrams of CJK terms."
          },
          {
            "name": "Hangul",
            "value": "hangul",
            "description": "Ignore Hangul script when forming bigrams of CJK terms."
          }
        ]
      }
    },
    "ClassicSimilarityAlgorithm": {
      "type": "object",
      "description": "Legacy similarity algorithm which uses the Lucene TFIDFSimilarity\nimplementation of TF-IDF. This variation of TF-IDF introduces static document\nlength normalization as well as coordinating factors that penalize documents\nthat only partially match the searched queries.",
      "allOf": [
        {
          "$ref": "#/definitions/SimilarityAlgorithm"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.ClassicSimilarity"
    },
    "ClassicTokenizer": {
      "type": "object",
      "description": "Grammar-based tokenizer that is suitable for processing most European-language\ndocuments. This tokenizer is implemented using Apache Lucene.",
      "properties": {
        "maxTokenLength": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum token length. Default is 255. Tokens longer than the maximum length\nare split. The maximum token length that can be used is 300 characters.",
          "default": 255,
          "maximum": 300
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.ClassicTokenizer"
    },
    "CognitiveServicesAccount": {
      "type": "object",
      "description": "Base type for describing any Azure AI service resource attached to a skillset.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        },
        "description": {
          "type": "string",
          "description": "Description of the Azure AI service resource attached to a skillset."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type"
      ]
    },
    "CognitiveServicesAccountKey": {
      "type": "object",
      "description": "The multi-region account key of an Azure AI service resource that's attached to\na skillset.",
      "properties": {
        "key": {
          "type": "string",
          "description": "The key used to provision the Azure AI service resource attached to a skillset."
        }
      },
      "required": [
        "key"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/CognitiveServicesAccount"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.CognitiveServicesByKey"
    },
    "CommonGramTokenFilter": {
      "type": "object",
      "description": "Construct bigrams for frequently occurring terms while indexing. Single terms\nare still indexed too, with bigrams overlaid. This token filter is implemented\nusing Apache Lucene.",
      "properties": {
        "commonWords": {
          "type": "array",
          "description": "The set of common words.",
          "items": {
            "type": "string"
          }
        },
        "ignoreCase": {
          "type": "boolean",
          "description": "A value indicating whether common words matching will be case insensitive.\nDefault is false."
        },
        "queryMode": {
          "type": "boolean",
          "description": "A value that indicates whether the token filter is in query mode. When in query\nmode, the token filter generates bigrams and then removes common words and\nsingle terms followed by a common word. Default is false."
        }
      },
      "required": [
        "commonWords"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.CommonGramTokenFilter"
    },
    "ConditionalSkill": {
      "type": "object",
      "description": "A skill that enables scenarios that require a Boolean operation to determine\nthe data to assign to an output.",
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Util.ConditionalSkill"
    },
    "CorsOptions": {
      "type": "object",
      "description": "Defines options to control Cross-Origin Resource Sharing (CORS) for an index.",
      "properties": {
        "allowedOrigins": {
          "type": "array",
          "description": "The list of origins from which JavaScript code will be granted access to your\nindex. Can contain a list of hosts of the form\n{protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to allow\nall origins (not recommended).",
          "items": {
            "type": "string"
          }
        },
        "maxAgeInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "The duration for which browsers should cache CORS preflight responses. Defaults\nto 5 minutes."
        }
      },
      "required": [
        "allowedOrigins"
      ]
    },
    "CustomAnalyzer": {
      "type": "object",
      "description": "Allows you to take control over the process of converting text into\nindexable/searchable tokens. It's a user-defined configuration consisting of a\nsingle predefined tokenizer and one or more filters. The tokenizer is\nresponsible for breaking text into tokens, and the filters for modifying tokens\nemitted by the tokenizer.",
      "properties": {
        "tokenizer": {
          "$ref": "#/definitions/LexicalTokenizerName",
          "description": "The name of the tokenizer to use to divide continuous text into a sequence of\ntokens, such as breaking a sentence into words."
        },
        "tokenFilters": {
          "type": "array",
          "description": "A list of token filters used to filter out or modify the tokens generated by a\ntokenizer. For example, you can specify a lowercase filter that converts all\ncharacters to lowercase. The filters are run in the order in which they are\nlisted.",
          "items": {
            "$ref": "#/definitions/TokenFilterName"
          }
        },
        "charFilters": {
          "type": "array",
          "description": "A list of character filters used to prepare input text before it is processed\nby the tokenizer. For instance, they can replace certain characters or symbols.\nThe filters are run in the order in which they are listed.",
          "items": {
            "$ref": "#/definitions/CharFilterName"
          }
        }
      },
      "required": [
        "tokenizer"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/LexicalAnalyzer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.CustomAnalyzer"
    },
    "CustomEntity": {
      "type": "object",
      "description": "An object that contains information about the matches that were found, and\nrelated metadata.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The top-level entity descriptor. Matches in the skill output will be grouped by\nthis name, and it should represent the \"normalized\" form of the text being\nfound."
        },
        "description": {
          "type": "string",
          "description": "This field can be used as a passthrough for custom metadata about the matched\ntext(s). The value of this field will appear with every match of its entity in\nthe skill output."
        },
        "type": {
          "type": "string",
          "description": "This field can be used as a passthrough for custom metadata about the matched\ntext(s). The value of this field will appear with every match of its entity in\nthe skill output."
        },
        "subtype": {
          "type": "string",
          "description": "This field can be used as a passthrough for custom metadata about the matched\ntext(s). The value of this field will appear with every match of its entity in\nthe skill output."
        },
        "id": {
          "type": "string",
          "description": "This field can be used as a passthrough for custom metadata about the matched\ntext(s). The value of this field will appear with every match of its entity in\nthe skill output."
        },
        "caseSensitive": {
          "type": "boolean",
          "description": "Defaults to false. Boolean value denoting whether comparisons with the entity\nname should be sensitive to character casing. Sample case insensitive matches\nof \"Microsoft\" could be: microsoft, microSoft, MICROSOFT."
        },
        "accentSensitive": {
          "type": "boolean",
          "description": "Defaults to false. Boolean value denoting whether comparisons with the entity\nname should be sensitive to accent."
        },
        "fuzzyEditDistance": {
          "type": "integer",
          "format": "int32",
          "description": "Defaults to 0. Maximum value of 5. Denotes the acceptable number of divergent\ncharacters that would still constitute a match with the entity name. The\nsmallest possible fuzziness for any given match is returned. For instance, if\nthe edit distance is set to 3, \"Windows10\" would still match \"Windows\",\n\"Windows10\" and \"Windows 7\". When case sensitivity is set to false, case\ndifferences do NOT count towards fuzziness tolerance, but otherwise do."
        },
        "defaultCaseSensitive": {
          "type": "boolean",
          "description": "Changes the default case sensitivity value for this entity. It be used to\nchange the default value of all aliases caseSensitive values."
        },
        "defaultAccentSensitive": {
          "type": "boolean",
          "description": "Changes the default accent sensitivity value for this entity. It be used to\nchange the default value of all aliases accentSensitive values."
        },
        "defaultFuzzyEditDistance": {
          "type": "integer",
          "format": "int32",
          "description": "Changes the default fuzzy edit distance value for this entity. It can be used\nto change the default value of all aliases fuzzyEditDistance values."
        },
        "aliases": {
          "type": "array",
          "description": "An array of complex objects that can be used to specify alternative spellings\nor synonyms to the root entity name.",
          "items": {
            "$ref": "#/definitions/CustomEntityAlias"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "name"
      ]
    },
    "CustomEntityAlias": {
      "type": "object",
      "description": "A complex object that can be used to specify alternative spellings or synonyms\nto the root entity name.",
      "properties": {
        "text": {
          "type": "string",
          "description": "The text of the alias."
        },
        "caseSensitive": {
          "type": "boolean",
          "description": "Determine if the alias is case sensitive."
        },
        "accentSensitive": {
          "type": "boolean",
          "description": "Determine if the alias is accent sensitive."
        },
        "fuzzyEditDistance": {
          "type": "integer",
          "format": "int32",
          "description": "Determine the fuzzy edit distance of the alias."
        }
      },
      "required": [
        "text"
      ]
    },
    "CustomEntityLookupSkill": {
      "type": "object",
      "description": "A skill looks for text from a custom, user-defined list of words and phrases.",
      "properties": {
        "defaultLanguageCode": {
          "$ref": "#/definitions/CustomEntityLookupSkillLanguage",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "entitiesDefinitionUri": {
          "type": "string",
          "description": "Path to a JSON or CSV file containing all the target text to match against.\nThis entity definition is read at the beginning of an indexer run. Any updates\nto this file during an indexer run will not take effect until subsequent runs.\nThis config must be accessible over HTTPS."
        },
        "inlineEntitiesDefinition": {
          "type": "array",
          "description": "The inline CustomEntity definition.",
          "items": {
            "$ref": "#/definitions/CustomEntity"
          }
        },
        "globalDefaultCaseSensitive": {
          "type": "boolean",
          "description": "A global flag for CaseSensitive. If CaseSensitive is not set in CustomEntity,\nthis value will be the default value."
        },
        "globalDefaultAccentSensitive": {
          "type": "boolean",
          "description": "A global flag for AccentSensitive. If AccentSensitive is not set in\nCustomEntity, this value will be the default value."
        },
        "globalDefaultFuzzyEditDistance": {
          "type": "integer",
          "format": "int32",
          "description": "A global flag for FuzzyEditDistance. If FuzzyEditDistance is not set in\nCustomEntity, this value will be the default value."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.CustomEntityLookupSkill"
    },
    "CustomEntityLookupSkillLanguage": {
      "type": "string",
      "description": "The language codes supported for input text by CustomEntityLookupSkill.",
      "enum": [
        "da",
        "de",
        "en",
        "es",
        "fi",
        "fr",
        "it",
        "ko",
        "pt"
      ],
      "x-ms-enum": {
        "name": "CustomEntityLookupSkillLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "da",
            "value": "da",
            "description": "Danish"
          },
          {
            "name": "de",
            "value": "de",
            "description": "German"
          },
          {
            "name": "en",
            "value": "en",
            "description": "English"
          },
          {
            "name": "es",
            "value": "es",
            "description": "Spanish"
          },
          {
            "name": "fi",
            "value": "fi",
            "description": "Finnish"
          },
          {
            "name": "fr",
            "value": "fr",
            "description": "French"
          },
          {
            "name": "it",
            "value": "it",
            "description": "Italian"
          },
          {
            "name": "ko",
            "value": "ko",
            "description": "Korean"
          },
          {
            "name": "pt",
            "value": "pt",
            "description": "Portuguese"
          }
        ]
      }
    },
    "DataChangeDetectionPolicy": {
      "type": "object",
      "description": "Base type for data change detection policies.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type"
      ]
    },
    "DataDeletionDetectionPolicy": {
      "type": "object",
      "description": "Base type for data deletion detection policies.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type"
      ]
    },
    "DataSourceCredentials": {
      "type": "object",
      "description": "Represents credentials that can be used to connect to a datasource.",
      "properties": {
        "connectionString": {
          "type": "string",
          "description": "The connection string for the datasource. Set to `<unchanged>` (with brackets)\nif you don't want the connection string updated. Set to `<redacted>` if you\nwant to remove the connection string value from the datasource."
        }
      }
    },
    "DefaultCognitiveServicesAccount": {
      "type": "object",
      "description": "An empty object that represents the default Azure AI service resource for a\nskillset.",
      "allOf": [
        {
          "$ref": "#/definitions/CognitiveServicesAccount"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.DefaultCognitiveServices"
    },
    "DictionaryDecompounderTokenFilter": {
      "type": "object",
      "description": "Decomposes compound words found in many Germanic languages. This token filter\nis implemented using Apache Lucene.",
      "properties": {
        "wordList": {
          "type": "array",
          "description": "The list of words to match against.",
          "items": {
            "type": "string"
          }
        },
        "minWordSize": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum word size. Only words longer than this get processed. Default is 5.\nMaximum is 300.",
          "default": 5,
          "maximum": 300
        },
        "minSubwordSize": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum subword size. Only subwords longer than this are outputted. Default\nis 2. Maximum is 300.",
          "default": 2,
          "maximum": 300
        },
        "maxSubwordSize": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum subword size. Only subwords shorter than this are outputted.\nDefault is 15. Maximum is 300.",
          "default": 15,
          "maximum": 300
        },
        "onlyLongestMatch": {
          "type": "boolean",
          "description": "A value indicating whether to add only the longest matching subword to the\noutput. Default is false."
        }
      },
      "required": [
        "wordList"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter"
    },
    "DistanceScoringFunction": {
      "type": "object",
      "description": "Defines a function that boosts scores based on distance from a geographic\nlocation.",
      "properties": {
        "distance": {
          "$ref": "#/definitions/DistanceScoringParameters",
          "description": "Parameter values for the distance scoring function."
        }
      },
      "required": [
        "distance"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/ScoringFunction"
        }
      ],
      "x-ms-discriminator-value": "distance"
    },
    "DistanceScoringParameters": {
      "type": "object",
      "description": "Provides parameter values to a distance scoring function.",
      "properties": {
        "referencePointParameter": {
          "type": "string",
          "description": "The name of the parameter passed in search queries to specify the reference\nlocation."
        },
        "boostingDistance": {
          "type": "number",
          "format": "double",
          "description": "The distance in kilometers from the reference location where the boosting range\nends."
        }
      },
      "required": [
        "referencePointParameter",
        "boostingDistance"
      ]
    },
    "DocumentExtractionSkill": {
      "type": "object",
      "description": "A skill that extracts content from a file within the enrichment pipeline.",
      "properties": {
        "parsingMode": {
          "type": "string",
          "description": "The parsingMode for the skill. Will be set to 'default' if not defined."
        },
        "dataToExtract": {
          "type": "string",
          "description": "The type of data to be extracted for the skill. Will be set to\n'contentAndMetadata' if not defined."
        },
        "configuration": {
          "type": "object",
          "description": "A dictionary of configurations for the skill.",
          "additionalProperties": {}
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Util.DocumentExtractionSkill"
    },
    "EdgeNGramTokenFilterSide": {
      "type": "string",
      "description": "Specifies which side of the input an n-gram should be generated from.",
      "enum": [
        "front",
        "back"
      ],
      "x-ms-enum": {
        "name": "EdgeNGramTokenFilterSide",
        "modelAsString": true,
        "values": [
          {
            "name": "Front",
            "value": "front",
            "description": "Specifies that the n-gram should be generated from the front of the input."
          },
          {
            "name": "Back",
            "value": "back",
            "description": "Specifies that the n-gram should be generated from the back of the input."
          }
        ]
      }
    },
    "EdgeNGramTokenFilterV2": {
      "type": "object",
      "description": "Generates n-grams of the given size(s) starting from the front or the back of\nan input token. This token filter is implemented using Apache Lucene.",
      "properties": {
        "minGram": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the\nvalue of maxGram.",
          "default": 1,
          "maximum": 300
        },
        "maxGram": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum n-gram length. Default is 2. Maximum is 300.",
          "default": 2,
          "maximum": 300
        },
        "side": {
          "$ref": "#/definitions/EdgeNGramTokenFilterSide",
          "description": "Specifies which side of the input the n-gram should be generated from. Default\nis \"front\"."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2"
    },
    "EdgeNGramTokenizer": {
      "type": "object",
      "description": "Tokenizes the input from an edge into n-grams of the given size(s). This\ntokenizer is implemented using Apache Lucene.",
      "properties": {
        "minGram": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the\nvalue of maxGram.",
          "default": 1,
          "maximum": 300
        },
        "maxGram": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum n-gram length. Default is 2. Maximum is 300.",
          "default": 2,
          "maximum": 300
        },
        "tokenChars": {
          "type": "array",
          "description": "Character classes to keep in the tokens.",
          "items": {
            "$ref": "#/definitions/TokenCharacterKind"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.EdgeNGramTokenizer"
    },
    "ElisionTokenFilter": {
      "type": "object",
      "description": "Removes elisions. For example, \"l'avion\" (the plane) will be converted to\n\"avion\" (plane). This token filter is implemented using Apache Lucene.",
      "properties": {
        "articles": {
          "type": "array",
          "description": "The set of articles to remove.",
          "items": {
            "type": "string"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.ElisionTokenFilter"
    },
    "EntityCategory": {
      "type": "string",
      "description": "A string indicating what entity categories to return.",
      "enum": [
        "location",
        "organization",
        "person",
        "quantity",
        "datetime",
        "url",
        "email"
      ],
      "x-ms-enum": {
        "name": "EntityCategory",
        "modelAsString": true,
        "values": [
          {
            "name": "Location",
            "value": "location",
            "description": "Entities describing a physical location."
          },
          {
            "name": "Organization",
            "value": "organization",
            "description": "Entities describing an organization."
          },
          {
            "name": "Person",
            "value": "person",
            "description": "Entities describing a person."
          },
          {
            "name": "Quantity",
            "value": "quantity",
            "description": "Entities describing a quantity."
          },
          {
            "name": "Datetime",
            "value": "datetime",
            "description": "Entities describing a date and time."
          },
          {
            "name": "Url",
            "value": "url",
            "description": "Entities describing a URL."
          },
          {
            "name": "Email",
            "value": "email",
            "description": "Entities describing an email address."
          }
        ]
      }
    },
    "EntityLinkingSkill": {
      "type": "object",
      "description": "Using the Text Analytics API, extracts linked entities from text.",
      "properties": {
        "defaultLanguageCode": {
          "type": "string",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "minimumPrecision": {
          "type": "number",
          "format": "double",
          "description": "A value between 0 and 1 that be used to only include entities whose confidence\nscore is greater than the value specified. If not set (default), or if\nexplicitly set to null, all entities will be included.",
          "maximum": 1
        },
        "modelVersion": {
          "type": "string",
          "description": "The version of the model to use when calling the Text Analytics service. It\nwill default to the latest available when not specified. We recommend you do\nnot specify this value unless absolutely necessary."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.V3.EntityLinkingSkill"
    },
    "EntityRecognitionSkill": {
      "type": "object",
      "description": "This skill is deprecated. Use the V3.EntityRecognitionSkill instead.",
      "properties": {
        "categories": {
          "type": "array",
          "description": "A list of entity categories that should be extracted.",
          "items": {
            "$ref": "#/definitions/EntityCategory"
          }
        },
        "defaultLanguageCode": {
          "$ref": "#/definitions/EntityRecognitionSkillLanguage",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "includeTypelessEntities": {
          "type": "boolean",
          "description": "Determines whether or not to include entities which are well known but don't\nconform to a pre-defined type. If this configuration is not set (default), set\nto null or set to false, entities which don't conform to one of the pre-defined\ntypes will not be surfaced."
        },
        "minimumPrecision": {
          "type": "number",
          "format": "double",
          "description": "A value between 0 and 1 that be used to only include entities whose confidence\nscore is greater than the value specified. If not set (default), or if\nexplicitly set to null, all entities will be included."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.EntityRecognitionSkill"
    },
    "EntityRecognitionSkillLanguage": {
      "type": "string",
      "description": "Deprecated. The language codes supported for input text by\nEntityRecognitionSkill.",
      "enum": [
        "ar",
        "cs",
        "zh-Hans",
        "zh-Hant",
        "da",
        "nl",
        "en",
        "fi",
        "fr",
        "de",
        "el",
        "hu",
        "it",
        "ja",
        "ko",
        "no",
        "pl",
        "pt-PT",
        "pt-BR",
        "ru",
        "es",
        "sv",
        "tr"
      ],
      "x-ms-enum": {
        "name": "EntityRecognitionSkillLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "ar",
            "value": "ar",
            "description": "Arabic"
          },
          {
            "name": "cs",
            "value": "cs",
            "description": "Czech"
          },
          {
            "name": "zh-Hans",
            "value": "zh-Hans",
            "description": "Chinese-Simplified"
          },
          {
            "name": "zh-Hant",
            "value": "zh-Hant",
            "description": "Chinese-Traditional"
          },
          {
            "name": "da",
            "value": "da",
            "description": "Danish"
          },
          {
            "name": "nl",
            "value": "nl",
            "description": "Dutch"
          },
          {
            "name": "en",
            "value": "en",
            "description": "English"
          },
          {
            "name": "fi",
            "value": "fi",
            "description": "Finnish"
          },
          {
            "name": "fr",
            "value": "fr",
            "description": "French"
          },
          {
            "name": "de",
            "value": "de",
            "description": "German"
          },
          {
            "name": "el",
            "value": "el",
            "description": "Greek"
          },
          {
            "name": "hu",
            "value": "hu",
            "description": "Hungarian"
          },
          {
            "name": "it",
            "value": "it",
            "description": "Italian"
          },
          {
            "name": "ja",
            "value": "ja",
            "description": "Japanese"
          },
          {
            "name": "ko",
            "value": "ko",
            "description": "Korean"
          },
          {
            "name": "no",
            "value": "no",
            "description": "Norwegian (Bokmaal)"
          },
          {
            "name": "pl",
            "value": "pl",
            "description": "Polish"
          },
          {
            "name": "pt-PT",
            "value": "pt-PT",
            "description": "Portuguese (Portugal)"
          },
          {
            "name": "pt-BR",
            "value": "pt-BR",
            "description": "Portuguese (Brazil)"
          },
          {
            "name": "ru",
            "value": "ru",
            "description": "Russian"
          },
          {
            "name": "es",
            "value": "es",
            "description": "Spanish"
          },
          {
            "name": "sv",
            "value": "sv",
            "description": "Swedish"
          },
          {
            "name": "tr",
            "value": "tr",
            "description": "Turkish"
          }
        ]
      }
    },
    "EntityRecognitionSkillV3": {
      "type": "object",
      "description": "Using the Text Analytics API, extracts entities of different types from text.",
      "properties": {
        "categories": {
          "type": "array",
          "description": "A list of entity categories that should be extracted.",
          "items": {
            "type": "string"
          }
        },
        "defaultLanguageCode": {
          "type": "string",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "minimumPrecision": {
          "type": "number",
          "format": "double",
          "description": "A value between 0 and 1 that be used to only include entities whose confidence\nscore is greater than the value specified. If not set (default), or if\nexplicitly set to null, all entities will be included.",
          "maximum": 1
        },
        "modelVersion": {
          "type": "string",
          "description": "The version of the model to use when calling the Text Analytics API. It will\ndefault to the latest available when not specified. We recommend you do not\nspecify this value unless absolutely necessary."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.V3.EntityRecognitionSkill"
    },
    "ErrorAdditionalInfo": {
      "type": "object",
      "description": "The resource management error additional info.",
      "properties": {
        "type": {
          "type": "string",
          "description": "The additional info type."
        },
        "info": {
          "type": "object",
          "description": "The additional info.",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "ErrorDetail": {
      "type": "object",
      "description": "The error detail.",
      "properties": {
        "code": {
          "type": "string",
          "description": "The error code."
        },
        "message": {
          "type": "string",
          "description": "The error message."
        },
        "target": {
          "type": "string",
          "description": "The error target."
        },
        "details": {
          "type": "array",
          "description": "The error details.",
          "items": {
            "$ref": "#/definitions/ErrorDetail"
          },
          "x-ms-identifiers": []
        },
        "additionalInfo": {
          "type": "array",
          "description": "The error additional info.",
          "items": {
            "$ref": "#/definitions/ErrorAdditionalInfo"
          },
          "x-ms-identifiers": []
        }
      }
    },
    "ErrorResponse": {
      "type": "object",
      "description": "Common error response for all Azure Resource Manager APIs to return error\ndetails for failed operations. (This also follows the OData error response\nformat.).",
      "properties": {
        "error": {
          "$ref": "#/definitions/ErrorDetail",
          "description": "The error object."
        }
      }
    },
    "ExhaustiveKnnAlgorithmConfiguration": {
      "type": "object",
      "description": "Contains configuration options specific to the exhaustive KNN algorithm used\nduring querying, which will perform brute-force search across the entire vector\nindex.",
      "properties": {
        "exhaustiveKnnParameters": {
          "$ref": "#/definitions/ExhaustiveKnnParameters",
          "description": "Contains the parameters specific to exhaustive KNN algorithm."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/VectorSearchAlgorithmConfiguration"
        }
      ],
      "x-ms-discriminator-value": "exhaustiveKnn"
    },
    "ExhaustiveKnnParameters": {
      "type": "object",
      "description": "Contains the parameters specific to exhaustive KNN algorithm.",
      "properties": {
        "metric": {
          "$ref": "#/definitions/VectorSearchAlgorithmMetric",
          "description": "The similarity metric to use for vector comparisons."
        }
      }
    },
    "FacetResult": {
      "type": "object",
      "description": "A single bucket of a facet query result. Reports the number of documents with a\nfield value falling within a particular range or having a particular value or\ninterval.",
      "properties": {
        "count": {
          "type": "integer",
          "format": "int64",
          "description": "The approximate count of documents falling within the bucket described by this\nfacet."
        }
      },
      "additionalProperties": {}
    },
    "FieldMapping": {
      "type": "object",
      "description": "Defines a mapping between a field in a data source and a target field in an\nindex.",
      "properties": {
        "sourceFieldName": {
          "type": "string",
          "description": "The name of the field in the data source."
        },
        "targetFieldName": {
          "type": "string",
          "description": "The name of the target field in the index. Same as the source field name by\ndefault."
        },
        "mappingFunction": {
          "$ref": "#/definitions/FieldMappingFunction",
          "description": "A function to apply to each source field value before indexing."
        }
      },
      "required": [
        "sourceFieldName"
      ]
    },
    "FieldMappingFunction": {
      "type": "object",
      "description": "Represents a function that transforms a value from a data source before\nindexing.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the field mapping function."
        },
        "parameters": {
          "type": "object",
          "description": "A dictionary of parameter name/value pairs to pass to the function. Each value\nmust be of a primitive type.",
          "additionalProperties": {}
        }
      },
      "required": [
        "name"
      ]
    },
    "FreshnessScoringFunction": {
      "type": "object",
      "description": "Defines a function that boosts scores based on the value of a date-time field.",
      "properties": {
        "freshness": {
          "$ref": "#/definitions/FreshnessScoringParameters",
          "description": "Parameter values for the freshness scoring function."
        }
      },
      "required": [
        "freshness"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/ScoringFunction"
        }
      ],
      "x-ms-discriminator-value": "freshness"
    },
    "FreshnessScoringParameters": {
      "type": "object",
      "description": "Provides parameter values to a freshness scoring function.",
      "properties": {
        "boostingDuration": {
          "type": "string",
          "format": "duration",
          "description": "The expiration period after which boosting will stop for a particular document."
        }
      },
      "required": [
        "boostingDuration"
      ]
    },
    "GetIndexStatisticsResult": {
      "type": "object",
      "description": "Statistics for a given index. Statistics are collected periodically and are not\nguaranteed to always be up-to-date.",
      "properties": {
        "documentCount": {
          "type": "integer",
          "format": "int64",
          "description": "The number of documents in the index."
        },
        "storageSize": {
          "type": "integer",
          "format": "int64",
          "description": "The amount of storage in bytes consumed by the index."
        },
        "vectorIndexSize": {
          "type": "integer",
          "format": "int64",
          "description": "The amount of memory in bytes consumed by vectors in the index."
        }
      },
      "required": [
        "documentCount",
        "storageSize",
        "vectorIndexSize"
      ]
    },
    "HighWaterMarkChangeDetectionPolicy": {
      "type": "object",
      "description": "Defines a data change detection policy that captures changes based on the value\nof a high water mark column.",
      "properties": {
        "highWaterMarkColumnName": {
          "type": "string",
          "description": "The name of the high water mark column."
        }
      },
      "required": [
        "highWaterMarkColumnName"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/DataChangeDetectionPolicy"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
    },
    "HnswAlgorithmConfiguration": {
      "type": "object",
      "description": "Contains configuration options specific to the HNSW approximate nearest\nneighbors algorithm used during indexing and querying. The HNSW algorithm\noffers a tunable trade-off between search speed and accuracy.",
      "properties": {
        "hnswParameters": {
          "$ref": "#/definitions/HnswParameters",
          "description": "Contains the parameters specific to HNSW algorithm."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/VectorSearchAlgorithmConfiguration"
        }
      ],
      "x-ms-discriminator-value": "hnsw"
    },
    "HnswParameters": {
      "type": "object",
      "description": "Contains the parameters specific to the HNSW algorithm.",
      "properties": {
        "m": {
          "type": "integer",
          "format": "int32",
          "description": "The number of bi-directional links created for every new element during\nconstruction. Increasing this parameter value may improve recall and reduce\nretrieval times for datasets with high intrinsic dimensionality at the expense\nof increased memory consumption and longer indexing time.",
          "default": 4,
          "minimum": 4,
          "maximum": 10
        },
        "efConstruction": {
          "type": "integer",
          "format": "int32",
          "description": "The size of the dynamic list containing the nearest neighbors, which is used\nduring index time. Increasing this parameter may improve index quality, at the\nexpense of increased indexing time. At a certain point, increasing this\nparameter leads to diminishing returns.",
          "default": 400,
          "minimum": 100,
          "maximum": 1000
        },
        "efSearch": {
          "type": "integer",
          "format": "int32",
          "description": "The size of the dynamic list containing the nearest neighbors, which is used\nduring search time. Increasing this parameter may improve search results, at\nthe expense of slower search. At a certain point, increasing this parameter\nleads to diminishing returns.",
          "default": 500,
          "minimum": 100,
          "maximum": 1000
        },
        "metric": {
          "$ref": "#/definitions/VectorSearchAlgorithmMetric",
          "description": "The similarity metric to use for vector comparisons."
        }
      }
    },
    "ImageAnalysisSkill": {
      "type": "object",
      "description": "A skill that analyzes image files. It extracts a rich set of visual features\nbased on the image content.",
      "properties": {
        "defaultLanguageCode": {
          "$ref": "#/definitions/ImageAnalysisSkillLanguage",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "visualFeatures": {
          "type": "array",
          "description": "A list of visual features.",
          "items": {
            "$ref": "#/definitions/VisualFeature"
          }
        },
        "details": {
          "type": "array",
          "description": "A string indicating which domain-specific details to return.",
          "items": {
            "$ref": "#/definitions/ImageDetail"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Vision.ImageAnalysisSkill"
    },
    "ImageAnalysisSkillLanguage": {
      "type": "string",
      "description": "The language codes supported for input by ImageAnalysisSkill.",
      "enum": [
        "ar",
        "az",
        "bg",
        "bs",
        "ca",
        "cs",
        "cy",
        "da",
        "de",
        "el",
        "en",
        "es",
        "et",
        "eu",
        "fi",
        "fr",
        "ga",
        "gl",
        "he",
        "hi",
        "hr",
        "hu",
        "id",
        "it",
        "ja",
        "kk",
        "ko",
        "lt",
        "lv",
        "mk",
        "ms",
        "nb",
        "nl",
        "pl",
        "prs",
        "pt-BR",
        "pt",
        "pt-PT",
        "ro",
        "ru",
        "sk",
        "sl",
        "sr-Cyrl",
        "sr-Latn",
        "sv",
        "th",
        "tr",
        "uk",
        "vi",
        "zh",
        "zh-Hans",
        "zh-Hant"
      ],
      "x-ms-enum": {
        "name": "ImageAnalysisSkillLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "ar",
            "value": "ar",
            "description": "Arabic"
          },
          {
            "name": "az",
            "value": "az",
            "description": "Azerbaijani"
          },
          {
            "name": "bg",
            "value": "bg",
            "description": "Bulgarian"
          },
          {
            "name": "bs",
            "value": "bs",
            "description": "Bosnian Latin"
          },
          {
            "name": "ca",
            "value": "ca",
            "description": "Catalan"
          },
          {
            "name": "cs",
            "value": "cs",
            "description": "Czech"
          },
          {
            "name": "cy",
            "value": "cy",
            "description": "Welsh"
          },
          {
            "name": "da",
            "value": "da",
            "description": "Danish"
          },
          {
            "name": "de",
            "value": "de",
            "description": "German"
          },
          {
            "name": "el",
            "value": "el",
            "description": "Greek"
          },
          {
            "name": "en",
            "value": "en",
            "description": "English"
          },
          {
            "name": "es",
            "value": "es",
            "description": "Spanish"
          },
          {
            "name": "et",
            "value": "et",
            "description": "Estonian"
          },
          {
            "name": "eu",
            "value": "eu",
            "description": "Basque"
          },
          {
            "name": "fi",
            "value": "fi",
            "description": "Finnish"
          },
          {
            "name": "fr",
            "value": "fr",
            "description": "French"
          },
          {
            "name": "ga",
            "value": "ga",
            "description": "Irish"
          },
          {
            "name": "gl",
            "value": "gl",
            "description": "Galician"
          },
          {
            "name": "he",
            "value": "he",
            "description": "Hebrew"
          },
          {
            "name": "hi",
            "value": "hi",
            "description": "Hindi"
          },
          {
            "name": "hr",
            "value": "hr",
            "description": "Croatian"
          },
          {
            "name": "hu",
            "value": "hu",
            "description": "Hungarian"
          },
          {
            "name": "id",
            "value": "id",
            "description": "Indonesian"
          },
          {
            "name": "it",
            "value": "it",
            "description": "Italian"
          },
          {
            "name": "ja",
            "value": "ja",
            "description": "Japanese"
          },
          {
            "name": "kk",
            "value": "kk",
            "description": "Kazakh"
          },
          {
            "name": "ko",
            "value": "ko",
            "description": "Korean"
          },
          {
            "name": "lt",
            "value": "lt",
            "description": "Lithuanian"
          },
          {
            "name": "lv",
            "value": "lv",
            "description": "Latvian"
          },
          {
            "name": "mk",
            "value": "mk",
            "description": "Macedonian"
          },
          {
            "name": "ms",
            "value": "ms",
            "description": "Malay Malaysia"
          },
          {
            "name": "nb",
            "value": "nb",
            "description": "Norwegian (Bokmal)"
          },
          {
            "name": "nl",
            "value": "nl",
            "description": "Dutch"
          },
          {
            "name": "pl",
            "value": "pl",
            "description": "Polish"
          },
          {
            "name": "prs",
            "value": "prs",
            "description": "Dari"
          },
          {
            "name": "pt-BR",
            "value": "pt-BR",
            "description": "Portuguese-Brazil"
          },
          {
            "name": "pt",
            "value": "pt",
            "description": "Portuguese-Portugal"
          },
          {
            "name": "pt-PT",
            "value": "pt-PT",
            "description": "Portuguese-Portugal"
          },
          {
            "name": "ro",
            "value": "ro",
            "description": "Romanian"
          },
          {
            "name": "ru",
            "value": "ru",
            "description": "Russian"
          },
          {
            "name": "sk",
            "value": "sk",
            "description": "Slovak"
          },
          {
            "name": "sl",
            "value": "sl",
            "description": "Slovenian"
          },
          {
            "name": "sr-Cyrl",
            "value": "sr-Cyrl",
            "description": "Serbian - Cyrillic RS"
          },
          {
            "name": "sr-Latn",
            "value": "sr-Latn",
            "description": "Serbian - Latin RS"
          },
          {
            "name": "sv",
            "value": "sv",
            "description": "Swedish"
          },
          {
            "name": "th",
            "value": "th",
            "description": "Thai"
          },
          {
            "name": "tr",
            "value": "tr",
            "description": "Turkish"
          },
          {
            "name": "uk",
            "value": "uk",
            "description": "Ukrainian"
          },
          {
            "name": "vi",
            "value": "vi",
            "description": "Vietnamese"
          },
          {
            "name": "zh",
            "value": "zh",
            "description": "Chinese Simplified"
          },
          {
            "name": "zh-Hans",
            "value": "zh-Hans",
            "description": "Chinese Simplified"
          },
          {
            "name": "zh-Hant",
            "value": "zh-Hant",
            "description": "Chinese Traditional"
          }
        ]
      }
    },
    "ImageDetail": {
      "type": "string",
      "description": "A string indicating which domain-specific details to return.",
      "enum": [
        "celebrities",
        "landmarks"
      ],
      "x-ms-enum": {
        "name": "ImageDetail",
        "modelAsString": true,
        "values": [
          {
            "name": "Celebrities",
            "value": "celebrities",
            "description": "Details recognized as celebrities."
          },
          {
            "name": "Landmarks",
            "value": "landmarks",
            "description": "Details recognized as landmarks."
          }
        ]
      }
    },
    "IndexAction": {
      "type": "object",
      "description": "Represents an index action that operates on a document.",
      "properties": {
        "@search.action": {
          "$ref": "#/definitions/IndexActionType",
          "description": "The operation to perform on a document in an indexing batch.",
          "x-ms-client-name": "actionType"
        }
      },
      "additionalProperties": {}
    },
    "IndexActionType": {
      "type": "string",
      "description": "The operation to perform on a document in an indexing batch.",
      "enum": [
        "upload",
        "merge",
        "mergeOrUpload",
        "delete"
      ],
      "x-ms-enum": {
        "name": "IndexActionType",
        "modelAsString": true,
        "values": [
          {
            "name": "Upload",
            "value": "upload",
            "description": "Inserts the document into the index if it is new and updates it if it exists.\nAll fields are replaced in the update case."
          },
          {
            "name": "Merge",
            "value": "merge",
            "description": "Merges the specified field values with an existing document. If the document\ndoes not exist, the merge will fail. Any field you specify in a merge will\nreplace the existing field in the document. This also applies to collections of\nprimitive and complex types."
          },
          {
            "name": "MergeOrUpload",
            "value": "mergeOrUpload",
            "description": "Behaves like merge if a document with the given key already exists in the\nindex. If the document does not exist, it behaves like upload with a new\ndocument."
          },
          {
            "name": "Delete",
            "value": "delete",
            "description": "Removes the specified document from the index. Any field you specify in a\ndelete operation other than the key field will be ignored. If you want to\nremove an individual field from a document, use merge instead and set the field\nexplicitly to null."
          }
        ]
      }
    },
    "IndexBatch": {
      "type": "object",
      "description": "Contains a batch of document write actions to send to the index.",
      "properties": {
        "value": {
          "type": "array",
          "description": "The actions in the batch.",
          "items": {
            "$ref": "#/definitions/IndexAction"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "value"
      ]
    },
    "IndexDocumentsResult": {
      "type": "object",
      "description": "Response containing the status of operations for all documents in the indexing\nrequest.",
      "properties": {
        "value": {
          "type": "array",
          "description": "The list of status information for each document in the indexing request.",
          "items": {
            "$ref": "#/definitions/IndexingResult"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "value"
      ]
    },
    "IndexProjectionMode": {
      "type": "string",
      "description": "Defines behavior of the index projections in relation to the rest of the\nindexer.",
      "enum": [
        "skipIndexingParentDocuments",
        "includeIndexingParentDocuments"
      ],
      "x-ms-enum": {
        "name": "IndexProjectionMode",
        "modelAsString": true,
        "values": [
          {
            "name": "SkipIndexingParentDocuments",
            "value": "skipIndexingParentDocuments",
            "description": "The source document will be skipped from writing into the indexer's target\nindex."
          },
          {
            "name": "IncludeIndexingParentDocuments",
            "value": "includeIndexingParentDocuments",
            "description": "The source document will be written into the indexer's target index. This is\nthe default pattern."
          }
        ]
      }
    },
    "IndexerExecutionEnvironment": {
      "type": "string",
      "description": "Specifies the environment in which the indexer should execute.",
      "enum": [
        "standard",
        "private"
      ],
      "x-ms-enum": {
        "name": "IndexerExecutionEnvironment",
        "modelAsString": true,
        "values": [
          {
            "name": "standard",
            "value": "standard",
            "description": "Indicates that the search service can determine where the indexer should\nexecute. This is the default environment when nothing is specified and is the\nrecommended value."
          },
          {
            "name": "private",
            "value": "private",
            "description": "Indicates that the indexer should run with the environment provisioned\nspecifically for the search service. This should only be specified as the\nexecution environment if the indexer needs to access resources securely over\nshared private link resources."
          }
        ]
      }
    },
    "IndexerExecutionResult": {
      "type": "object",
      "description": "Represents the result of an individual indexer execution.",
      "properties": {
        "status": {
          "$ref": "#/definitions/IndexerExecutionStatus",
          "description": "The outcome of this indexer execution."
        },
        "errorMessage": {
          "type": "string",
          "description": "The error message indicating the top-level error, if any."
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "description": "The start time of this indexer execution."
        },
        "endTime": {
          "type": "string",
          "format": "date-time",
          "description": "The end time of this indexer execution, if the execution has already completed."
        },
        "errors": {
          "type": "array",
          "description": "The item-level indexing errors.",
          "items": {
            "$ref": "#/definitions/SearchIndexerError"
          },
          "x-ms-identifiers": []
        },
        "warnings": {
          "type": "array",
          "description": "The item-level indexing warnings.",
          "items": {
            "$ref": "#/definitions/SearchIndexerWarning"
          },
          "x-ms-identifiers": []
        },
        "itemsProcessed": {
          "type": "integer",
          "format": "int32",
          "description": "The number of items that were processed during this indexer execution. This\nincludes both successfully processed items and items where indexing was\nattempted but failed."
        },
        "itemsFailed": {
          "type": "integer",
          "format": "int32",
          "description": "The number of items that failed to be indexed during this indexer execution."
        },
        "initialTrackingState": {
          "type": "string",
          "description": "Change tracking state with which an indexer execution started."
        },
        "finalTrackingState": {
          "type": "string",
          "description": "Change tracking state with which an indexer execution finished."
        }
      },
      "required": [
        "status",
        "errors",
        "warnings",
        "itemsProcessed",
        "itemsFailed"
      ]
    },
    "IndexerExecutionStatus": {
      "type": "string",
      "description": "Represents the status of an individual indexer execution.",
      "enum": [
        "transientFailure",
        "success",
        "inProgress",
        "reset"
      ],
      "x-ms-enum": {
        "name": "IndexerExecutionStatus",
        "modelAsString": true,
        "values": [
          {
            "name": "TransientFailure",
            "value": "transientFailure",
            "description": "An indexer invocation has failed, but the failure may be transient. Indexer\ninvocations will continue per schedule."
          },
          {
            "name": "Success",
            "value": "success",
            "description": "Indexer execution completed successfully."
          },
          {
            "name": "InProgress",
            "value": "inProgress",
            "description": "Indexer execution is in progress."
          },
          {
            "name": "Reset",
            "value": "reset",
            "description": "Indexer has been reset."
          }
        ]
      }
    },
    "IndexerStatus": {
      "type": "string",
      "description": "Represents the overall indexer status.",
      "enum": [
        "unknown",
        "error",
        "running"
      ],
      "x-ms-enum": {
        "name": "IndexerStatus",
        "modelAsString": true,
        "values": [
          {
            "name": "Unknown",
            "value": "unknown",
            "description": "Indicates that the indexer is in an unknown state."
          },
          {
            "name": "Error",
            "value": "error",
            "description": "Indicates that the indexer experienced an error that cannot be corrected\nwithout human intervention."
          },
          {
            "name": "Running",
            "value": "running",
            "description": "Indicates that the indexer is running normally."
          }
        ]
      }
    },
    "IndexingParameters": {
      "type": "object",
      "description": "Represents parameters for indexer execution.",
      "properties": {
        "batchSize": {
          "type": "integer",
          "format": "int32",
          "description": "The number of items that are read from the data source and indexed as a single\nbatch in order to improve performance. The default depends on the data source\ntype."
        },
        "maxFailedItems": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum number of items that can fail indexing for indexer execution to\nstill be considered successful. -1 means no limit. Default is 0."
        },
        "maxFailedItemsPerBatch": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum number of items in a single batch that can fail indexing for the\nbatch to still be considered successful. -1 means no limit. Default is 0."
        },
        "configuration": {
          "$ref": "#/definitions/IndexingParametersConfiguration",
          "description": "A dictionary of indexer-specific configuration properties. Each name is the\nname of a specific property. Each value must be of a primitive type."
        }
      }
    },
    "IndexingParametersConfiguration": {
      "type": "object",
      "description": "A dictionary of indexer-specific configuration properties. Each name is the\nname of a specific property. Each value must be of a primitive type.",
      "properties": {
        "parsingMode": {
          "type": "string",
          "description": "Represents the parsing mode for indexing from an Azure blob data source.",
          "default": "default",
          "enum": [
            "default",
            "text",
            "delimitedText",
            "json",
            "jsonArray",
            "jsonLines"
          ],
          "x-ms-enum": {
            "name": "BlobIndexerParsingMode",
            "modelAsString": true,
            "values": [
              {
                "name": "Default",
                "value": "default",
                "description": "Set to default for normal file processing."
              },
              {
                "name": "Text",
                "value": "text",
                "description": "Set to text to improve indexing performance on plain text files in blob storage."
              },
              {
                "name": "DelimitedText",
                "value": "delimitedText",
                "description": "Set to delimitedText when blobs are plain CSV files."
              },
              {
                "name": "Json",
                "value": "json",
                "description": "Set to json to extract structured content from JSON files."
              },
              {
                "name": "JsonArray",
                "value": "jsonArray",
                "description": "Set to jsonArray to extract individual elements of a JSON array as separate\ndocuments."
              },
              {
                "name": "JsonLines",
                "value": "jsonLines",
                "description": "Set to jsonLines to extract individual JSON entities, separated by a new line,\nas separate documents."
              }
            ]
          }
        },
        "excludedFileNameExtensions": {
          "type": "string",
          "description": "Comma-delimited list of filename extensions to ignore when processing from\nAzure blob storage.  For example, you could exclude \".png, .mp4\" to skip over\nthose files during indexing."
        },
        "indexedFileNameExtensions": {
          "type": "string",
          "description": "Comma-delimited list of filename extensions to select when processing from\nAzure blob storage.  For example, you could focus indexing on specific\napplication files \".docx, .pptx, .msg\" to specifically include those file\ntypes."
        },
        "failOnUnsupportedContentType": {
          "type": "boolean",
          "description": "For Azure blobs, set to false if you want to continue indexing when an\nunsupported content type is encountered, and you don't know all the content\ntypes (file extensions) in advance."
        },
        "failOnUnprocessableDocument": {
          "type": "boolean",
          "description": "For Azure blobs, set to false if you want to continue indexing if a document\nfails indexing."
        },
        "indexStorageMetadataOnlyForOversizedDocuments": {
          "type": "boolean",
          "description": "For Azure blobs, set this property to true to still index storage metadata for\nblob content that is too large to process. Oversized blobs are treated as\nerrors by default. For limits on blob size, see\nhttps://learn.microsoft.com/azure/search/search-limits-quotas-capacity."
        },
        "delimitedTextHeaders": {
          "type": "string",
          "description": "For CSV blobs, specifies a comma-delimited list of column headers, useful for\nmapping source fields to destination fields in an index."
        },
        "delimitedTextDelimiter": {
          "type": "string",
          "description": "For CSV blobs, specifies the end-of-line single-character delimiter for CSV\nfiles where each line starts a new document (for example, \"|\")."
        },
        "firstLineContainsHeaders": {
          "type": "boolean",
          "description": "For CSV blobs, indicates that the first (non-blank) line of each blob contains\nheaders.",
          "default": true
        },
        "documentRoot": {
          "type": "string",
          "description": "For JSON arrays, given a structured or semi-structured document, you can\nspecify a path to the array using this property."
        },
        "dataToExtract": {
          "type": "string",
          "description": "Specifies the data to extract from Azure blob storage and tells the indexer\nwhich data to extract from image content when \"imageAction\" is set to a value\nother than \"none\".  This applies to embedded image content in a .PDF or other\napplication, or image files such as .jpg and .png, in Azure blobs.",
          "default": "contentAndMetadata",
          "enum": [
            "storageMetadata",
            "allMetadata",
            "contentAndMetadata"
          ],
          "x-ms-enum": {
            "name": "BlobIndexerDataToExtract",
            "modelAsString": true,
            "values": [
              {
                "name": "StorageMetadata",
                "value": "storageMetadata",
                "description": "Indexes just the standard blob properties and user-specified metadata."
              },
              {
                "name": "AllMetadata",
                "value": "allMetadata",
                "description": "Extracts metadata provided by the Azure blob storage subsystem and the\ncontent-type specific metadata (for example, metadata unique to just .png files\nare indexed)."
              },
              {
                "name": "ContentAndMetadata",
                "value": "contentAndMetadata",
                "description": "Extracts all metadata and textual content from each blob."
              }
            ]
          }
        },
        "imageAction": {
          "type": "string",
          "description": "Determines how to process embedded images and image files in Azure blob\nstorage.  Setting the \"imageAction\" configuration to any value other than\n\"none\" requires that a skillset also be attached to that indexer.",
          "default": "none",
          "enum": [
            "none",
            "generateNormalizedImages",
            "generateNormalizedImagePerPage"
          ],
          "x-ms-enum": {
            "name": "BlobIndexerImageAction",
            "modelAsString": true,
            "values": [
              {
                "name": "None",
                "value": "none",
                "description": "Ignores embedded images or image files in the data set.  This is the default."
              },
              {
                "name": "GenerateNormalizedImages",
                "value": "generateNormalizedImages",
                "description": "Extracts text from images (for example, the word \"STOP\" from a traffic stop\nsign), and embeds it into the content field.  This action requires that\n\"dataToExtract\" is set to \"contentAndMetadata\".  A normalized image refers to\nadditional processing resulting in uniform image output, sized and rotated to\npromote consistent rendering when you include images in visual search results.\nThis information is generated for each image when you use this option."
              },
              {
                "name": "GenerateNormalizedImagePerPage",
                "value": "generateNormalizedImagePerPage",
                "description": "Extracts text from images (for example, the word \"STOP\" from a traffic stop\nsign), and embeds it into the content field, but treats PDF files differently\nin that each page will be rendered as an image and normalized accordingly,\ninstead of extracting embedded images.  Non-PDF file types will be treated the\nsame as if \"generateNormalizedImages\" was set."
              }
            ]
          }
        },
        "allowSkillsetToReadFileData": {
          "type": "boolean",
          "description": "If true, will create a path //document//file_data that is an object\nrepresenting the original file data downloaded from your blob data source.\nThis allows you to pass the original file data to a custom skill for processing\nwithin the enrichment pipeline, or to the Document Extraction skill."
        },
        "pdfTextRotationAlgorithm": {
          "type": "string",
          "description": "Determines algorithm for text extraction from PDF files in Azure blob storage.",
          "default": "none",
          "enum": [
            "none",
            "detectAngles"
          ],
          "x-ms-enum": {
            "name": "BlobIndexerPDFTextRotationAlgorithm",
            "modelAsString": true,
            "values": [
              {
                "name": "None",
                "value": "none",
                "description": "Leverages normal text extraction.  This is the default."
              },
              {
                "name": "DetectAngles",
                "value": "detectAngles",
                "description": "May produce better and more readable text extraction from PDF files that have\nrotated text within them.  Note that there may be a small performance speed\nimpact when this parameter is used.  This parameter only applies to PDF files,\nand only to PDFs with embedded text.  If the rotated text appears within an\nembedded image in the PDF, this parameter does not apply."
              }
            ]
          }
        },
        "executionEnvironment": {
          "type": "string",
          "description": "Specifies the environment in which the indexer should execute.",
          "default": "standard",
          "enum": [
            "standard",
            "private"
          ],
          "x-ms-enum": {
            "name": "IndexerExecutionEnvironment",
            "modelAsString": true,
            "values": [
              {
                "name": "standard",
                "value": "standard",
                "description": "Indicates that the search service can determine where the indexer should\nexecute. This is the default environment when nothing is specified and is the\nrecommended value."
              },
              {
                "name": "private",
                "value": "private",
                "description": "Indicates that the indexer should run with the environment provisioned\nspecifically for the search service. This should only be specified as the\nexecution environment if the indexer needs to access resources securely over\nshared private link resources."
              }
            ]
          }
        },
        "queryTimeout": {
          "type": "string",
          "description": "Increases the timeout beyond the 5-minute default for Azure SQL database data\nsources, specified in the format \"hh:mm:ss\".",
          "default": "00:05:00"
        }
      },
      "additionalProperties": {}
    },
    "IndexingResult": {
      "type": "object",
      "description": "Status of an indexing operation for a single document.",
      "properties": {
        "key": {
          "type": "string",
          "description": "The key of a document that was in the indexing request."
        },
        "errorMessage": {
          "type": "string",
          "description": "The error message explaining why the indexing operation failed for the document\nidentified by the key; null if indexing succeeded."
        },
        "status": {
          "type": "boolean",
          "description": "A value indicating whether the indexing operation succeeded for the document\nidentified by the key."
        },
        "statusCode": {
          "type": "integer",
          "format": "int32",
          "description": "The status code of the indexing operation. Possible values include: 200 for a\nsuccessful update or delete, 201 for successful document creation, 400 for a\nmalformed input document, 404 for document not found, 409 for a version\nconflict, 422 when the index is temporarily unavailable, or 503 for when the\nservice is too busy."
        }
      },
      "required": [
        "key",
        "status",
        "statusCode"
      ]
    },
    "IndexingSchedule": {
      "type": "object",
      "description": "Represents a schedule for indexer execution.",
      "properties": {
        "interval": {
          "type": "string",
          "format": "duration",
          "description": "The interval of time between indexer executions."
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when an indexer should start running."
        }
      },
      "required": [
        "interval"
      ]
    },
    "InputFieldMappingEntry": {
      "type": "object",
      "description": "Input field mapping for a skill.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the input."
        },
        "source": {
          "type": "string",
          "description": "The source of the input."
        },
        "sourceContext": {
          "type": "string",
          "description": "The source context used for selecting recursive inputs."
        },
        "inputs": {
          "type": "array",
          "description": "The recursive inputs used when creating a complex type.",
          "items": {
            "$ref": "#/definitions/InputFieldMappingEntry"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "name"
      ]
    },
    "KeepTokenFilter": {
      "type": "object",
      "description": "A token filter that only keeps tokens with text contained in a specified list\nof words. This token filter is implemented using Apache Lucene.",
      "properties": {
        "keepWords": {
          "type": "array",
          "description": "The list of words to keep.",
          "items": {
            "type": "string"
          }
        },
        "keepWordsCase": {
          "type": "boolean",
          "description": "A value indicating whether to lower case all words first. Default is false."
        }
      },
      "required": [
        "keepWords"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.KeepTokenFilter"
    },
    "KeyPhraseExtractionSkill": {
      "type": "object",
      "description": "A skill that uses text analytics for key phrase extraction.",
      "properties": {
        "defaultLanguageCode": {
          "$ref": "#/definitions/KeyPhraseExtractionSkillLanguage",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "maxKeyPhraseCount": {
          "type": "integer",
          "format": "int32",
          "description": "A number indicating how many key phrases to return. If absent, all identified\nkey phrases will be returned."
        },
        "modelVersion": {
          "type": "string",
          "description": "The version of the model to use when calling the Text Analytics service. It\nwill default to the latest available when not specified. We recommend you do\nnot specify this value unless absolutely necessary."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.KeyPhraseExtractionSkill"
    },
    "KeyPhraseExtractionSkillLanguage": {
      "type": "string",
      "description": "The language codes supported for input text by KeyPhraseExtractionSkill.",
      "enum": [
        "da",
        "nl",
        "en",
        "fi",
        "fr",
        "de",
        "it",
        "ja",
        "ko",
        "no",
        "pl",
        "pt-PT",
        "pt-BR",
        "ru",
        "es",
        "sv"
      ],
      "x-ms-enum": {
        "name": "KeyPhraseExtractionSkillLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "da",
            "value": "da",
            "description": "Danish"
          },
          {
            "name": "nl",
            "value": "nl",
            "description": "Dutch"
          },
          {
            "name": "en",
            "value": "en",
            "description": "English"
          },
          {
            "name": "fi",
            "value": "fi",
            "description": "Finnish"
          },
          {
            "name": "fr",
            "value": "fr",
            "description": "French"
          },
          {
            "name": "de",
            "value": "de",
            "description": "German"
          },
          {
            "name": "it",
            "value": "it",
            "description": "Italian"
          },
          {
            "name": "ja",
            "value": "ja",
            "description": "Japanese"
          },
          {
            "name": "ko",
            "value": "ko",
            "description": "Korean"
          },
          {
            "name": "no",
            "value": "no",
            "description": "Norwegian (Bokmaal)"
          },
          {
            "name": "pl",
            "value": "pl",
            "description": "Polish"
          },
          {
            "name": "pt-PT",
            "value": "pt-PT",
            "description": "Portuguese (Portugal)"
          },
          {
            "name": "pt-BR",
            "value": "pt-BR",
            "description": "Portuguese (Brazil)"
          },
          {
            "name": "ru",
            "value": "ru",
            "description": "Russian"
          },
          {
            "name": "es",
            "value": "es",
            "description": "Spanish"
          },
          {
            "name": "sv",
            "value": "sv",
            "description": "Swedish"
          }
        ]
      }
    },
    "KeywordMarkerTokenFilter": {
      "type": "object",
      "description": "Marks terms as keywords. This token filter is implemented using Apache Lucene.",
      "properties": {
        "keywords": {
          "type": "array",
          "description": "A list of words to mark as keywords.",
          "items": {
            "type": "string"
          }
        },
        "ignoreCase": {
          "type": "boolean",
          "description": "A value indicating whether to ignore case. If true, all words are converted to\nlower case first. Default is false."
        }
      },
      "required": [
        "keywords"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.KeywordMarkerTokenFilter"
    },
    "KeywordTokenizerV2": {
      "type": "object",
      "description": "Emits the entire input as a single token. This tokenizer is implemented using\nApache Lucene.",
      "properties": {
        "maxTokenLength": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum token length. Default is 256. Tokens longer than the maximum length\nare split. The maximum token length that can be used is 300 characters.",
          "default": 256,
          "maximum": 300
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.KeywordTokenizerV2"
    },
    "LanguageDetectionSkill": {
      "type": "object",
      "description": "A skill that detects the language of input text and reports a single language\ncode for every document submitted on the request. The language code is paired\nwith a score indicating the confidence of the analysis.",
      "properties": {
        "defaultCountryHint": {
          "type": "string",
          "description": "A country code to use as a hint to the language detection model if it cannot\ndisambiguate the language."
        },
        "modelVersion": {
          "type": "string",
          "description": "The version of the model to use when calling the Text Analytics service. It\nwill default to the latest available when not specified. We recommend you do\nnot specify this value unless absolutely necessary."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.LanguageDetectionSkill"
    },
    "LengthTokenFilter": {
      "type": "object",
      "description": "Removes words that are too long or too short. This token filter is implemented\nusing Apache Lucene.",
      "properties": {
        "min": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum length in characters. Default is 0. Maximum is 300. Must be less\nthan the value of max.",
          "maximum": 300
        },
        "max": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum length in characters. Default and maximum is 300.",
          "default": 300,
          "maximum": 300
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.LengthTokenFilter"
    },
    "LexicalAnalyzer": {
      "type": "object",
      "description": "Base type for analyzers.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        },
        "name": {
          "type": "string",
          "description": "The name of the analyzer. It must only contain letters, digits, spaces, dashes\nor underscores, can only start and end with alphanumeric characters, and is\nlimited to 128 characters."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type",
        "name"
      ]
    },
    "LexicalAnalyzerName": {
      "type": "string",
      "description": "Defines the names of all text analyzers supported by the search engine.",
      "enum": [
        "ar.microsoft",
        "ar.lucene",
        "hy.lucene",
        "bn.microsoft",
        "eu.lucene",
        "bg.microsoft",
        "bg.lucene",
        "ca.microsoft",
        "ca.lucene",
        "zh-Hans.microsoft",
        "zh-Hans.lucene",
        "zh-Hant.microsoft",
        "zh-Hant.lucene",
        "hr.microsoft",
        "cs.microsoft",
        "cs.lucene",
        "da.microsoft",
        "da.lucene",
        "nl.microsoft",
        "nl.lucene",
        "en.microsoft",
        "en.lucene",
        "et.microsoft",
        "fi.microsoft",
        "fi.lucene",
        "fr.microsoft",
        "fr.lucene",
        "gl.lucene",
        "de.microsoft",
        "de.lucene",
        "el.microsoft",
        "el.lucene",
        "gu.microsoft",
        "he.microsoft",
        "hi.microsoft",
        "hi.lucene",
        "hu.microsoft",
        "hu.lucene",
        "is.microsoft",
        "id.microsoft",
        "id.lucene",
        "ga.lucene",
        "it.microsoft",
        "it.lucene",
        "ja.microsoft",
        "ja.lucene",
        "kn.microsoft",
        "ko.microsoft",
        "ko.lucene",
        "lv.microsoft",
        "lv.lucene",
        "lt.microsoft",
        "ml.microsoft",
        "ms.microsoft",
        "mr.microsoft",
        "nb.microsoft",
        "no.lucene",
        "fa.lucene",
        "pl.microsoft",
        "pl.lucene",
        "pt-BR.microsoft",
        "pt-BR.lucene",
        "pt-PT.microsoft",
        "pt-PT.lucene",
        "pa.microsoft",
        "ro.microsoft",
        "ro.lucene",
        "ru.microsoft",
        "ru.lucene",
        "sr-cyrillic.microsoft",
        "sr-latin.microsoft",
        "sk.microsoft",
        "sl.microsoft",
        "es.microsoft",
        "es.lucene",
        "sv.microsoft",
        "sv.lucene",
        "ta.microsoft",
        "te.microsoft",
        "th.microsoft",
        "th.lucene",
        "tr.microsoft",
        "tr.lucene",
        "uk.microsoft",
        "ur.microsoft",
        "vi.microsoft",
        "standard.lucene",
        "standardasciifolding.lucene",
        "keyword",
        "pattern",
        "simple",
        "stop",
        "whitespace"
      ],
      "x-ms-enum": {
        "name": "LexicalAnalyzerName",
        "modelAsString": true,
        "values": [
          {
            "name": "ArMicrosoft",
            "value": "ar.microsoft",
            "description": "Microsoft analyzer for Arabic."
          },
          {
            "name": "ArLucene",
            "value": "ar.lucene",
            "description": "Lucene analyzer for Arabic."
          },
          {
            "name": "HyLucene",
            "value": "hy.lucene",
            "description": "Lucene analyzer for Armenian."
          },
          {
            "name": "BnMicrosoft",
            "value": "bn.microsoft",
            "description": "Microsoft analyzer for Bangla."
          },
          {
            "name": "EuLucene",
            "value": "eu.lucene",
            "description": "Lucene analyzer for Basque."
          },
          {
            "name": "BgMicrosoft",
            "value": "bg.microsoft",
            "description": "Microsoft analyzer for Bulgarian."
          },
          {
            "name": "BgLucene",
            "value": "bg.lucene",
            "description": "Lucene analyzer for Bulgarian."
          },
          {
            "name": "CaMicrosoft",
            "value": "ca.microsoft",
            "description": "Microsoft analyzer for Catalan."
          },
          {
            "name": "CaLucene",
            "value": "ca.lucene",
            "description": "Lucene analyzer for Catalan."
          },
          {
            "name": "ZhHansMicrosoft",
            "value": "zh-Hans.microsoft",
            "description": "Microsoft analyzer for Chinese (Simplified)."
          },
          {
            "name": "ZhHansLucene",
            "value": "zh-Hans.lucene",
            "description": "Lucene analyzer for Chinese (Simplified)."
          },
          {
            "name": "ZhHantMicrosoft",
            "value": "zh-Hant.microsoft",
            "description": "Microsoft analyzer for Chinese (Traditional)."
          },
          {
            "name": "ZhHantLucene",
            "value": "zh-Hant.lucene",
            "description": "Lucene analyzer for Chinese (Traditional)."
          },
          {
            "name": "HrMicrosoft",
            "value": "hr.microsoft",
            "description": "Microsoft analyzer for Croatian."
          },
          {
            "name": "CsMicrosoft",
            "value": "cs.microsoft",
            "description": "Microsoft analyzer for Czech."
          },
          {
            "name": "CsLucene",
            "value": "cs.lucene",
            "description": "Lucene analyzer for Czech."
          },
          {
            "name": "DaMicrosoft",
            "value": "da.microsoft",
            "description": "Microsoft analyzer for Danish."
          },
          {
            "name": "DaLucene",
            "value": "da.lucene",
            "description": "Lucene analyzer for Danish."
          },
          {
            "name": "NlMicrosoft",
            "value": "nl.microsoft",
            "description": "Microsoft analyzer for Dutch."
          },
          {
            "name": "NlLucene",
            "value": "nl.lucene",
            "description": "Lucene analyzer for Dutch."
          },
          {
            "name": "EnMicrosoft",
            "value": "en.microsoft",
            "description": "Microsoft analyzer for English."
          },
          {
            "name": "EnLucene",
            "value": "en.lucene",
            "description": "Lucene analyzer for English."
          },
          {
            "name": "EtMicrosoft",
            "value": "et.microsoft",
            "description": "Microsoft analyzer for Estonian."
          },
          {
            "name": "FiMicrosoft",
            "value": "fi.microsoft",
            "description": "Microsoft analyzer for Finnish."
          },
          {
            "name": "FiLucene",
            "value": "fi.lucene",
            "description": "Lucene analyzer for Finnish."
          },
          {
            "name": "FrMicrosoft",
            "value": "fr.microsoft",
            "description": "Microsoft analyzer for French."
          },
          {
            "name": "FrLucene",
            "value": "fr.lucene",
            "description": "Lucene analyzer for French."
          },
          {
            "name": "GlLucene",
            "value": "gl.lucene",
            "description": "Lucene analyzer for Galician."
          },
          {
            "name": "DeMicrosoft",
            "value": "de.microsoft",
            "description": "Microsoft analyzer for German."
          },
          {
            "name": "DeLucene",
            "value": "de.lucene",
            "description": "Lucene analyzer for German."
          },
          {
            "name": "ElMicrosoft",
            "value": "el.microsoft",
            "description": "Microsoft analyzer for Greek."
          },
          {
            "name": "ElLucene",
            "value": "el.lucene",
            "description": "Lucene analyzer for Greek."
          },
          {
            "name": "GuMicrosoft",
            "value": "gu.microsoft",
            "description": "Microsoft analyzer for Gujarati."
          },
          {
            "name": "HeMicrosoft",
            "value": "he.microsoft",
            "description": "Microsoft analyzer for Hebrew."
          },
          {
            "name": "HiMicrosoft",
            "value": "hi.microsoft",
            "description": "Microsoft analyzer for Hindi."
          },
          {
            "name": "HiLucene",
            "value": "hi.lucene",
            "description": "Lucene analyzer for Hindi."
          },
          {
            "name": "HuMicrosoft",
            "value": "hu.microsoft",
            "description": "Microsoft analyzer for Hungarian."
          },
          {
            "name": "HuLucene",
            "value": "hu.lucene",
            "description": "Lucene analyzer for Hungarian."
          },
          {
            "name": "IsMicrosoft",
            "value": "is.microsoft",
            "description": "Microsoft analyzer for Icelandic."
          },
          {
            "name": "IdMicrosoft",
            "value": "id.microsoft",
            "description": "Microsoft analyzer for Indonesian (Bahasa)."
          },
          {
            "name": "IdLucene",
            "value": "id.lucene",
            "description": "Lucene analyzer for Indonesian."
          },
          {
            "name": "GaLucene",
            "value": "ga.lucene",
            "description": "Lucene analyzer for Irish."
          },
          {
            "name": "ItMicrosoft",
            "value": "it.microsoft",
            "description": "Microsoft analyzer for Italian."
          },
          {
            "name": "ItLucene",
            "value": "it.lucene",
            "description": "Lucene analyzer for Italian."
          },
          {
            "name": "JaMicrosoft",
            "value": "ja.microsoft",
            "description": "Microsoft analyzer for Japanese."
          },
          {
            "name": "JaLucene",
            "value": "ja.lucene",
            "description": "Lucene analyzer for Japanese."
          },
          {
            "name": "KnMicrosoft",
            "value": "kn.microsoft",
            "description": "Microsoft analyzer for Kannada."
          },
          {
            "name": "KoMicrosoft",
            "value": "ko.microsoft",
            "description": "Microsoft analyzer for Korean."
          },
          {
            "name": "KoLucene",
            "value": "ko.lucene",
            "description": "Lucene analyzer for Korean."
          },
          {
            "name": "LvMicrosoft",
            "value": "lv.microsoft",
            "description": "Microsoft analyzer for Latvian."
          },
          {
            "name": "LvLucene",
            "value": "lv.lucene",
            "description": "Lucene analyzer for Latvian."
          },
          {
            "name": "LtMicrosoft",
            "value": "lt.microsoft",
            "description": "Microsoft analyzer for Lithuanian."
          },
          {
            "name": "MlMicrosoft",
            "value": "ml.microsoft",
            "description": "Microsoft analyzer for Malayalam."
          },
          {
            "name": "MsMicrosoft",
            "value": "ms.microsoft",
            "description": "Microsoft analyzer for Malay (Latin)."
          },
          {
            "name": "MrMicrosoft",
            "value": "mr.microsoft",
            "description": "Microsoft analyzer for Marathi."
          },
          {
            "name": "NbMicrosoft",
            "value": "nb.microsoft",
            "description": "Microsoft analyzer for Norwegian (Bokmål)."
          },
          {
            "name": "NoLucene",
            "value": "no.lucene",
            "description": "Lucene analyzer for Norwegian."
          },
          {
            "name": "FaLucene",
            "value": "fa.lucene",
            "description": "Lucene analyzer for Persian."
          },
          {
            "name": "PlMicrosoft",
            "value": "pl.microsoft",
            "description": "Microsoft analyzer for Polish."
          },
          {
            "name": "PlLucene",
            "value": "pl.lucene",
            "description": "Lucene analyzer for Polish."
          },
          {
            "name": "PtBrMicrosoft",
            "value": "pt-BR.microsoft",
            "description": "Microsoft analyzer for Portuguese (Brazil)."
          },
          {
            "name": "PtBrLucene",
            "value": "pt-BR.lucene",
            "description": "Lucene analyzer for Portuguese (Brazil)."
          },
          {
            "name": "PtPtMicrosoft",
            "value": "pt-PT.microsoft",
            "description": "Microsoft analyzer for Portuguese (Portugal)."
          },
          {
            "name": "PtPtLucene",
            "value": "pt-PT.lucene",
            "description": "Lucene analyzer for Portuguese (Portugal)."
          },
          {
            "name": "PaMicrosoft",
            "value": "pa.microsoft",
            "description": "Microsoft analyzer for Punjabi."
          },
          {
            "name": "RoMicrosoft",
            "value": "ro.microsoft",
            "description": "Microsoft analyzer for Romanian."
          },
          {
            "name": "RoLucene",
            "value": "ro.lucene",
            "description": "Lucene analyzer for Romanian."
          },
          {
            "name": "RuMicrosoft",
            "value": "ru.microsoft",
            "description": "Microsoft analyzer for Russian."
          },
          {
            "name": "RuLucene",
            "value": "ru.lucene",
            "description": "Lucene analyzer for Russian."
          },
          {
            "name": "SrCyrillicMicrosoft",
            "value": "sr-cyrillic.microsoft",
            "description": "Microsoft analyzer for Serbian (Cyrillic)."
          },
          {
            "name": "SrLatinMicrosoft",
            "value": "sr-latin.microsoft",
            "description": "Microsoft analyzer for Serbian (Latin)."
          },
          {
            "name": "SkMicrosoft",
            "value": "sk.microsoft",
            "description": "Microsoft analyzer for Slovak."
          },
          {
            "name": "SlMicrosoft",
            "value": "sl.microsoft",
            "description": "Microsoft analyzer for Slovenian."
          },
          {
            "name": "EsMicrosoft",
            "value": "es.microsoft",
            "description": "Microsoft analyzer for Spanish."
          },
          {
            "name": "EsLucene",
            "value": "es.lucene",
            "description": "Lucene analyzer for Spanish."
          },
          {
            "name": "SvMicrosoft",
            "value": "sv.microsoft",
            "description": "Microsoft analyzer for Swedish."
          },
          {
            "name": "SvLucene",
            "value": "sv.lucene",
            "description": "Lucene analyzer for Swedish."
          },
          {
            "name": "TaMicrosoft",
            "value": "ta.microsoft",
            "description": "Microsoft analyzer for Tamil."
          },
          {
            "name": "TeMicrosoft",
            "value": "te.microsoft",
            "description": "Microsoft analyzer for Telugu."
          },
          {
            "name": "ThMicrosoft",
            "value": "th.microsoft",
            "description": "Microsoft analyzer for Thai."
          },
          {
            "name": "ThLucene",
            "value": "th.lucene",
            "description": "Lucene analyzer for Thai."
          },
          {
            "name": "TrMicrosoft",
            "value": "tr.microsoft",
            "description": "Microsoft analyzer for Turkish."
          },
          {
            "name": "TrLucene",
            "value": "tr.lucene",
            "description": "Lucene analyzer for Turkish."
          },
          {
            "name": "UkMicrosoft",
            "value": "uk.microsoft",
            "description": "Microsoft analyzer for Ukrainian."
          },
          {
            "name": "UrMicrosoft",
            "value": "ur.microsoft",
            "description": "Microsoft analyzer for Urdu."
          },
          {
            "name": "ViMicrosoft",
            "value": "vi.microsoft",
            "description": "Microsoft analyzer for Vietnamese."
          },
          {
            "name": "StandardLucene",
            "value": "standard.lucene",
            "description": "Standard Lucene analyzer."
          },
          {
            "name": "StandardAsciiFoldingLucene",
            "value": "standardasciifolding.lucene",
            "description": "Standard ASCII Folding Lucene analyzer. See\nhttps://learn.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#Analyzers"
          },
          {
            "name": "Keyword",
            "value": "keyword",
            "description": "Treats the entire content of a field as a single token. This is useful for data\nlike zip codes, ids, and some product names. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordAnalyzer.html"
          },
          {
            "name": "Pattern",
            "value": "pattern",
            "description": "Flexibly separates text into terms via a regular expression pattern. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/PatternAnalyzer.html"
          },
          {
            "name": "Simple",
            "value": "simple",
            "description": "Divides text at non-letters and converts them to lower case. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/SimpleAnalyzer.html"
          },
          {
            "name": "Stop",
            "value": "stop",
            "description": "Divides text at non-letters; Applies the lowercase and stopword token filters.\nSee\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopAnalyzer.html"
          },
          {
            "name": "Whitespace",
            "value": "whitespace",
            "description": "An analyzer that uses the whitespace tokenizer. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceAnalyzer.html"
          }
        ]
      }
    },
    "LexicalTokenizer": {
      "type": "object",
      "description": "Base type for tokenizers.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        },
        "name": {
          "type": "string",
          "description": "The name of the tokenizer. It must only contain letters, digits, spaces, dashes\nor underscores, can only start and end with alphanumeric characters, and is\nlimited to 128 characters."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type",
        "name"
      ]
    },
    "LexicalTokenizerName": {
      "type": "string",
      "description": "Defines the names of all tokenizers supported by the search engine.",
      "enum": [
        "classic",
        "edgeNGram",
        "keyword_v2",
        "letter",
        "lowercase",
        "microsoft_language_tokenizer",
        "microsoft_language_stemming_tokenizer",
        "nGram",
        "path_hierarchy_v2",
        "pattern",
        "standard_v2",
        "uax_url_email",
        "whitespace"
      ],
      "x-ms-enum": {
        "name": "LexicalTokenizerName",
        "modelAsString": true,
        "values": [
          {
            "name": "Classic",
            "value": "classic",
            "description": "Grammar-based tokenizer that is suitable for processing most European-language\ndocuments. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicTokenizer.html"
          },
          {
            "name": "EdgeNGram",
            "value": "edgeNGram",
            "description": "Tokenizes the input from an edge into n-grams of the given size(s). See\nhttps://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.html"
          },
          {
            "name": "Keyword",
            "value": "keyword_v2",
            "description": "Emits the entire input as a single token. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordTokenizer.html"
          },
          {
            "name": "Letter",
            "value": "letter",
            "description": "Divides text at non-letters. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LetterTokenizer.html"
          },
          {
            "name": "Lowercase",
            "value": "lowercase",
            "description": "Divides text at non-letters and converts them to lower case. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseTokenizer.html"
          },
          {
            "name": "MicrosoftLanguageTokenizer",
            "value": "microsoft_language_tokenizer",
            "description": "Divides text using language-specific rules."
          },
          {
            "name": "MicrosoftLanguageStemmingTokenizer",
            "value": "microsoft_language_stemming_tokenizer",
            "description": "Divides text using language-specific rules and reduces words to their base\nforms."
          },
          {
            "name": "NGram",
            "value": "nGram",
            "description": "Tokenizes the input into n-grams of the given size(s). See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenizer.html"
          },
          {
            "name": "PathHierarchy",
            "value": "path_hierarchy_v2",
            "description": "Tokenizer for path-like hierarchies. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/path/PathHierarchyTokenizer.html"
          },
          {
            "name": "Pattern",
            "value": "pattern",
            "description": "Tokenizer that uses regex pattern matching to construct distinct tokens. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/pattern/PatternTokenizer.html"
          },
          {
            "name": "Standard",
            "value": "standard_v2",
            "description": "Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter\nand stop filter. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/StandardTokenizer.html"
          },
          {
            "name": "UaxUrlEmail",
            "value": "uax_url_email",
            "description": "Tokenizes urls and emails as one token. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizer.html"
          },
          {
            "name": "Whitespace",
            "value": "whitespace",
            "description": "Divides text at whitespace. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceTokenizer.html"
          }
        ]
      }
    },
    "LimitTokenFilter": {
      "type": "object",
      "description": "Limits the number of tokens while indexing. This token filter is implemented\nusing Apache Lucene.",
      "properties": {
        "maxTokenCount": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum number of tokens to produce. Default is 1.",
          "default": 1
        },
        "consumeAllTokens": {
          "type": "boolean",
          "description": "A value indicating whether all tokens from the input must be consumed even if\nmaxTokenCount is reached. Default is false."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.LimitTokenFilter"
    },
    "ListDataSourcesResult": {
      "type": "object",
      "description": "Response from a List Datasources request. If successful, it includes the full\ndefinitions of all datasources.",
      "properties": {
        "value": {
          "type": "array",
          "description": "The datasources in the Search service.",
          "items": {
            "$ref": "#/definitions/SearchIndexerDataSource"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "value"
      ]
    },
    "ListIndexersResult": {
      "type": "object",
      "description": "Response from a List Indexers request. If successful, it includes the full\ndefinitions of all indexers.",
      "properties": {
        "value": {
          "type": "array",
          "description": "The indexers in the Search service.",
          "items": {
            "$ref": "#/definitions/SearchIndexer"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "value"
      ]
    },
    "ListIndexesResult": {
      "type": "object",
      "description": "Response from a List Indexes request. If successful, it includes the full\ndefinitions of all indexes.",
      "properties": {
        "value": {
          "type": "array",
          "description": "The indexes in the Search service.",
          "items": {
            "$ref": "#/definitions/SearchIndex"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "value"
      ]
    },
    "ListSkillsetsResult": {
      "type": "object",
      "description": "Response from a list skillset request. If successful, it includes the full\ndefinitions of all skillsets.",
      "properties": {
        "value": {
          "type": "array",
          "description": "The skillsets defined in the Search service.",
          "items": {
            "$ref": "#/definitions/SearchIndexerSkillset"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "value"
      ]
    },
    "ListSynonymMapsResult": {
      "type": "object",
      "description": "Response from a List SynonymMaps request. If successful, it includes the full\ndefinitions of all synonym maps.",
      "properties": {
        "value": {
          "type": "array",
          "description": "The synonym maps in the Search service.",
          "items": {
            "$ref": "#/definitions/SynonymMap"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "value"
      ]
    },
    "LookupDocument": {
      "type": "object",
      "description": "A document retrieved via a document lookup operation.",
      "additionalProperties": {}
    },
    "LuceneStandardAnalyzer": {
      "type": "object",
      "description": "Standard Apache Lucene analyzer; Composed of the standard tokenizer, lowercase\nfilter and stop filter.",
      "properties": {
        "maxTokenLength": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum token length. Default is 255. Tokens longer than the maximum length\nare split. The maximum token length that can be used is 300 characters.",
          "default": 255,
          "maximum": 300
        },
        "stopwords": {
          "type": "array",
          "description": "A list of stopwords.",
          "items": {
            "type": "string"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalAnalyzer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.StandardAnalyzer"
    },
    "LuceneStandardTokenizerV2": {
      "type": "object",
      "description": "Breaks text following the Unicode Text Segmentation rules. This tokenizer is\nimplemented using Apache Lucene.",
      "properties": {
        "maxTokenLength": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum token length. Default is 255. Tokens longer than the maximum length\nare split. The maximum token length that can be used is 300 characters.",
          "default": 255,
          "maximum": 300
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.StandardTokenizerV2"
    },
    "MagnitudeScoringFunction": {
      "type": "object",
      "description": "Defines a function that boosts scores based on the magnitude of a numeric field.",
      "properties": {
        "magnitude": {
          "$ref": "#/definitions/MagnitudeScoringParameters",
          "description": "Parameter values for the magnitude scoring function."
        }
      },
      "required": [
        "magnitude"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/ScoringFunction"
        }
      ],
      "x-ms-discriminator-value": "magnitude"
    },
    "MagnitudeScoringParameters": {
      "type": "object",
      "description": "Provides parameter values to a magnitude scoring function.",
      "properties": {
        "boostingRangeStart": {
          "type": "number",
          "format": "double",
          "description": "The field value at which boosting starts."
        },
        "boostingRangeEnd": {
          "type": "number",
          "format": "double",
          "description": "The field value at which boosting ends."
        },
        "constantBoostBeyondRange": {
          "type": "boolean",
          "description": "A value indicating whether to apply a constant boost for field values beyond\nthe range end value; default is false."
        }
      },
      "required": [
        "boostingRangeStart",
        "boostingRangeEnd"
      ]
    },
    "MappingCharFilter": {
      "type": "object",
      "description": "A character filter that applies mappings defined with the mappings option.\nMatching is greedy (longest pattern matching at a given point wins).\nReplacement is allowed to be the empty string. This character filter is\nimplemented using Apache Lucene.",
      "properties": {
        "mappings": {
          "type": "array",
          "description": "A list of mappings of the following format: \"a=>b\" (all occurrences of the\ncharacter \"a\" will be replaced with character \"b\").",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "mappings"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/CharFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.MappingCharFilter"
    },
    "MergeSkill": {
      "type": "object",
      "description": "A skill for merging two or more strings into a single unified string, with an\noptional user-defined delimiter separating each component part.",
      "properties": {
        "insertPreTag": {
          "type": "string",
          "description": "The tag indicates the start of the merged text. By default, the tag is an empty\nspace.",
          "default": " "
        },
        "insertPostTag": {
          "type": "string",
          "description": "The tag indicates the end of the merged text. By default, the tag is an empty\nspace.",
          "default": " "
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.MergeSkill"
    },
    "MicrosoftLanguageStemmingTokenizer": {
      "type": "object",
      "description": "Divides text using language-specific rules and reduces words to their base\nforms.",
      "properties": {
        "maxTokenLength": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum token length. Tokens longer than the maximum length are split.\nMaximum token length that can be used is 300 characters. Tokens longer than 300\ncharacters are first split into tokens of length 300 and then each of those\ntokens is split based on the max token length set. Default is 255.",
          "default": 255,
          "maximum": 300
        },
        "isSearchTokenizer": {
          "type": "boolean",
          "description": "A value indicating how the tokenizer is used. Set to true if used as the search\ntokenizer, set to false if used as the indexing tokenizer. Default is false."
        },
        "language": {
          "$ref": "#/definitions/MicrosoftStemmingTokenizerLanguage",
          "description": "The language to use. The default is English."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer"
    },
    "MicrosoftLanguageTokenizer": {
      "type": "object",
      "description": "Divides text using language-specific rules.",
      "properties": {
        "maxTokenLength": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum token length. Tokens longer than the maximum length are split.\nMaximum token length that can be used is 300 characters. Tokens longer than 300\ncharacters are first split into tokens of length 300 and then each of those\ntokens is split based on the max token length set. Default is 255.",
          "default": 255,
          "maximum": 300
        },
        "isSearchTokenizer": {
          "type": "boolean",
          "description": "A value indicating how the tokenizer is used. Set to true if used as the search\ntokenizer, set to false if used as the indexing tokenizer. Default is false."
        },
        "language": {
          "$ref": "#/definitions/MicrosoftTokenizerLanguage",
          "description": "The language to use. The default is English."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer"
    },
    "MicrosoftStemmingTokenizerLanguage": {
      "type": "string",
      "description": "Lists the languages supported by the Microsoft language stemming tokenizer.",
      "enum": [
        "arabic",
        "bangla",
        "bulgarian",
        "catalan",
        "croatian",
        "czech",
        "danish",
        "dutch",
        "english",
        "estonian",
        "finnish",
        "french",
        "german",
        "greek",
        "gujarati",
        "hebrew",
        "hindi",
        "hungarian",
        "icelandic",
        "indonesian",
        "italian",
        "kannada",
        "latvian",
        "lithuanian",
        "malay",
        "malayalam",
        "marathi",
        "norwegianBokmaal",
        "polish",
        "portuguese",
        "portugueseBrazilian",
        "punjabi",
        "romanian",
        "russian",
        "serbianCyrillic",
        "serbianLatin",
        "slovak",
        "slovenian",
        "spanish",
        "swedish",
        "tamil",
        "telugu",
        "turkish",
        "ukrainian",
        "urdu"
      ],
      "x-ms-enum": {
        "name": "MicrosoftStemmingTokenizerLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "Arabic",
            "value": "arabic",
            "description": "Selects the Microsoft stemming tokenizer for Arabic."
          },
          {
            "name": "Bangla",
            "value": "bangla",
            "description": "Selects the Microsoft stemming tokenizer for Bangla."
          },
          {
            "name": "Bulgarian",
            "value": "bulgarian",
            "description": "Selects the Microsoft stemming tokenizer for Bulgarian."
          },
          {
            "name": "Catalan",
            "value": "catalan",
            "description": "Selects the Microsoft stemming tokenizer for Catalan."
          },
          {
            "name": "Croatian",
            "value": "croatian",
            "description": "Selects the Microsoft stemming tokenizer for Croatian."
          },
          {
            "name": "Czech",
            "value": "czech",
            "description": "Selects the Microsoft stemming tokenizer for Czech."
          },
          {
            "name": "Danish",
            "value": "danish",
            "description": "Selects the Microsoft stemming tokenizer for Danish."
          },
          {
            "name": "Dutch",
            "value": "dutch",
            "description": "Selects the Microsoft stemming tokenizer for Dutch."
          },
          {
            "name": "English",
            "value": "english",
            "description": "Selects the Microsoft stemming tokenizer for English."
          },
          {
            "name": "Estonian",
            "value": "estonian",
            "description": "Selects the Microsoft stemming tokenizer for Estonian."
          },
          {
            "name": "Finnish",
            "value": "finnish",
            "description": "Selects the Microsoft stemming tokenizer for Finnish."
          },
          {
            "name": "French",
            "value": "french",
            "description": "Selects the Microsoft stemming tokenizer for French."
          },
          {
            "name": "German",
            "value": "german",
            "description": "Selects the Microsoft stemming tokenizer for German."
          },
          {
            "name": "Greek",
            "value": "greek",
            "description": "Selects the Microsoft stemming tokenizer for Greek."
          },
          {
            "name": "Gujarati",
            "value": "gujarati",
            "description": "Selects the Microsoft stemming tokenizer for Gujarati."
          },
          {
            "name": "Hebrew",
            "value": "hebrew",
            "description": "Selects the Microsoft stemming tokenizer for Hebrew."
          },
          {
            "name": "Hindi",
            "value": "hindi",
            "description": "Selects the Microsoft stemming tokenizer for Hindi."
          },
          {
            "name": "Hungarian",
            "value": "hungarian",
            "description": "Selects the Microsoft stemming tokenizer for Hungarian."
          },
          {
            "name": "Icelandic",
            "value": "icelandic",
            "description": "Selects the Microsoft stemming tokenizer for Icelandic."
          },
          {
            "name": "Indonesian",
            "value": "indonesian",
            "description": "Selects the Microsoft stemming tokenizer for Indonesian."
          },
          {
            "name": "Italian",
            "value": "italian",
            "description": "Selects the Microsoft stemming tokenizer for Italian."
          },
          {
            "name": "Kannada",
            "value": "kannada",
            "description": "Selects the Microsoft stemming tokenizer for Kannada."
          },
          {
            "name": "Latvian",
            "value": "latvian",
            "description": "Selects the Microsoft stemming tokenizer for Latvian."
          },
          {
            "name": "Lithuanian",
            "value": "lithuanian",
            "description": "Selects the Microsoft stemming tokenizer for Lithuanian."
          },
          {
            "name": "Malay",
            "value": "malay",
            "description": "Selects the Microsoft stemming tokenizer for Malay."
          },
          {
            "name": "Malayalam",
            "value": "malayalam",
            "description": "Selects the Microsoft stemming tokenizer for Malayalam."
          },
          {
            "name": "Marathi",
            "value": "marathi",
            "description": "Selects the Microsoft stemming tokenizer for Marathi."
          },
          {
            "name": "NorwegianBokmaal",
            "value": "norwegianBokmaal",
            "description": "Selects the Microsoft stemming tokenizer for Norwegian (Bokmål)."
          },
          {
            "name": "Polish",
            "value": "polish",
            "description": "Selects the Microsoft stemming tokenizer for Polish."
          },
          {
            "name": "Portuguese",
            "value": "portuguese",
            "description": "Selects the Microsoft stemming tokenizer for Portuguese."
          },
          {
            "name": "PortugueseBrazilian",
            "value": "portugueseBrazilian",
            "description": "Selects the Microsoft stemming tokenizer for Portuguese (Brazil)."
          },
          {
            "name": "Punjabi",
            "value": "punjabi",
            "description": "Selects the Microsoft stemming tokenizer for Punjabi."
          },
          {
            "name": "Romanian",
            "value": "romanian",
            "description": "Selects the Microsoft stemming tokenizer for Romanian."
          },
          {
            "name": "Russian",
            "value": "russian",
            "description": "Selects the Microsoft stemming tokenizer for Russian."
          },
          {
            "name": "SerbianCyrillic",
            "value": "serbianCyrillic",
            "description": "Selects the Microsoft stemming tokenizer for Serbian (Cyrillic)."
          },
          {
            "name": "SerbianLatin",
            "value": "serbianLatin",
            "description": "Selects the Microsoft stemming tokenizer for Serbian (Latin)."
          },
          {
            "name": "Slovak",
            "value": "slovak",
            "description": "Selects the Microsoft stemming tokenizer for Slovak."
          },
          {
            "name": "Slovenian",
            "value": "slovenian",
            "description": "Selects the Microsoft stemming tokenizer for Slovenian."
          },
          {
            "name": "Spanish",
            "value": "spanish",
            "description": "Selects the Microsoft stemming tokenizer for Spanish."
          },
          {
            "name": "Swedish",
            "value": "swedish",
            "description": "Selects the Microsoft stemming tokenizer for Swedish."
          },
          {
            "name": "Tamil",
            "value": "tamil",
            "description": "Selects the Microsoft stemming tokenizer for Tamil."
          },
          {
            "name": "Telugu",
            "value": "telugu",
            "description": "Selects the Microsoft stemming tokenizer for Telugu."
          },
          {
            "name": "Turkish",
            "value": "turkish",
            "description": "Selects the Microsoft stemming tokenizer for Turkish."
          },
          {
            "name": "Ukrainian",
            "value": "ukrainian",
            "description": "Selects the Microsoft stemming tokenizer for Ukrainian."
          },
          {
            "name": "Urdu",
            "value": "urdu",
            "description": "Selects the Microsoft stemming tokenizer for Urdu."
          }
        ]
      }
    },
    "MicrosoftTokenizerLanguage": {
      "type": "string",
      "description": "Lists the languages supported by the Microsoft language tokenizer.",
      "enum": [
        "bangla",
        "bulgarian",
        "catalan",
        "chineseSimplified",
        "chineseTraditional",
        "croatian",
        "czech",
        "danish",
        "dutch",
        "english",
        "french",
        "german",
        "greek",
        "gujarati",
        "hindi",
        "icelandic",
        "indonesian",
        "italian",
        "japanese",
        "kannada",
        "korean",
        "malay",
        "malayalam",
        "marathi",
        "norwegianBokmaal",
        "polish",
        "portuguese",
        "portugueseBrazilian",
        "punjabi",
        "romanian",
        "russian",
        "serbianCyrillic",
        "serbianLatin",
        "slovenian",
        "spanish",
        "swedish",
        "tamil",
        "telugu",
        "thai",
        "ukrainian",
        "urdu",
        "vietnamese"
      ],
      "x-ms-enum": {
        "name": "MicrosoftTokenizerLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "Bangla",
            "value": "bangla",
            "description": "Selects the Microsoft tokenizer for Bangla."
          },
          {
            "name": "Bulgarian",
            "value": "bulgarian",
            "description": "Selects the Microsoft tokenizer for Bulgarian."
          },
          {
            "name": "Catalan",
            "value": "catalan",
            "description": "Selects the Microsoft tokenizer for Catalan."
          },
          {
            "name": "ChineseSimplified",
            "value": "chineseSimplified",
            "description": "Selects the Microsoft tokenizer for Chinese (Simplified)."
          },
          {
            "name": "ChineseTraditional",
            "value": "chineseTraditional",
            "description": "Selects the Microsoft tokenizer for Chinese (Traditional)."
          },
          {
            "name": "Croatian",
            "value": "croatian",
            "description": "Selects the Microsoft tokenizer for Croatian."
          },
          {
            "name": "Czech",
            "value": "czech",
            "description": "Selects the Microsoft tokenizer for Czech."
          },
          {
            "name": "Danish",
            "value": "danish",
            "description": "Selects the Microsoft tokenizer for Danish."
          },
          {
            "name": "Dutch",
            "value": "dutch",
            "description": "Selects the Microsoft tokenizer for Dutch."
          },
          {
            "name": "English",
            "value": "english",
            "description": "Selects the Microsoft tokenizer for English."
          },
          {
            "name": "French",
            "value": "french",
            "description": "Selects the Microsoft tokenizer for French."
          },
          {
            "name": "German",
            "value": "german",
            "description": "Selects the Microsoft tokenizer for German."
          },
          {
            "name": "Greek",
            "value": "greek",
            "description": "Selects the Microsoft tokenizer for Greek."
          },
          {
            "name": "Gujarati",
            "value": "gujarati",
            "description": "Selects the Microsoft tokenizer for Gujarati."
          },
          {
            "name": "Hindi",
            "value": "hindi",
            "description": "Selects the Microsoft tokenizer for Hindi."
          },
          {
            "name": "Icelandic",
            "value": "icelandic",
            "description": "Selects the Microsoft tokenizer for Icelandic."
          },
          {
            "name": "Indonesian",
            "value": "indonesian",
            "description": "Selects the Microsoft tokenizer for Indonesian."
          },
          {
            "name": "Italian",
            "value": "italian",
            "description": "Selects the Microsoft tokenizer for Italian."
          },
          {
            "name": "Japanese",
            "value": "japanese",
            "description": "Selects the Microsoft tokenizer for Japanese."
          },
          {
            "name": "Kannada",
            "value": "kannada",
            "description": "Selects the Microsoft tokenizer for Kannada."
          },
          {
            "name": "Korean",
            "value": "korean",
            "description": "Selects the Microsoft tokenizer for Korean."
          },
          {
            "name": "Malay",
            "value": "malay",
            "description": "Selects the Microsoft tokenizer for Malay."
          },
          {
            "name": "Malayalam",
            "value": "malayalam",
            "description": "Selects the Microsoft tokenizer for Malayalam."
          },
          {
            "name": "Marathi",
            "value": "marathi",
            "description": "Selects the Microsoft tokenizer for Marathi."
          },
          {
            "name": "NorwegianBokmaal",
            "value": "norwegianBokmaal",
            "description": "Selects the Microsoft tokenizer for Norwegian (Bokmål)."
          },
          {
            "name": "Polish",
            "value": "polish",
            "description": "Selects the Microsoft tokenizer for Polish."
          },
          {
            "name": "Portuguese",
            "value": "portuguese",
            "description": "Selects the Microsoft tokenizer for Portuguese."
          },
          {
            "name": "PortugueseBrazilian",
            "value": "portugueseBrazilian",
            "description": "Selects the Microsoft tokenizer for Portuguese (Brazil)."
          },
          {
            "name": "Punjabi",
            "value": "punjabi",
            "description": "Selects the Microsoft tokenizer for Punjabi."
          },
          {
            "name": "Romanian",
            "value": "romanian",
            "description": "Selects the Microsoft tokenizer for Romanian."
          },
          {
            "name": "Russian",
            "value": "russian",
            "description": "Selects the Microsoft tokenizer for Russian."
          },
          {
            "name": "SerbianCyrillic",
            "value": "serbianCyrillic",
            "description": "Selects the Microsoft tokenizer for Serbian (Cyrillic)."
          },
          {
            "name": "SerbianLatin",
            "value": "serbianLatin",
            "description": "Selects the Microsoft tokenizer for Serbian (Latin)."
          },
          {
            "name": "Slovenian",
            "value": "slovenian",
            "description": "Selects the Microsoft tokenizer for Slovenian."
          },
          {
            "name": "Spanish",
            "value": "spanish",
            "description": "Selects the Microsoft tokenizer for Spanish."
          },
          {
            "name": "Swedish",
            "value": "swedish",
            "description": "Selects the Microsoft tokenizer for Swedish."
          },
          {
            "name": "Tamil",
            "value": "tamil",
            "description": "Selects the Microsoft tokenizer for Tamil."
          },
          {
            "name": "Telugu",
            "value": "telugu",
            "description": "Selects the Microsoft tokenizer for Telugu."
          },
          {
            "name": "Thai",
            "value": "thai",
            "description": "Selects the Microsoft tokenizer for Thai."
          },
          {
            "name": "Ukrainian",
            "value": "ukrainian",
            "description": "Selects the Microsoft tokenizer for Ukrainian."
          },
          {
            "name": "Urdu",
            "value": "urdu",
            "description": "Selects the Microsoft tokenizer for Urdu."
          },
          {
            "name": "Vietnamese",
            "value": "vietnamese",
            "description": "Selects the Microsoft tokenizer for Vietnamese."
          }
        ]
      }
    },
    "NGramTokenFilterV2": {
      "type": "object",
      "description": "Generates n-grams of the given size(s). This token filter is implemented using\nApache Lucene.",
      "properties": {
        "minGram": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the\nvalue of maxGram.",
          "default": 1,
          "maximum": 300
        },
        "maxGram": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum n-gram length. Default is 2. Maximum is 300.",
          "default": 2,
          "maximum": 300
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.NGramTokenFilterV2"
    },
    "NGramTokenizer": {
      "type": "object",
      "description": "Tokenizes the input into n-grams of the given size(s). This tokenizer is\nimplemented using Apache Lucene.",
      "properties": {
        "minGram": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the\nvalue of maxGram.",
          "default": 1,
          "maximum": 300
        },
        "maxGram": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum n-gram length. Default is 2. Maximum is 300.",
          "default": 2,
          "maximum": 300
        },
        "tokenChars": {
          "type": "array",
          "description": "Character classes to keep in the tokens.",
          "items": {
            "$ref": "#/definitions/TokenCharacterKind"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.NGramTokenizer"
    },
    "OcrLineEnding": {
      "type": "string",
      "description": "Defines the sequence of characters to use between the lines of text recognized\nby the OCR skill. The default value is \"space\".",
      "enum": [
        "space",
        "carriageReturn",
        "lineFeed",
        "carriageReturnLineFeed"
      ],
      "x-ms-enum": {
        "name": "OcrLineEnding",
        "modelAsString": true,
        "values": [
          {
            "name": "Space",
            "value": "space",
            "description": "Lines are separated by a single space character."
          },
          {
            "name": "CarriageReturn",
            "value": "carriageReturn",
            "description": "Lines are separated by a carriage return ('\\r') character."
          },
          {
            "name": "LineFeed",
            "value": "lineFeed",
            "description": "Lines are separated by a single line feed ('\\n') character."
          },
          {
            "name": "CarriageReturnLineFeed",
            "value": "carriageReturnLineFeed",
            "description": "Lines are separated by a carriage return and a line feed ('\\r\\n') character."
          }
        ]
      }
    },
    "OcrSkill": {
      "type": "object",
      "description": "A skill that extracts text from image files.",
      "properties": {
        "defaultLanguageCode": {
          "$ref": "#/definitions/OcrSkillLanguage",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "detectOrientation": {
          "type": "boolean",
          "description": "A value indicating to turn orientation detection on or not. Default is false."
        },
        "lineEnding": {
          "$ref": "#/definitions/OcrLineEnding",
          "description": "Defines the sequence of characters to use between the lines of text recognized\nby the OCR skill. The default value is \"space\"."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Vision.OcrSkill"
    },
    "OcrSkillLanguage": {
      "type": "string",
      "description": "The language codes supported for input by OcrSkill.",
      "enum": [
        "af",
        "sq",
        "anp",
        "ar",
        "ast",
        "awa",
        "az",
        "bfy",
        "eu",
        "be",
        "be-cyrl",
        "be-latn",
        "bho",
        "bi",
        "brx",
        "bs",
        "bra",
        "br",
        "bg",
        "bns",
        "bua",
        "ca",
        "ceb",
        "rab",
        "ch",
        "hne",
        "zh-Hans",
        "zh-Hant",
        "kw",
        "co",
        "crh",
        "hr",
        "cs",
        "da",
        "prs",
        "dhi",
        "doi",
        "nl",
        "en",
        "myv",
        "et",
        "fo",
        "fj",
        "fil",
        "fi",
        "fr",
        "fur",
        "gag",
        "gl",
        "de",
        "gil",
        "gon",
        "el",
        "kl",
        "gvr",
        "ht",
        "hlb",
        "hni",
        "bgc",
        "haw",
        "hi",
        "mww",
        "hoc",
        "hu",
        "is",
        "smn",
        "id",
        "ia",
        "iu",
        "ga",
        "it",
        "ja",
        "Jns",
        "jv",
        "kea",
        "kac",
        "xnr",
        "krc",
        "kaa-cyrl",
        "kaa",
        "csb",
        "kk-cyrl",
        "kk-latn",
        "klr",
        "kha",
        "quc",
        "ko",
        "kfq",
        "kpy",
        "kos",
        "kum",
        "ku-arab",
        "ku-latn",
        "kru",
        "ky",
        "lkt",
        "la",
        "lt",
        "dsb",
        "smj",
        "lb",
        "bfz",
        "ms",
        "mt",
        "kmj",
        "gv",
        "mi",
        "mr",
        "mn",
        "cnr-cyrl",
        "cnr-latn",
        "nap",
        "ne",
        "niu",
        "nog",
        "sme",
        "nb",
        "no",
        "oc",
        "os",
        "ps",
        "fa",
        "pl",
        "pt",
        "pa",
        "ksh",
        "ro",
        "rm",
        "ru",
        "sck",
        "sm",
        "sa",
        "sat",
        "sco",
        "gd",
        "sr",
        "sr-Cyrl",
        "sr-Latn",
        "xsr",
        "srx",
        "sms",
        "sk",
        "sl",
        "so",
        "sma",
        "es",
        "sw",
        "sv",
        "tg",
        "tt",
        "tet",
        "thf",
        "to",
        "tr",
        "tk",
        "tyv",
        "hsb",
        "ur",
        "ug",
        "uz-arab",
        "uz-cyrl",
        "uz",
        "vo",
        "wae",
        "cy",
        "fy",
        "yua",
        "za",
        "zu",
        "unk"
      ],
      "x-ms-enum": {
        "name": "OcrSkillLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "af",
            "value": "af",
            "description": "Afrikaans"
          },
          {
            "name": "sq",
            "value": "sq",
            "description": "Albanian"
          },
          {
            "name": "anp",
            "value": "anp",
            "description": "Angika (Devanagiri)"
          },
          {
            "name": "ar",
            "value": "ar",
            "description": "Arabic"
          },
          {
            "name": "ast",
            "value": "ast",
            "description": "Asturian"
          },
          {
            "name": "awa",
            "value": "awa",
            "description": "Awadhi-Hindi (Devanagiri)"
          },
          {
            "name": "az",
            "value": "az",
            "description": "Azerbaijani (Latin)"
          },
          {
            "name": "bfy",
            "value": "bfy",
            "description": "Bagheli"
          },
          {
            "name": "eu",
            "value": "eu",
            "description": "Basque"
          },
          {
            "name": "be",
            "value": "be",
            "description": "Belarusian (Cyrillic and Latin)"
          },
          {
            "name": "be-cyrl",
            "value": "be-cyrl",
            "description": "Belarusian (Cyrillic)"
          },
          {
            "name": "be-latn",
            "value": "be-latn",
            "description": "Belarusian (Latin)"
          },
          {
            "name": "bho",
            "value": "bho",
            "description": "Bhojpuri-Hindi (Devanagiri)"
          },
          {
            "name": "bi",
            "value": "bi",
            "description": "Bislama"
          },
          {
            "name": "brx",
            "value": "brx",
            "description": "Bodo (Devanagiri)"
          },
          {
            "name": "bs",
            "value": "bs",
            "description": "Bosnian Latin"
          },
          {
            "name": "bra",
            "value": "bra",
            "description": "Brajbha"
          },
          {
            "name": "br",
            "value": "br",
            "description": "Breton"
          },
          {
            "name": "bg",
            "value": "bg",
            "description": "Bulgarian"
          },
          {
            "name": "bns",
            "value": "bns",
            "description": "Bundeli"
          },
          {
            "name": "bua",
            "value": "bua",
            "description": "Buryat (Cyrillic)"
          },
          {
            "name": "ca",
            "value": "ca",
            "description": "Catalan"
          },
          {
            "name": "ceb",
            "value": "ceb",
            "description": "Cebuano"
          },
          {
            "name": "rab",
            "value": "rab",
            "description": "Chamling"
          },
          {
            "name": "ch",
            "value": "ch",
            "description": "Chamorro"
          },
          {
            "name": "hne",
            "value": "hne",
            "description": "Chhattisgarhi (Devanagiri)"
          },
          {
            "name": "zh-Hans",
            "value": "zh-Hans",
            "description": "Chinese Simplified"
          },
          {
            "name": "zh-Hant",
            "value": "zh-Hant",
            "description": "Chinese Traditional"
          },
          {
            "name": "kw",
            "value": "kw",
            "description": "Cornish"
          },
          {
            "name": "co",
            "value": "co",
            "description": "Corsican"
          },
          {
            "name": "crh",
            "value": "crh",
            "description": "Crimean Tatar (Latin)"
          },
          {
            "name": "hr",
            "value": "hr",
            "description": "Croatian"
          },
          {
            "name": "cs",
            "value": "cs",
            "description": "Czech"
          },
          {
            "name": "da",
            "value": "da",
            "description": "Danish"
          },
          {
            "name": "prs",
            "value": "prs",
            "description": "Dari"
          },
          {
            "name": "dhi",
            "value": "dhi",
            "description": "Dhimal (Devanagiri)"
          },
          {
            "name": "doi",
            "value": "doi",
            "description": "Dogri (Devanagiri)"
          },
          {
            "name": "nl",
            "value": "nl",
            "description": "Dutch"
          },
          {
            "name": "en",
            "value": "en",
            "description": "English"
          },
          {
            "name": "myv",
            "value": "myv",
            "description": "Erzya (Cyrillic)"
          },
          {
            "name": "et",
            "value": "et",
            "description": "Estonian"
          },
          {
            "name": "fo",
            "value": "fo",
            "description": "Faroese"
          },
          {
            "name": "fj",
            "value": "fj",
            "description": "Fijian"
          },
          {
            "name": "fil",
            "value": "fil",
            "description": "Filipino"
          },
          {
            "name": "fi",
            "value": "fi",
            "description": "Finnish"
          },
          {
            "name": "fr",
            "value": "fr",
            "description": "French"
          },
          {
            "name": "fur",
            "value": "fur",
            "description": "Frulian"
          },
          {
            "name": "gag",
            "value": "gag",
            "description": "Gagauz (Latin)"
          },
          {
            "name": "gl",
            "value": "gl",
            "description": "Galician"
          },
          {
            "name": "de",
            "value": "de",
            "description": "German"
          },
          {
            "name": "gil",
            "value": "gil",
            "description": "Gilbertese"
          },
          {
            "name": "gon",
            "value": "gon",
            "description": "Gondi (Devanagiri)"
          },
          {
            "name": "el",
            "value": "el",
            "description": "Greek"
          },
          {
            "name": "kl",
            "value": "kl",
            "description": "Greenlandic"
          },
          {
            "name": "gvr",
            "value": "gvr",
            "description": "Gurung (Devanagiri)"
          },
          {
            "name": "ht",
            "value": "ht",
            "description": "Haitian Creole"
          },
          {
            "name": "hlb",
            "value": "hlb",
            "description": "Halbi (Devanagiri)"
          },
          {
            "name": "hni",
            "value": "hni",
            "description": "Hani"
          },
          {
            "name": "bgc",
            "value": "bgc",
            "description": "Haryanvi"
          },
          {
            "name": "haw",
            "value": "haw",
            "description": "Hawaiian"
          },
          {
            "name": "hi",
            "value": "hi",
            "description": "Hindi"
          },
          {
            "name": "mww",
            "value": "mww",
            "description": "Hmong Daw (Latin)"
          },
          {
            "name": "hoc",
            "value": "hoc",
            "description": "Ho (Devanagiri)"
          },
          {
            "name": "hu",
            "value": "hu",
            "description": "Hungarian"
          },
          {
            "name": "is",
            "value": "is",
            "description": "Icelandic"
          },
          {
            "name": "smn",
            "value": "smn",
            "description": "Inari Sami"
          },
          {
            "name": "id",
            "value": "id",
            "description": "Indonesian"
          },
          {
            "name": "ia",
            "value": "ia",
            "description": "Interlingua"
          },
          {
            "name": "iu",
            "value": "iu",
            "description": "Inuktitut (Latin)"
          },
          {
            "name": "ga",
            "value": "ga",
            "description": "Irish"
          },
          {
            "name": "it",
            "value": "it",
            "description": "Italian"
          },
          {
            "name": "ja",
            "value": "ja",
            "description": "Japanese"
          },
          {
            "name": "Jns",
            "value": "Jns",
            "description": "Jaunsari (Devanagiri)"
          },
          {
            "name": "jv",
            "value": "jv",
            "description": "Javanese"
          },
          {
            "name": "kea",
            "value": "kea",
            "description": "Kabuverdianu"
          },
          {
            "name": "kac",
            "value": "kac",
            "description": "Kachin (Latin)"
          },
          {
            "name": "xnr",
            "value": "xnr",
            "description": "Kangri (Devanagiri)"
          },
          {
            "name": "krc",
            "value": "krc",
            "description": "Karachay-Balkar"
          },
          {
            "name": "kaa-cyrl",
            "value": "kaa-cyrl",
            "description": "Kara-Kalpak (Cyrillic)"
          },
          {
            "name": "kaa",
            "value": "kaa",
            "description": "Kara-Kalpak (Latin)"
          },
          {
            "name": "csb",
            "value": "csb",
            "description": "Kashubian"
          },
          {
            "name": "kk-cyrl",
            "value": "kk-cyrl",
            "description": "Kazakh (Cyrillic)"
          },
          {
            "name": "kk-latn",
            "value": "kk-latn",
            "description": "Kazakh (Latin)"
          },
          {
            "name": "klr",
            "value": "klr",
            "description": "Khaling"
          },
          {
            "name": "kha",
            "value": "kha",
            "description": "Khasi"
          },
          {
            "name": "quc",
            "value": "quc",
            "description": "K'iche'"
          },
          {
            "name": "ko",
            "value": "ko",
            "description": "Korean"
          },
          {
            "name": "kfq",
            "value": "kfq",
            "description": "Korku"
          },
          {
            "name": "kpy",
            "value": "kpy",
            "description": "Koryak"
          },
          {
            "name": "kos",
            "value": "kos",
            "description": "Kosraean"
          },
          {
            "name": "kum",
            "value": "kum",
            "description": "Kumyk (Cyrillic)"
          },
          {
            "name": "ku-arab",
            "value": "ku-arab",
            "description": "Kurdish (Arabic)"
          },
          {
            "name": "ku-latn",
            "value": "ku-latn",
            "description": "Kurdish (Latin)"
          },
          {
            "name": "kru",
            "value": "kru",
            "description": "Kurukh (Devanagiri)"
          },
          {
            "name": "ky",
            "value": "ky",
            "description": "Kyrgyz (Cyrillic)"
          },
          {
            "name": "lkt",
            "value": "lkt",
            "description": "Lakota"
          },
          {
            "name": "la",
            "value": "la",
            "description": "Latin"
          },
          {
            "name": "lt",
            "value": "lt",
            "description": "Lithuanian"
          },
          {
            "name": "dsb",
            "value": "dsb",
            "description": "Lower Sorbian"
          },
          {
            "name": "smj",
            "value": "smj",
            "description": "Lule Sami"
          },
          {
            "name": "lb",
            "value": "lb",
            "description": "Luxembourgish"
          },
          {
            "name": "bfz",
            "value": "bfz",
            "description": "Mahasu Pahari (Devanagiri)"
          },
          {
            "name": "ms",
            "value": "ms",
            "description": "Malay (Latin)"
          },
          {
            "name": "mt",
            "value": "mt",
            "description": "Maltese"
          },
          {
            "name": "kmj",
            "value": "kmj",
            "description": "Malto (Devanagiri)"
          },
          {
            "name": "gv",
            "value": "gv",
            "description": "Manx"
          },
          {
            "name": "mi",
            "value": "mi",
            "description": "Maori"
          },
          {
            "name": "mr",
            "value": "mr",
            "description": "Marathi"
          },
          {
            "name": "mn",
            "value": "mn",
            "description": "Mongolian (Cyrillic)"
          },
          {
            "name": "cnr-cyrl",
            "value": "cnr-cyrl",
            "description": "Montenegrin (Cyrillic)"
          },
          {
            "name": "cnr-latn",
            "value": "cnr-latn",
            "description": "Montenegrin (Latin)"
          },
          {
            "name": "nap",
            "value": "nap",
            "description": "Neapolitan"
          },
          {
            "name": "ne",
            "value": "ne",
            "description": "Nepali"
          },
          {
            "name": "niu",
            "value": "niu",
            "description": "Niuean"
          },
          {
            "name": "nog",
            "value": "nog",
            "description": "Nogay"
          },
          {
            "name": "sme",
            "value": "sme",
            "description": "Northern Sami (Latin)"
          },
          {
            "name": "nb",
            "value": "nb",
            "description": "Norwegian"
          },
          {
            "name": "no",
            "value": "no",
            "description": "Norwegian"
          },
          {
            "name": "oc",
            "value": "oc",
            "description": "Occitan"
          },
          {
            "name": "os",
            "value": "os",
            "description": "Ossetic"
          },
          {
            "name": "ps",
            "value": "ps",
            "description": "Pashto"
          },
          {
            "name": "fa",
            "value": "fa",
            "description": "Persian"
          },
          {
            "name": "pl",
            "value": "pl",
            "description": "Polish"
          },
          {
            "name": "pt",
            "value": "pt",
            "description": "Portuguese"
          },
          {
            "name": "pa",
            "value": "pa",
            "description": "Punjabi (Arabic)"
          },
          {
            "name": "ksh",
            "value": "ksh",
            "description": "Ripuarian"
          },
          {
            "name": "ro",
            "value": "ro",
            "description": "Romanian"
          },
          {
            "name": "rm",
            "value": "rm",
            "description": "Romansh"
          },
          {
            "name": "ru",
            "value": "ru",
            "description": "Russian"
          },
          {
            "name": "sck",
            "value": "sck",
            "description": "Sadri (Devanagiri)"
          },
          {
            "name": "sm",
            "value": "sm",
            "description": "Samoan (Latin)"
          },
          {
            "name": "sa",
            "value": "sa",
            "description": "Sanskrit (Devanagiri)"
          },
          {
            "name": "sat",
            "value": "sat",
            "description": "Santali (Devanagiri)"
          },
          {
            "name": "sco",
            "value": "sco",
            "description": "Scots"
          },
          {
            "name": "gd",
            "value": "gd",
            "description": "Scottish Gaelic"
          },
          {
            "name": "sr",
            "value": "sr",
            "description": "Serbian (Latin)"
          },
          {
            "name": "sr-Cyrl",
            "value": "sr-Cyrl",
            "description": "Serbian (Cyrillic)"
          },
          {
            "name": "sr-Latn",
            "value": "sr-Latn",
            "description": "Serbian (Latin)"
          },
          {
            "name": "xsr",
            "value": "xsr",
            "description": "Sherpa (Devanagiri)"
          },
          {
            "name": "srx",
            "value": "srx",
            "description": "Sirmauri (Devanagiri)"
          },
          {
            "name": "sms",
            "value": "sms",
            "description": "Skolt Sami"
          },
          {
            "name": "sk",
            "value": "sk",
            "description": "Slovak"
          },
          {
            "name": "sl",
            "value": "sl",
            "description": "Slovenian"
          },
          {
            "name": "so",
            "value": "so",
            "description": "Somali (Arabic)"
          },
          {
            "name": "sma",
            "value": "sma",
            "description": "Southern Sami"
          },
          {
            "name": "es",
            "value": "es",
            "description": "Spanish"
          },
          {
            "name": "sw",
            "value": "sw",
            "description": "Swahili (Latin)"
          },
          {
            "name": "sv",
            "value": "sv",
            "description": "Swedish"
          },
          {
            "name": "tg",
            "value": "tg",
            "description": "Tajik (Cyrillic)"
          },
          {
            "name": "tt",
            "value": "tt",
            "description": "Tatar (Latin)"
          },
          {
            "name": "tet",
            "value": "tet",
            "description": "Tetum"
          },
          {
            "name": "thf",
            "value": "thf",
            "description": "Thangmi"
          },
          {
            "name": "to",
            "value": "to",
            "description": "Tongan"
          },
          {
            "name": "tr",
            "value": "tr",
            "description": "Turkish"
          },
          {
            "name": "tk",
            "value": "tk",
            "description": "Turkmen (Latin)"
          },
          {
            "name": "tyv",
            "value": "tyv",
            "description": "Tuvan"
          },
          {
            "name": "hsb",
            "value": "hsb",
            "description": "Upper Sorbian"
          },
          {
            "name": "ur",
            "value": "ur",
            "description": "Urdu"
          },
          {
            "name": "ug",
            "value": "ug",
            "description": "Uyghur (Arabic)"
          },
          {
            "name": "uz-arab",
            "value": "uz-arab",
            "description": "Uzbek (Arabic)"
          },
          {
            "name": "uz-cyrl",
            "value": "uz-cyrl",
            "description": "Uzbek (Cyrillic)"
          },
          {
            "name": "uz",
            "value": "uz",
            "description": "Uzbek (Latin)"
          },
          {
            "name": "vo",
            "value": "vo",
            "description": "Volapük"
          },
          {
            "name": "wae",
            "value": "wae",
            "description": "Walser"
          },
          {
            "name": "cy",
            "value": "cy",
            "description": "Welsh"
          },
          {
            "name": "fy",
            "value": "fy",
            "description": "Western Frisian"
          },
          {
            "name": "yua",
            "value": "yua",
            "description": "Yucatec Maya"
          },
          {
            "name": "za",
            "value": "za",
            "description": "Zhuang"
          },
          {
            "name": "zu",
            "value": "zu",
            "description": "Zulu"
          },
          {
            "name": "unk",
            "value": "unk",
            "description": "Unknown (All)"
          }
        ]
      }
    },
    "OutputFieldMappingEntry": {
      "type": "object",
      "description": "Output field mapping for a skill.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the output defined by the skill."
        },
        "targetName": {
          "type": "string",
          "description": "The target name of the output. It is optional and default to name."
        }
      },
      "required": [
        "name"
      ]
    },
    "PIIDetectionSkill": {
      "type": "object",
      "description": "Using the Text Analytics API, extracts personal information from an input text\nand gives you the option of masking it.",
      "properties": {
        "defaultLanguageCode": {
          "type": "string",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "minimumPrecision": {
          "type": "number",
          "format": "double",
          "description": "A value between 0 and 1 that be used to only include entities whose confidence\nscore is greater than the value specified. If not set (default), or if\nexplicitly set to null, all entities will be included.",
          "maximum": 1
        },
        "maskingMode": {
          "$ref": "#/definitions/PIIDetectionSkillMaskingMode",
          "description": "A parameter that provides various ways to mask the personal information\ndetected in the input text. Default is 'none'."
        },
        "maskingCharacter": {
          "type": "string",
          "description": "The character used to mask the text if the maskingMode parameter is set to\nreplace. Default is '*'.",
          "maxLength": 1
        },
        "modelVersion": {
          "type": "string",
          "description": "The version of the model to use when calling the Text Analytics service. It\nwill default to the latest available when not specified. We recommend you do\nnot specify this value unless absolutely necessary."
        },
        "piiCategories": {
          "type": "array",
          "description": "A list of PII entity categories that should be extracted and masked.",
          "items": {
            "type": "string"
          }
        },
        "domain": {
          "type": "string",
          "description": "If specified, will set the PII domain to include only a subset of the entity\ncategories. Possible values include: 'phi', 'none'. Default is 'none'."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.PIIDetectionSkill"
    },
    "PIIDetectionSkillMaskingMode": {
      "type": "string",
      "description": "A string indicating what maskingMode to use to mask the personal information\ndetected in the input text.",
      "enum": [
        "none",
        "replace"
      ],
      "x-ms-enum": {
        "name": "PIIDetectionSkillMaskingMode",
        "modelAsString": true,
        "values": [
          {
            "name": "None",
            "value": "none",
            "description": "No masking occurs and the maskedText output will not be returned."
          },
          {
            "name": "Replace",
            "value": "replace",
            "description": "Replaces the detected entities with the character given in the maskingCharacter\nparameter. The character will be repeated to the length of the detected entity\nso that the offsets will correctly correspond to both the input text as well as\nthe output maskedText."
          }
        ]
      }
    },
    "PathHierarchyTokenizerV2": {
      "type": "object",
      "description": "Tokenizer for path-like hierarchies. This tokenizer is implemented using Apache\nLucene.",
      "properties": {
        "delimiter": {
          "type": "string",
          "description": "The delimiter character to use. Default is \"/\".",
          "default": "/"
        },
        "replacement": {
          "type": "string",
          "description": "A value that, if set, replaces the delimiter character. Default is \"/\".",
          "default": "/"
        },
        "maxTokenLength": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum token length. Default and maximum is 300.",
          "default": 300,
          "maximum": 300
        },
        "reverse": {
          "type": "boolean",
          "description": "A value indicating whether to generate tokens in reverse order. Default is\nfalse."
        },
        "skip": {
          "type": "integer",
          "format": "int32",
          "description": "The number of initial tokens to skip. Default is 0."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.PathHierarchyTokenizerV2"
    },
    "PatternAnalyzer": {
      "type": "object",
      "description": "Flexibly separates text into terms via a regular expression pattern. This\nanalyzer is implemented using Apache Lucene.",
      "properties": {
        "lowercase": {
          "type": "boolean",
          "description": "A value indicating whether terms should be lower-cased. Default is true.",
          "default": true
        },
        "pattern": {
          "type": "string",
          "description": "A regular expression pattern to match token separators. Default is an\nexpression that matches one or more non-word characters.",
          "default": "\\W+"
        },
        "flags": {
          "$ref": "#/definitions/RegexFlags",
          "description": "Regular expression flags."
        },
        "stopwords": {
          "type": "array",
          "description": "A list of stopwords.",
          "items": {
            "type": "string"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalAnalyzer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.PatternAnalyzer"
    },
    "PatternCaptureTokenFilter": {
      "type": "object",
      "description": "Uses Java regexes to emit multiple tokens - one for each capture group in one\nor more patterns. This token filter is implemented using Apache Lucene.",
      "properties": {
        "patterns": {
          "type": "array",
          "description": "A list of patterns to match against each token.",
          "items": {
            "type": "string"
          }
        },
        "preserveOriginal": {
          "type": "boolean",
          "description": "A value indicating whether to return the original token even if one of the\npatterns matches. Default is true.",
          "default": true
        }
      },
      "required": [
        "patterns"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.PatternCaptureTokenFilter"
    },
    "PatternReplaceCharFilter": {
      "type": "object",
      "description": "A character filter that replaces characters in the input string. It uses a\nregular expression to identify character sequences to preserve and a\nreplacement pattern to identify characters to replace. For example, given the\ninput text \"aa bb aa bb\", pattern \"(aa)\\s+(bb)\", and replacement \"$1#$2\", the\nresult would be \"aa#bb aa#bb\". This character filter is implemented using\nApache Lucene.",
      "properties": {
        "pattern": {
          "type": "string",
          "description": "A regular expression pattern."
        },
        "replacement": {
          "type": "string",
          "description": "The replacement text."
        }
      },
      "required": [
        "pattern",
        "replacement"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/CharFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.PatternReplaceCharFilter"
    },
    "PatternReplaceTokenFilter": {
      "type": "object",
      "description": "A character filter that replaces characters in the input string. It uses a\nregular expression to identify character sequences to preserve and a\nreplacement pattern to identify characters to replace. For example, given the\ninput text \"aa bb aa bb\", pattern \"(aa)\\s+(bb)\", and replacement \"$1#$2\", the\nresult would be \"aa#bb aa#bb\". This token filter is implemented using Apache\nLucene.",
      "properties": {
        "pattern": {
          "type": "string",
          "description": "A regular expression pattern."
        },
        "replacement": {
          "type": "string",
          "description": "The replacement text."
        }
      },
      "required": [
        "pattern",
        "replacement"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.PatternReplaceTokenFilter"
    },
    "PatternTokenizer": {
      "type": "object",
      "description": "Tokenizer that uses regex pattern matching to construct distinct tokens. This\ntokenizer is implemented using Apache Lucene.",
      "properties": {
        "pattern": {
          "type": "string",
          "description": "A regular expression pattern to match token separators. Default is an\nexpression that matches one or more non-word characters.",
          "default": "\\W+"
        },
        "flags": {
          "$ref": "#/definitions/RegexFlags",
          "description": "Regular expression flags."
        },
        "group": {
          "type": "integer",
          "format": "int32",
          "description": "The zero-based ordinal of the matching group in the regular expression pattern\nto extract into tokens. Use -1 if you want to use the entire pattern to split\nthe input into tokens, irrespective of matching groups. Default is -1.",
          "default": -1
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.PatternTokenizer"
    },
    "PhoneticEncoder": {
      "type": "string",
      "description": "Identifies the type of phonetic encoder to use with a PhoneticTokenFilter.",
      "enum": [
        "metaphone",
        "doubleMetaphone",
        "soundex",
        "refinedSoundex",
        "caverphone1",
        "caverphone2",
        "cologne",
        "nysiis",
        "koelnerPhonetik",
        "haasePhonetik",
        "beiderMorse"
      ],
      "x-ms-enum": {
        "name": "PhoneticEncoder",
        "modelAsString": true,
        "values": [
          {
            "name": "Metaphone",
            "value": "metaphone",
            "description": "Encodes a token into a Metaphone value."
          },
          {
            "name": "DoubleMetaphone",
            "value": "doubleMetaphone",
            "description": "Encodes a token into a double metaphone value."
          },
          {
            "name": "Soundex",
            "value": "soundex",
            "description": "Encodes a token into a Soundex value."
          },
          {
            "name": "RefinedSoundex",
            "value": "refinedSoundex",
            "description": "Encodes a token into a Refined Soundex value."
          },
          {
            "name": "Caverphone1",
            "value": "caverphone1",
            "description": "Encodes a token into a Caverphone 1.0 value."
          },
          {
            "name": "Caverphone2",
            "value": "caverphone2",
            "description": "Encodes a token into a Caverphone 2.0 value."
          },
          {
            "name": "Cologne",
            "value": "cologne",
            "description": "Encodes a token into a Cologne Phonetic value."
          },
          {
            "name": "Nysiis",
            "value": "nysiis",
            "description": "Encodes a token into a NYSIIS value."
          },
          {
            "name": "KoelnerPhonetik",
            "value": "koelnerPhonetik",
            "description": "Encodes a token using the Kölner Phonetik algorithm."
          },
          {
            "name": "HaasePhonetik",
            "value": "haasePhonetik",
            "description": "Encodes a token using the Haase refinement of the Kölner Phonetik algorithm."
          },
          {
            "name": "BeiderMorse",
            "value": "beiderMorse",
            "description": "Encodes a token into a Beider-Morse value."
          }
        ]
      }
    },
    "PhoneticTokenFilter": {
      "type": "object",
      "description": "Create tokens for phonetic matches. This token filter is implemented using\nApache Lucene.",
      "properties": {
        "encoder": {
          "$ref": "#/definitions/PhoneticEncoder",
          "description": "The phonetic encoder to use. Default is \"metaphone\"."
        },
        "replace": {
          "type": "boolean",
          "description": "A value indicating whether encoded tokens should replace original tokens. If\nfalse, encoded tokens are added as synonyms. Default is true.",
          "default": true
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.PhoneticTokenFilter"
    },
    "QueryAnswerResult": {
      "type": "object",
      "description": "An answer is a text passage extracted from the contents of the most relevant\ndocuments that matched the query. Answers are extracted from the top search\nresults. Answer candidates are scored and the top answers are selected.",
      "properties": {
        "score": {
          "type": "number",
          "format": "double",
          "description": "The score value represents how relevant the answer is to the query relative to\nother answers returned for the query."
        },
        "key": {
          "type": "string",
          "description": "The key of the document the answer was extracted from."
        },
        "text": {
          "type": "string",
          "description": "The text passage extracted from the document contents as the answer."
        },
        "highlights": {
          "type": "string",
          "description": "Same text passage as in the Text property with highlighted text phrases most\nrelevant to the query."
        }
      },
      "additionalProperties": {}
    },
    "QueryAnswerType": {
      "type": "string",
      "description": "This parameter is only valid if the query type is `semantic`. If set, the query\nreturns answers extracted from key passages in the highest ranked documents.\nThe number of answers returned can be configured by appending the pipe\ncharacter `|` followed by the `count-<number of answers>` option after the\nanswers parameter value, such as `extractive|count-3`. Default count is 1. The\nconfidence threshold can be configured by appending the pipe character `|`\nfollowed by the `threshold-<confidence threshold>` option after the answers\nparameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.",
      "enum": [
        "none",
        "extractive"
      ],
      "x-ms-enum": {
        "name": "QueryAnswerType",
        "modelAsString": true,
        "values": [
          {
            "name": "None",
            "value": "none",
            "description": "Do not return answers for the query."
          },
          {
            "name": "Extractive",
            "value": "extractive",
            "description": "Extracts answer candidates from the contents of the documents returned in\nresponse to a query expressed as a question in natural language."
          }
        ]
      }
    },
    "QueryCaptionResult": {
      "type": "object",
      "description": "Captions are the most representative passages from the document relatively to\nthe search query. They are often used as document summary. Captions are only\nreturned for queries of type `semantic`.",
      "properties": {
        "text": {
          "type": "string",
          "description": "A representative text passage extracted from the document most relevant to the\nsearch query."
        },
        "highlights": {
          "type": "string",
          "description": "Same text passage as in the Text property with highlighted phrases most\nrelevant to the query."
        }
      },
      "additionalProperties": {}
    },
    "QueryCaptionType": {
      "type": "string",
      "description": "This parameter is only valid if the query type is `semantic`. If set, the query\nreturns captions extracted from key passages in the highest ranked documents.\nWhen Captions is set to `extractive`, highlighting is enabled by default, and\ncan be configured by appending the pipe character `|` followed by the\n`highlight-<true/false>` option, such as `extractive|highlight-true`. Defaults\nto `None`.",
      "enum": [
        "none",
        "extractive"
      ],
      "x-ms-enum": {
        "name": "QueryCaptionType",
        "modelAsString": true,
        "values": [
          {
            "name": "None",
            "value": "none",
            "description": "Do not return captions for the query."
          },
          {
            "name": "Extractive",
            "value": "extractive",
            "description": "Extracts captions from the matching documents that contain passages relevant to\nthe search query."
          }
        ]
      }
    },
    "QueryType": {
      "type": "string",
      "description": "Specifies the syntax of the search query. The default is 'simple'. Use 'full'\nif your query uses the Lucene query syntax.",
      "enum": [
        "simple",
        "full",
        "semantic"
      ],
      "x-ms-enum": {
        "name": "QueryType",
        "modelAsString": true,
        "values": [
          {
            "name": "Simple",
            "value": "simple",
            "description": "Uses the simple query syntax for searches. Search text is interpreted using a\nsimple query language that allows for symbols such as +, * and \"\". Queries are\nevaluated across all searchable fields by default, unless the searchFields\nparameter is specified."
          },
          {
            "name": "Full",
            "value": "full",
            "description": "Uses the full Lucene query syntax for searches. Search text is interpreted\nusing the Lucene query language which allows field-specific and weighted\nsearches, as well as other advanced features."
          },
          {
            "name": "Semantic",
            "value": "semantic",
            "description": "Best suited for queries expressed in natural language as opposed to keywords.\nImproves precision of search results by re-ranking the top search results using\na ranking model trained on the Web corpus."
          }
        ]
      }
    },
    "RegexFlags": {
      "type": "string",
      "description": "Defines flags that can be combined to control how regular expressions are used\nin the pattern analyzer and pattern tokenizer.",
      "enum": [
        "CANON_EQ",
        "CASE_INSENSITIVE",
        "COMMENTS",
        "DOTALL",
        "LITERAL",
        "MULTILINE",
        "UNICODE_CASE",
        "UNIX_LINES"
      ],
      "x-ms-enum": {
        "name": "RegexFlags",
        "modelAsString": true,
        "values": [
          {
            "name": "CanonEq",
            "value": "CANON_EQ",
            "description": "Enables canonical equivalence."
          },
          {
            "name": "CaseInsensitive",
            "value": "CASE_INSENSITIVE",
            "description": "Enables case-insensitive matching."
          },
          {
            "name": "Comments",
            "value": "COMMENTS",
            "description": "Permits whitespace and comments in the pattern."
          },
          {
            "name": "DotAll",
            "value": "DOTALL",
            "description": "Enables dotall mode."
          },
          {
            "name": "Literal",
            "value": "LITERAL",
            "description": "Enables literal parsing of the pattern."
          },
          {
            "name": "Multiline",
            "value": "MULTILINE",
            "description": "Enables multiline mode."
          },
          {
            "name": "UnicodeCase",
            "value": "UNICODE_CASE",
            "description": "Enables Unicode-aware case folding."
          },
          {
            "name": "UnixLines",
            "value": "UNIX_LINES",
            "description": "Enables Unix lines mode."
          }
        ]
      }
    },
    "ResourceCounter": {
      "type": "object",
      "description": "Represents a resource's usage and quota.",
      "properties": {
        "usage": {
          "type": "integer",
          "format": "int64",
          "description": "The resource usage amount."
        },
        "quota": {
          "type": "integer",
          "format": "int64",
          "description": "The resource amount quota."
        }
      },
      "required": [
        "usage"
      ]
    },
    "ScalarQuantizationCompression": {
      "type": "object",
      "description": "Contains configuration options specific to the scalar quantization compression\nmethod used during indexing and querying.",
      "properties": {
        "scalarQuantizationParameters": {
          "$ref": "#/definitions/ScalarQuantizationParameters",
          "description": "Contains the parameters specific to Scalar Quantization."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/VectorSearchCompression"
        }
      ],
      "x-ms-discriminator-value": "scalarQuantization"
    },
    "ScalarQuantizationParameters": {
      "type": "object",
      "description": "Contains the parameters specific to Scalar Quantization.",
      "properties": {
        "quantizedDataType": {
          "$ref": "#/definitions/VectorSearchCompressionTarget",
          "description": "The quantized data type of compressed vector values."
        }
      }
    },
    "ScoringFunction": {
      "type": "object",
      "description": "Base type for functions that can modify document scores during ranking.",
      "properties": {
        "fieldName": {
          "type": "string",
          "description": "The name of the field used as input to the scoring function."
        },
        "boost": {
          "type": "number",
          "format": "double",
          "description": "A multiplier for the raw score. Must be a positive number not equal to 1.0."
        },
        "interpolation": {
          "$ref": "#/definitions/ScoringFunctionInterpolation",
          "description": "A value indicating how boosting will be interpolated across document scores;\ndefaults to \"Linear\"."
        },
        "type": {
          "type": "string",
          "description": "Type of ScoringFunction."
        }
      },
      "discriminator": "type",
      "required": [
        "fieldName",
        "boost",
        "type"
      ]
    },
    "ScoringFunctionAggregation": {
      "type": "string",
      "description": "Defines the aggregation function used to combine the results of all the scoring\nfunctions in a scoring profile.",
      "enum": [
        "sum",
        "average",
        "minimum",
        "maximum",
        "firstMatching"
      ],
      "x-ms-enum": {
        "name": "ScoringFunctionAggregation",
        "modelAsString": true,
        "values": [
          {
            "name": "Sum",
            "value": "sum",
            "description": "Boost scores by the sum of all scoring function results."
          },
          {
            "name": "Average",
            "value": "average",
            "description": "Boost scores by the average of all scoring function results."
          },
          {
            "name": "Minimum",
            "value": "minimum",
            "description": "Boost scores by the minimum of all scoring function results."
          },
          {
            "name": "Maximum",
            "value": "maximum",
            "description": "Boost scores by the maximum of all scoring function results."
          },
          {
            "name": "FirstMatching",
            "value": "firstMatching",
            "description": "Boost scores using the first applicable scoring function in the scoring profile."
          }
        ]
      }
    },
    "ScoringFunctionInterpolation": {
      "type": "string",
      "description": "Defines the function used to interpolate score boosting across a range of\ndocuments.",
      "enum": [
        "linear",
        "constant",
        "quadratic",
        "logarithmic"
      ],
      "x-ms-enum": {
        "name": "ScoringFunctionInterpolation",
        "modelAsString": true,
        "values": [
          {
            "name": "Linear",
            "value": "linear",
            "description": "Boosts scores by a linearly decreasing amount. This is the default\ninterpolation for scoring functions."
          },
          {
            "name": "Constant",
            "value": "constant",
            "description": "Boosts scores by a constant factor."
          },
          {
            "name": "Quadratic",
            "value": "quadratic",
            "description": "Boosts scores by an amount that decreases quadratically. Boosts decrease slowly\nfor higher scores, and more quickly as the scores decrease. This interpolation\noption is not allowed in tag scoring functions."
          },
          {
            "name": "Logarithmic",
            "value": "logarithmic",
            "description": "Boosts scores by an amount that decreases logarithmically. Boosts decrease\nquickly for higher scores, and more slowly as the scores decrease. This\ninterpolation option is not allowed in tag scoring functions."
          }
        ]
      }
    },
    "ScoringProfile": {
      "type": "object",
      "description": "Defines parameters for a search index that influence scoring in search queries.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the scoring profile."
        },
        "text": {
          "$ref": "#/definitions/TextWeights",
          "description": "Parameters that boost scoring based on text matches in certain index fields."
        },
        "functions": {
          "type": "array",
          "description": "The collection of functions that influence the scoring of documents.",
          "items": {
            "$ref": "#/definitions/ScoringFunction"
          },
          "x-ms-identifiers": []
        },
        "functionAggregation": {
          "$ref": "#/definitions/ScoringFunctionAggregation",
          "description": "A value indicating how the results of individual scoring functions should be\ncombined. Defaults to \"Sum\". Ignored if there are no scoring functions."
        }
      },
      "required": [
        "name"
      ]
    },
    "ScoringStatistics": {
      "type": "string",
      "description": "A value that specifies whether we want to calculate scoring statistics (such as\ndocument frequency) globally for more consistent scoring, or locally, for lower\nlatency. The default is 'local'. Use 'global' to aggregate scoring statistics\nglobally before scoring. Using global scoring statistics can increase latency\nof search queries.",
      "enum": [
        "local",
        "global"
      ],
      "x-ms-enum": {
        "name": "ScoringStatistics",
        "modelAsString": true,
        "values": [
          {
            "name": "Local",
            "value": "local",
            "description": "The scoring statistics will be calculated locally for lower latency."
          },
          {
            "name": "Global",
            "value": "global",
            "description": "The scoring statistics will be calculated globally for more consistent scoring."
          }
        ]
      }
    },
    "SearchDocumentsResult": {
      "type": "object",
      "description": "Response containing search results from an index.",
      "properties": {
        "@odata.count": {
          "type": "integer",
          "format": "int64",
          "description": "The total count of results found by the search operation, or null if the count\nwas not requested. If present, the count may be greater than the number of\nresults in this response. This can happen if you use the $top or $skip\nparameters, or if the query can't return all the requested documents in a\nsingle response.",
          "x-ms-client-name": "count"
        },
        "@search.coverage": {
          "type": "number",
          "format": "double",
          "description": "A value indicating the percentage of the index that was included in the query,\nor null if minimumCoverage was not specified in the request.",
          "x-ms-client-name": "coverage"
        },
        "@search.facets": {
          "type": "object",
          "description": "The facet query results for the search operation, organized as a collection of\nbuckets for each faceted field; null if the query did not include any facet\nexpressions.",
          "additionalProperties": {
            "items": {
              "$ref": "#/definitions/FacetResult"
            },
            "type": "array",
            "x-ms-identifiers": []
          },
          "x-ms-client-name": "facets"
        },
        "@search.answers": {
          "type": "array",
          "description": "The answers query results for the search operation; null if the answers query\nparameter was not specified or set to 'none'.",
          "items": {
            "$ref": "#/definitions/QueryAnswerResult"
          },
          "x-ms-client-name": "answers",
          "x-ms-identifiers": []
        },
        "@search.nextPageParameters": {
          "$ref": "#/definitions/SearchRequest",
          "description": "Continuation JSON payload returned when the query can't return all the\nrequested results in a single response. You can use this JSON along with",
          "x-ms-client-name": "nextPageParameters"
        },
        "value": {
          "type": "array",
          "description": "The sequence of results returned by the query.",
          "items": {
            "$ref": "#/definitions/SearchResult"
          },
          "x-ms-identifiers": []
        },
        "@odata.nextLink": {
          "type": "string",
          "description": "Continuation URL returned when the query can't return all the requested results\nin a single response. You can use this URL to formulate another GET or POST\nSearch request to get the next part of the search response. Make sure to use\nthe same verb (GET or POST) as the request that produced this response.",
          "x-ms-client-name": "nextLink"
        },
        "@search.semanticPartialResponseReason": {
          "$ref": "#/definitions/SemanticErrorReason",
          "description": "Reason that a partial response was returned for a semantic ranking request.",
          "x-ms-client-name": "semanticPartialResponseReason"
        },
        "@search.semanticPartialResponseType": {
          "$ref": "#/definitions/SemanticSearchResultsType",
          "description": "Type of partial response that was returned for a semantic ranking request.",
          "x-ms-client-name": "semanticPartialResponseType"
        }
      },
      "required": [
        "value"
      ]
    },
    "SearchField": {
      "type": "object",
      "description": "Represents a field in an index definition, which describes the name, data type,\nand search behavior of a field.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the field, which must be unique within the fields collection of the\nindex or parent field."
        },
        "type": {
          "$ref": "#/definitions/SearchFieldDataType",
          "description": "The data type of the field."
        },
        "key": {
          "type": "boolean",
          "description": "A value indicating whether the field uniquely identifies documents in the\nindex. Exactly one top-level field in each index must be chosen as the key\nfield and it must be of type Edm.String. Key fields can be used to look up\ndocuments directly and update or delete specific documents. Default is false\nfor simple fields and null for complex fields."
        },
        "retrievable": {
          "type": "boolean",
          "description": "A value indicating whether the field can be returned in a search result. You\ncan disable this option if you want to use a field (for example, margin) as a\nfilter, sorting, or scoring mechanism but do not want the field to be visible\nto the end user. This property must be true for key fields, and it must be null\nfor complex fields. This property can be changed on existing fields. Enabling\nthis property does not cause any increase in index storage requirements.\nDefault is true for simple fields, false for vector fields, and null for\ncomplex fields."
        },
        "stored": {
          "type": "boolean",
          "description": "An immutable value indicating whether the field will be persisted separately on\ndisk to be returned in a search result. You can disable this option if you\ndon't plan to return the field contents in a search response to save on storage\noverhead. This can only be set during index creation and only for vector\nfields. This property cannot be changed for existing fields or set as false for\nnew fields. If this property is set as false, the property 'retrievable' must\nalso be set to false. This property must be true or unset for key fields, for\nnew fields, and for non-vector fields, and it must be null for complex fields.\nDisabling this property will reduce index storage requirements. The default is\ntrue for vector fields."
        },
        "searchable": {
          "type": "boolean",
          "description": "A value indicating whether the field is full-text searchable. This means it\nwill undergo analysis such as word-breaking during indexing. If you set a\nsearchable field to a value like \"sunny day\", internally it will be split into\nthe individual tokens \"sunny\" and \"day\". This enables full-text searches for\nthese terms. Fields of type Edm.String or Collection(Edm.String) are searchable\nby default. This property must be false for simple fields of other non-string\ndata types, and it must be null for complex fields. Note: searchable fields\nconsume extra space in your index to accommodate additional tokenized versions\nof the field value for full-text searches. If you want to save space in your\nindex and you don't need a field to be included in searches, set searchable to\nfalse."
        },
        "filterable": {
          "type": "boolean",
          "description": "A value indicating whether to enable the field to be referenced in $filter\nqueries. filterable differs from searchable in how strings are handled. Fields\nof type Edm.String or Collection(Edm.String) that are filterable do not undergo\nword-breaking, so comparisons are for exact matches only. For example, if you\nset such a field f to \"sunny day\", $filter=f eq 'sunny' will find no matches,\nbut $filter=f eq 'sunny day' will. This property must be null for complex\nfields. Default is true for simple fields and null for complex fields."
        },
        "sortable": {
          "type": "boolean",
          "description": "A value indicating whether to enable the field to be referenced in $orderby\nexpressions. By default, the search engine sorts results by score, but in many\nexperiences users will want to sort by fields in the documents. A simple field\ncan be sortable only if it is single-valued (it has a single value in the scope\nof the parent document). Simple collection fields cannot be sortable, since\nthey are multi-valued. Simple sub-fields of complex collections are also\nmulti-valued, and therefore cannot be sortable. This is true whether it's an\nimmediate parent field, or an ancestor field, that's the complex collection.\nComplex fields cannot be sortable and the sortable property must be null for\nsuch fields. The default for sortable is true for single-valued simple fields,\nfalse for multi-valued simple fields, and null for complex fields."
        },
        "facetable": {
          "type": "boolean",
          "description": "A value indicating whether to enable the field to be referenced in facet\nqueries. Typically used in a presentation of search results that includes hit\ncount by category (for example, search for digital cameras and see hits by\nbrand, by megapixels, by price, and so on). This property must be null for\ncomplex fields. Fields of type Edm.GeographyPoint or\nCollection(Edm.GeographyPoint) cannot be facetable. Default is true for all\nother simple fields."
        },
        "analyzer": {
          "$ref": "#/definitions/LexicalAnalyzerName",
          "description": "The name of the analyzer to use for the field. This option can be used only\nwith searchable fields and it can't be set together with either searchAnalyzer\nor indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the\nfield. Must be null for complex fields."
        },
        "searchAnalyzer": {
          "$ref": "#/definitions/LexicalAnalyzerName",
          "description": "The name of the analyzer used at search time for the field. This option can be\nused only with searchable fields. It must be set together with indexAnalyzer\nand it cannot be set together with the analyzer option. This property cannot be\nset to the name of a language analyzer; use the analyzer property instead if\nyou need a language analyzer. This analyzer can be updated on an existing\nfield. Must be null for complex fields."
        },
        "indexAnalyzer": {
          "$ref": "#/definitions/LexicalAnalyzerName",
          "description": "The name of the analyzer used at indexing time for the field. This option can\nbe used only with searchable fields. It must be set together with\nsearchAnalyzer and it cannot be set together with the analyzer option.  This\nproperty cannot be set to the name of a language analyzer; use the analyzer\nproperty instead if you need a language analyzer. Once the analyzer is chosen,\nit cannot be changed for the field. Must be null for complex fields."
        },
        "dimensions": {
          "type": "integer",
          "format": "int32",
          "description": "The dimensionality of the vector field.",
          "minimum": 2,
          "maximum": 2048
        },
        "vectorSearchProfile": {
          "type": "string",
          "description": "The name of the vector search profile that specifies the algorithm and\nvectorizer to use when searching the vector field."
        },
        "vectorEncoding": {
          "$ref": "#/definitions/VectorEncodingFormat",
          "description": "The encoding format to interpret the field contents."
        },
        "synonymMaps": {
          "type": "array",
          "description": "A list of the names of synonym maps to associate with this field. This option\ncan be used only with searchable fields. Currently only one synonym map per\nfield is supported. Assigning a synonym map to a field ensures that query terms\ntargeting that field are expanded at query-time using the rules in the synonym\nmap. This attribute can be changed on existing fields. Must be null or an empty\ncollection for complex fields.",
          "items": {
            "type": "string"
          }
        },
        "fields": {
          "type": "array",
          "description": "A list of sub-fields if this is a field of type Edm.ComplexType or\nCollection(Edm.ComplexType). Must be null or empty for simple fields.",
          "items": {
            "$ref": "#/definitions/SearchField"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "name",
        "type"
      ]
    },
    "SearchFieldDataType": {
      "type": "string",
      "description": "Defines the data type of a field in a search index.",
      "enum": [
        "Edm.String",
        "Edm.Int32",
        "Edm.Int64",
        "Edm.Double",
        "Edm.Boolean",
        "Edm.DateTimeOffset",
        "Edm.GeographyPoint",
        "Edm.ComplexType",
        "Edm.Single",
        "Edm.Half",
        "Edm.Int16",
        "Edm.SByte",
        "Edm.Byte"
      ],
      "x-ms-enum": {
        "name": "SearchFieldDataType",
        "modelAsString": true,
        "values": [
          {
            "name": "String",
            "value": "Edm.String",
            "description": "Indicates that a field contains a string."
          },
          {
            "name": "Int32",
            "value": "Edm.Int32",
            "description": "Indicates that a field contains a 32-bit signed integer."
          },
          {
            "name": "Int64",
            "value": "Edm.Int64",
            "description": "Indicates that a field contains a 64-bit signed integer."
          },
          {
            "name": "Double",
            "value": "Edm.Double",
            "description": "Indicates that a field contains an IEEE double-precision floating point number."
          },
          {
            "name": "Boolean",
            "value": "Edm.Boolean",
            "description": "Indicates that a field contains a Boolean value (true or false)."
          },
          {
            "name": "DateTimeOffset",
            "value": "Edm.DateTimeOffset",
            "description": "Indicates that a field contains a date/time value, including timezone\ninformation."
          },
          {
            "name": "GeographyPoint",
            "value": "Edm.GeographyPoint",
            "description": "Indicates that a field contains a geo-location in terms of longitude and\nlatitude."
          },
          {
            "name": "Complex",
            "value": "Edm.ComplexType",
            "description": "Indicates that a field contains one or more complex objects that in turn have\nsub-fields of other types."
          },
          {
            "name": "Single",
            "value": "Edm.Single",
            "description": "Indicates that a field contains a single-precision floating point number. This\nis only valid when used with Collection(Edm.Single)."
          },
          {
            "name": "Half",
            "value": "Edm.Half",
            "description": "Indicates that a field contains a half-precision floating point number. This is\nonly valid when used with Collection(Edm.Half)."
          },
          {
            "name": "Int16",
            "value": "Edm.Int16",
            "description": "Indicates that a field contains a 16-bit signed integer. This is only valid\nwhen used with Collection(Edm.Int16)."
          },
          {
            "name": "SByte",
            "value": "Edm.SByte",
            "description": "Indicates that a field contains a 8-bit signed integer. This is only valid when\nused with Collection(Edm.SByte)."
          },
          {
            "name": "Byte",
            "value": "Edm.Byte",
            "description": "Indicates that a field contains a 8-bit unsigned integer. This is only valid\nwhen used with Collection(Edm.Byte)."
          }
        ]
      }
    },
    "SearchIndex": {
      "type": "object",
      "description": "Represents a search index definition, which describes the fields and search\nbehavior of an index.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the index."
        },
        "fields": {
          "type": "array",
          "description": "The fields of the index.",
          "items": {
            "$ref": "#/definitions/SearchField"
          },
          "x-ms-identifiers": []
        },
        "scoringProfiles": {
          "type": "array",
          "description": "The scoring profiles for the index.",
          "items": {
            "$ref": "#/definitions/ScoringProfile"
          },
          "x-ms-identifiers": []
        },
        "defaultScoringProfile": {
          "type": "string",
          "description": "The name of the scoring profile to use if none is specified in the query. If\nthis property is not set and no scoring profile is specified in the query, then\ndefault scoring (tf-idf) will be used."
        },
        "corsOptions": {
          "$ref": "#/definitions/CorsOptions",
          "description": "Options to control Cross-Origin Resource Sharing (CORS) for the index."
        },
        "suggesters": {
          "type": "array",
          "description": "The suggesters for the index.",
          "items": {
            "$ref": "#/definitions/SearchSuggester"
          },
          "x-ms-identifiers": []
        },
        "analyzers": {
          "type": "array",
          "description": "The analyzers for the index.",
          "items": {
            "$ref": "#/definitions/LexicalAnalyzer"
          },
          "x-ms-identifiers": []
        },
        "tokenizers": {
          "type": "array",
          "description": "The tokenizers for the index.",
          "items": {
            "$ref": "#/definitions/LexicalTokenizer"
          },
          "x-ms-identifiers": []
        },
        "tokenFilters": {
          "type": "array",
          "description": "The token filters for the index.",
          "items": {
            "$ref": "#/definitions/TokenFilter"
          },
          "x-ms-identifiers": []
        },
        "charFilters": {
          "type": "array",
          "description": "The character filters for the index.",
          "items": {
            "$ref": "#/definitions/CharFilter"
          },
          "x-ms-identifiers": []
        },
        "encryptionKey": {
          "$ref": "#/definitions/SearchResourceEncryptionKey",
          "description": "A description of an encryption key that you create in Azure Key Vault. This key\nis used to provide an additional level of encryption-at-rest for your data when\nyou want full assurance that no one, not even Microsoft, can decrypt your data.\nOnce you have encrypted your data, it will always remain encrypted. The search\nservice will ignore attempts to set this property to null. You can change this\nproperty as needed if you want to rotate your encryption key; Your data will be\nunaffected. Encryption with customer-managed keys is not available for free\nsearch services, and is only available for paid services created on or after\nJanuary 1, 2019."
        },
        "similarity": {
          "$ref": "#/definitions/SimilarityAlgorithm",
          "description": "The type of similarity algorithm to be used when scoring and ranking the\ndocuments matching a search query. The similarity algorithm can only be defined\nat index creation time and cannot be modified on existing indexes. If null, the\nClassicSimilarity algorithm is used."
        },
        "semantic": {
          "$ref": "#/definitions/SemanticSearch",
          "description": "Defines parameters for a search index that influence semantic capabilities."
        },
        "vectorSearch": {
          "$ref": "#/definitions/VectorSearch",
          "description": "Contains configuration options related to vector search."
        },
        "@odata.etag": {
          "type": "string",
          "description": "The ETag of the index.",
          "x-ms-client-name": "eTag"
        }
      },
      "required": [
        "name",
        "fields"
      ]
    },
    "SearchIndexer": {
      "type": "object",
      "description": "Represents an indexer.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the indexer."
        },
        "description": {
          "type": "string",
          "description": "The description of the indexer."
        },
        "dataSourceName": {
          "type": "string",
          "description": "The name of the datasource from which this indexer reads data."
        },
        "skillsetName": {
          "type": "string",
          "description": "The name of the skillset executing with this indexer."
        },
        "targetIndexName": {
          "type": "string",
          "description": "The name of the index to which this indexer writes data."
        },
        "schedule": {
          "$ref": "#/definitions/IndexingSchedule",
          "description": "The schedule for this indexer."
        },
        "parameters": {
          "$ref": "#/definitions/IndexingParameters",
          "description": "Parameters for indexer execution."
        },
        "fieldMappings": {
          "type": "array",
          "description": "Defines mappings between fields in the data source and corresponding target\nfields in the index.",
          "items": {
            "$ref": "#/definitions/FieldMapping"
          },
          "x-ms-identifiers": []
        },
        "outputFieldMappings": {
          "type": "array",
          "description": "Output field mappings are applied after enrichment and immediately before\nindexing.",
          "items": {
            "$ref": "#/definitions/FieldMapping"
          },
          "x-ms-identifiers": []
        },
        "disabled": {
          "type": "boolean",
          "description": "A value indicating whether the indexer is disabled. Default is false."
        },
        "@odata.etag": {
          "type": "string",
          "description": "The ETag of the indexer.",
          "x-ms-client-name": "eTag"
        },
        "encryptionKey": {
          "$ref": "#/definitions/SearchResourceEncryptionKey",
          "description": "A description of an encryption key that you create in Azure Key Vault. This key\nis used to provide an additional level of encryption-at-rest for your indexer\ndefinition (as well as indexer execution status) when you want full assurance\nthat no one, not even Microsoft, can decrypt them. Once you have encrypted your\nindexer definition, it will always remain encrypted. The search service will\nignore attempts to set this property to null. You can change this property as\nneeded if you want to rotate your encryption key; Your indexer definition (and\nindexer execution status) will be unaffected. Encryption with customer-managed\nkeys is not available for free search services, and is only available for paid\nservices created on or after January 1, 2019."
        }
      },
      "required": [
        "name",
        "dataSourceName",
        "targetIndexName"
      ]
    },
    "SearchIndexerDataContainer": {
      "type": "object",
      "description": "Represents information about the entity (such as Azure SQL table or CosmosDB\ncollection) that will be indexed.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the table or view (for Azure SQL data source) or collection (for\nCosmosDB data source) that will be indexed."
        },
        "query": {
          "type": "string",
          "description": "A query that is applied to this data container. The syntax and meaning of this\nparameter is datasource-specific. Not supported by Azure SQL datasources."
        }
      },
      "required": [
        "name"
      ]
    },
    "SearchIndexerDataIdentity": {
      "type": "object",
      "description": "Abstract base type for data identities.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "A URI fragment specifying the type of identity."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type"
      ]
    },
    "SearchIndexerDataNoneIdentity": {
      "type": "object",
      "description": "Clears the identity property of a datasource.",
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerDataIdentity"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.DataNoneIdentity"
    },
    "SearchIndexerDataSource": {
      "type": "object",
      "description": "Represents a datasource definition, which can be used to configure an indexer.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the datasource."
        },
        "description": {
          "type": "string",
          "description": "The description of the datasource."
        },
        "type": {
          "$ref": "#/definitions/SearchIndexerDataSourceType",
          "description": "The type of the datasource."
        },
        "credentials": {
          "$ref": "#/definitions/DataSourceCredentials",
          "description": "Credentials for the datasource."
        },
        "container": {
          "$ref": "#/definitions/SearchIndexerDataContainer",
          "description": "The data container for the datasource."
        },
        "dataChangeDetectionPolicy": {
          "$ref": "#/definitions/DataChangeDetectionPolicy",
          "description": "The data change detection policy for the datasource."
        },
        "dataDeletionDetectionPolicy": {
          "$ref": "#/definitions/DataDeletionDetectionPolicy",
          "description": "The data deletion detection policy for the datasource."
        },
        "@odata.etag": {
          "type": "string",
          "description": "The ETag of the data source.",
          "x-ms-client-name": "eTag"
        },
        "encryptionKey": {
          "$ref": "#/definitions/SearchResourceEncryptionKey",
          "description": "A description of an encryption key that you create in Azure Key Vault. This key\nis used to provide an additional level of encryption-at-rest for your\ndatasource definition when you want full assurance that no one, not even\nMicrosoft, can decrypt your data source definition. Once you have encrypted\nyour data source definition, it will always remain encrypted. The search\nservice will ignore attempts to set this property to null. You can change this\nproperty as needed if you want to rotate your encryption key; Your datasource\ndefinition will be unaffected. Encryption with customer-managed keys is not\navailable for free search services, and is only available for paid services\ncreated on or after January 1, 2019."
        }
      },
      "required": [
        "name",
        "type",
        "credentials",
        "container"
      ]
    },
    "SearchIndexerDataSourceType": {
      "type": "string",
      "description": "Defines the type of a datasource.",
      "enum": [
        "azuresql",
        "cosmosdb",
        "azureblob",
        "azuretable",
        "mysql",
        "adlsgen2"
      ],
      "x-ms-enum": {
        "name": "SearchIndexerDataSourceType",
        "modelAsString": true,
        "values": [
          {
            "name": "AzureSql",
            "value": "azuresql",
            "description": "Indicates an Azure SQL datasource."
          },
          {
            "name": "CosmosDb",
            "value": "cosmosdb",
            "description": "Indicates a CosmosDB datasource."
          },
          {
            "name": "AzureBlob",
            "value": "azureblob",
            "description": "Indicates an Azure Blob datasource."
          },
          {
            "name": "AzureTable",
            "value": "azuretable",
            "description": "Indicates an Azure Table datasource."
          },
          {
            "name": "MySql",
            "value": "mysql",
            "description": "Indicates a MySql datasource."
          },
          {
            "name": "AdlsGen2",
            "value": "adlsgen2",
            "description": "Indicates an ADLS Gen2 datasource."
          }
        ]
      }
    },
    "SearchIndexerDataUserAssignedIdentity": {
      "type": "object",
      "description": "Specifies the identity for a datasource to use.",
      "properties": {
        "userAssignedIdentity": {
          "type": "string",
          "description": "The fully qualified Azure resource Id of a user assigned managed identity\ntypically in the form\n\"/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId\"\nthat should have been assigned to the search service."
        }
      },
      "required": [
        "userAssignedIdentity"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerDataIdentity"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.DataUserAssignedIdentity"
    },
    "SearchIndexerError": {
      "type": "object",
      "description": "Represents an item- or document-level indexing error.",
      "properties": {
        "key": {
          "type": "string",
          "description": "The key of the item for which indexing failed."
        },
        "errorMessage": {
          "type": "string",
          "description": "The message describing the error that occurred while processing the item."
        },
        "statusCode": {
          "type": "integer",
          "format": "int32",
          "description": "The status code indicating why the indexing operation failed. Possible values\ninclude: 400 for a malformed input document, 404 for document not found, 409\nfor a version conflict, 422 when the index is temporarily unavailable, or 503\nfor when the service is too busy."
        },
        "name": {
          "type": "string",
          "description": "The name of the source at which the error originated. For example, this could\nrefer to a particular skill in the attached skillset. This may not be always\navailable."
        },
        "details": {
          "type": "string",
          "description": "Additional, verbose details about the error to assist in debugging the indexer.\nThis may not be always available."
        },
        "documentationLink": {
          "type": "string",
          "description": "A link to a troubleshooting guide for these classes of errors. This may not be\nalways available."
        }
      },
      "required": [
        "errorMessage",
        "statusCode"
      ]
    },
    "SearchIndexerIndexProjection": {
      "type": "object",
      "description": "Definition of additional projections to secondary search indexes.",
      "properties": {
        "selectors": {
          "type": "array",
          "description": "A list of projections to be performed to secondary search indexes.",
          "items": {
            "$ref": "#/definitions/SearchIndexerIndexProjectionSelector"
          },
          "x-ms-identifiers": []
        },
        "parameters": {
          "$ref": "#/definitions/SearchIndexerIndexProjectionsParameters",
          "description": "A dictionary of index projection-specific configuration properties. Each name\nis the name of a specific property. Each value must be of a primitive type."
        }
      },
      "required": [
        "selectors"
      ]
    },
    "SearchIndexerIndexProjectionSelector": {
      "type": "object",
      "description": "Description for what data to store in the designated search index.",
      "properties": {
        "targetIndexName": {
          "type": "string",
          "description": "Name of the search index to project to. Must have a key field with the 'keyword' analyzer set."
        },
        "parentKeyFieldName": {
          "type": "string",
          "description": "Name of the field in the search index to map the parent document's key value\nto. Must be a string field that is filterable and not the key field."
        },
        "sourceContext": {
          "type": "string",
          "description": "Source context for the projections. Represents the cardinality at which the\ndocument will be split into multiple sub documents."
        },
        "mappings": {
          "type": "array",
          "description": "Mappings for the projection, or which source should be mapped to which field in\nthe target index.",
          "items": {
            "$ref": "#/definitions/InputFieldMappingEntry"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "targetIndexName",
        "parentKeyFieldName",
        "sourceContext",
        "mappings"
      ]
    },
    "SearchIndexerIndexProjectionsParameters": {
      "type": "object",
      "description": "A dictionary of index projection-specific configuration properties. Each name\nis the name of a specific property. Each value must be of a primitive type.",
      "properties": {
        "projectionMode": {
          "$ref": "#/definitions/IndexProjectionMode",
          "description": "Defines behavior of the index projections in relation to the rest of the\nindexer."
        }
      },
      "additionalProperties": {}
    },
    "SearchIndexerKnowledgeStore": {
      "type": "object",
      "description": "Definition of additional projections to azure blob, table, or files, of\nenriched data.",
      "properties": {
        "storageConnectionString": {
          "type": "string",
          "description": "The connection string to the storage account projections will be stored in."
        },
        "projections": {
          "type": "array",
          "description": "A list of additional projections to perform during indexing.",
          "items": {
            "$ref": "#/definitions/SearchIndexerKnowledgeStoreProjection"
          },
          "x-ms-identifiers": []
        }
      },
      "required": [
        "storageConnectionString",
        "projections"
      ]
    },
    "SearchIndexerKnowledgeStoreBlobProjectionSelector": {
      "type": "object",
      "description": "Abstract class to share properties between concrete selectors.",
      "properties": {
        "storageContainer": {
          "type": "string",
          "description": "Blob container to store projections in."
        }
      },
      "required": [
        "storageContainer"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerKnowledgeStoreProjectionSelector"
        }
      ]
    },
    "SearchIndexerKnowledgeStoreFileProjectionSelector": {
      "type": "object",
      "description": "Projection definition for what data to store in Azure Files.",
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerKnowledgeStoreBlobProjectionSelector"
        }
      ]
    },
    "SearchIndexerKnowledgeStoreObjectProjectionSelector": {
      "type": "object",
      "description": "Projection definition for what data to store in Azure Blob.",
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerKnowledgeStoreBlobProjectionSelector"
        }
      ]
    },
    "SearchIndexerKnowledgeStoreParameters": {
      "type": "object",
      "description": "A dictionary of knowledge store-specific configuration properties. Each name is\nthe name of a specific property. Each value must be of a primitive type.",
      "properties": {
        "synthesizeGeneratedKeyName": {
          "type": "boolean",
          "description": "Whether or not projections should synthesize a generated key name if one isn't\nalready present."
        }
      },
      "additionalProperties": {}
    },
    "SearchIndexerKnowledgeStoreProjection": {
      "type": "object",
      "description": "Container object for various projection selectors.",
      "properties": {
        "tables": {
          "type": "array",
          "description": "Projections to Azure Table storage.",
          "items": {
            "$ref": "#/definitions/SearchIndexerKnowledgeStoreTableProjectionSelector"
          },
          "x-ms-identifiers": []
        },
        "objects": {
          "type": "array",
          "description": "Projections to Azure Blob storage.",
          "items": {
            "$ref": "#/definitions/SearchIndexerKnowledgeStoreObjectProjectionSelector"
          },
          "x-ms-identifiers": []
        },
        "files": {
          "type": "array",
          "description": "Projections to Azure File storage.",
          "items": {
            "$ref": "#/definitions/SearchIndexerKnowledgeStoreFileProjectionSelector"
          },
          "x-ms-identifiers": []
        }
      }
    },
    "SearchIndexerKnowledgeStoreProjectionSelector": {
      "type": "object",
      "description": "Abstract class to share properties between concrete selectors.",
      "properties": {
        "referenceKeyName": {
          "type": "string",
          "description": "Name of reference key to different projection."
        },
        "generatedKeyName": {
          "type": "string",
          "description": "Name of generated key to store projection under."
        },
        "source": {
          "type": "string",
          "description": "Source data to project."
        },
        "sourceContext": {
          "type": "string",
          "description": "Source context for complex projections."
        },
        "inputs": {
          "type": "array",
          "description": "Nested inputs for complex projections.",
          "items": {
            "$ref": "#/definitions/InputFieldMappingEntry"
          },
          "x-ms-identifiers": []
        }
      }
    },
    "SearchIndexerKnowledgeStoreTableProjectionSelector": {
      "type": "object",
      "description": "Description for what data to store in Azure Tables.",
      "properties": {
        "tableName": {
          "type": "string",
          "description": "Name of the Azure table to store projected data in."
        }
      },
      "required": [
        "tableName"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerKnowledgeStoreProjectionSelector"
        }
      ]
    },
    "SearchIndexerLimits": {
      "type": "object",
      "description": "Represents the limits that can be applied to an indexer.",
      "properties": {
        "maxRunTime": {
          "type": "string",
          "format": "duration",
          "description": "The maximum duration that the indexer is permitted to run for one execution."
        },
        "maxDocumentExtractionSize": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum size of a document, in bytes, which will be considered valid for\nindexing."
        },
        "maxDocumentContentCharactersToExtract": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of characters that will be extracted from a document picked\nup for indexing."
        }
      }
    },
    "SearchIndexerSkill": {
      "type": "object",
      "description": "Base type for skills.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        },
        "name": {
          "type": "string",
          "description": "The name of the skill which uniquely identifies it within the skillset. A skill\nwith no name defined will be given a default name of its 1-based index in the\nskills array, prefixed with the character '#'."
        },
        "description": {
          "type": "string",
          "description": "The description of the skill which describes the inputs, outputs, and usage of\nthe skill."
        },
        "context": {
          "type": "string",
          "description": "Represents the level at which operations take place, such as the document root\nor document content (for example, /document or /document/content). The default\nis /document."
        },
        "inputs": {
          "type": "array",
          "description": "Inputs of the skills could be a column in the source data set, or the output of\nan upstream skill.",
          "items": {
            "$ref": "#/definitions/InputFieldMappingEntry"
          },
          "x-ms-identifiers": []
        },
        "outputs": {
          "type": "array",
          "description": "The output of a skill is either a field in a search index, or a value that can\nbe consumed as an input by another skill.",
          "items": {
            "$ref": "#/definitions/OutputFieldMappingEntry"
          },
          "x-ms-identifiers": []
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type",
        "inputs",
        "outputs"
      ]
    },
    "SearchIndexerSkillset": {
      "type": "object",
      "description": "A list of skills.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the skillset."
        },
        "description": {
          "type": "string",
          "description": "The description of the skillset."
        },
        "skills": {
          "type": "array",
          "description": "A list of skills in the skillset.",
          "items": {
            "$ref": "#/definitions/SearchIndexerSkill"
          },
          "x-ms-identifiers": []
        },
        "cognitiveServices": {
          "$ref": "#/definitions/CognitiveServicesAccount",
          "description": "Details about the Azure AI service to be used when running skills."
        },
        "knowledgeStore": {
          "$ref": "#/definitions/SearchIndexerKnowledgeStore",
          "description": "Definition of additional projections to Azure blob, table, or files, of\nenriched data."
        },
        "indexProjections": {
          "$ref": "#/definitions/SearchIndexerIndexProjection",
          "description": "Definition of additional projections to secondary search index(es)."
        },
        "@odata.etag": {
          "type": "string",
          "description": "The ETag of the skillset.",
          "x-ms-client-name": "eTag"
        },
        "encryptionKey": {
          "$ref": "#/definitions/SearchResourceEncryptionKey",
          "description": "A description of an encryption key that you create in Azure Key Vault. This key\nis used to provide an additional level of encryption-at-rest for your skillset\ndefinition when you want full assurance that no one, not even Microsoft, can\ndecrypt your skillset definition. Once you have encrypted your skillset\ndefinition, it will always remain encrypted. The search service will ignore\nattempts to set this property to null. You can change this property as needed\nif you want to rotate your encryption key; Your skillset definition will be\nunaffected. Encryption with customer-managed keys is not available for free\nsearch services, and is only available for paid services created on or after\nJanuary 1, 2019."
        }
      },
      "required": [
        "name",
        "skills"
      ]
    },
    "SearchIndexerStatus": {
      "type": "object",
      "description": "Represents the current status and execution history of an indexer.",
      "properties": {
        "status": {
          "$ref": "#/definitions/IndexerStatus",
          "description": "Overall indexer status."
        },
        "lastResult": {
          "$ref": "#/definitions/IndexerExecutionResult",
          "description": "The result of the most recent or an in-progress indexer execution."
        },
        "executionHistory": {
          "type": "array",
          "description": "History of the recent indexer executions, sorted in reverse chronological order.",
          "items": {
            "$ref": "#/definitions/IndexerExecutionResult"
          },
          "x-ms-identifiers": []
        },
        "limits": {
          "$ref": "#/definitions/SearchIndexerLimits",
          "description": "The execution limits for the indexer."
        }
      },
      "required": [
        "status",
        "executionHistory",
        "limits"
      ]
    },
    "SearchIndexerWarning": {
      "type": "object",
      "description": "Represents an item-level warning.",
      "properties": {
        "key": {
          "type": "string",
          "description": "The key of the item which generated a warning."
        },
        "message": {
          "type": "string",
          "description": "The message describing the warning that occurred while processing the item."
        },
        "name": {
          "type": "string",
          "description": "The name of the source at which the warning originated. For example, this could\nrefer to a particular skill in the attached skillset. This may not be always\navailable."
        },
        "details": {
          "type": "string",
          "description": "Additional, verbose details about the warning to assist in debugging the\nindexer. This may not be always available."
        },
        "documentationLink": {
          "type": "string",
          "description": "A link to a troubleshooting guide for these classes of warnings. This may not\nbe always available."
        }
      },
      "required": [
        "message"
      ]
    },
    "SearchMode": {
      "type": "string",
      "description": "Specifies whether any or all of the search terms must be matched in order to\ncount the document as a match.",
      "enum": [
        "any",
        "all"
      ],
      "x-ms-enum": {
        "name": "SearchMode",
        "modelAsString": true,
        "values": [
          {
            "name": "Any",
            "value": "any",
            "description": "Any of the search terms must be matched in order to count the document as a\nmatch."
          },
          {
            "name": "All",
            "value": "all",
            "description": "All of the search terms must be matched in order to count the document as a\nmatch."
          }
        ]
      }
    },
    "SearchRequest": {
      "type": "object",
      "description": "Parameters for filtering, sorting, faceting, paging, and other search query\nbehaviors.",
      "properties": {
        "count": {
          "type": "boolean",
          "description": "A value that specifies whether to fetch the total count of results. Default is\nfalse. Setting this value to true may have a performance impact. Note that the\ncount returned is an approximation."
        },
        "facets": {
          "type": "array",
          "description": "The list of facet expressions to apply to the search query. Each facet\nexpression contains a field name, optionally followed by a comma-separated list\nof name:value pairs.",
          "items": {
            "type": "string"
          }
        },
        "filter": {
          "type": "string",
          "description": "The OData $filter expression to apply to the search query."
        },
        "highlight": {
          "type": "string",
          "description": "The comma-separated list of field names to use for hit highlights. Only\nsearchable fields can be used for hit highlighting."
        },
        "highlightPostTag": {
          "type": "string",
          "description": "A string tag that is appended to hit highlights. Must be set with\nhighlightPreTag. Default is &lt;/em&gt;."
        },
        "highlightPreTag": {
          "type": "string",
          "description": "A string tag that is prepended to hit highlights. Must be set with\nhighlightPostTag. Default is &lt;em&gt;."
        },
        "minimumCoverage": {
          "type": "number",
          "format": "double",
          "description": "A number between 0 and 100 indicating the percentage of the index that must be\ncovered by a search query in order for the query to be reported as a success.\nThis parameter can be useful for ensuring search availability even for services\nwith only one replica. The default is 100."
        },
        "orderby": {
          "type": "string",
          "description": "The comma-separated list of OData $orderby expressions by which to sort the\nresults. Each expression can be either a field name or a call to either the\ngeo.distance() or the search.score() functions. Each expression can be followed\nby asc to indicate ascending, or desc to indicate descending. The default is\nascending order. Ties will be broken by the match scores of documents. If no\n$orderby is specified, the default sort order is descending by document match\nscore. There can be at most 32 $orderby clauses."
        },
        "queryType": {
          "$ref": "#/definitions/QueryType",
          "description": "A value that specifies the syntax of the search query. The default is 'simple'.\nUse 'full' if your query uses the Lucene query syntax."
        },
        "scoringStatistics": {
          "$ref": "#/definitions/ScoringStatistics",
          "description": "A value that specifies whether we want to calculate scoring statistics (such as\ndocument frequency) globally for more consistent scoring, or locally, for lower\nlatency. The default is 'local'. Use 'global' to aggregate scoring statistics\nglobally before scoring. Using global scoring statistics can increase latency\nof search queries."
        },
        "sessionId": {
          "type": "string",
          "description": "A value to be used to create a sticky session, which can help getting more\nconsistent results. As long as the same sessionId is used, a best-effort\nattempt will be made to target the same replica set. Be wary that reusing the\nsame sessionID values repeatedly can interfere with the load balancing of the\nrequests across replicas and adversely affect the performance of the search\nservice. The value used as sessionId cannot start with a '_' character."
        },
        "scoringParameters": {
          "type": "array",
          "description": "The list of parameter values to be used in scoring functions (for example,\nreferencePointParameter) using the format name-values. For example, if the\nscoring profile defines a function with a parameter called 'mylocation' the\nparameter string would be \"mylocation--122.2,44.8\" (without the quotes).",
          "items": {
            "type": "string"
          }
        },
        "scoringProfile": {
          "type": "string",
          "description": "The name of a scoring profile to evaluate match scores for matching documents\nin order to sort the results."
        },
        "search": {
          "type": "string",
          "description": "A full-text search query expression; Use \"*\" or omit this parameter to match\nall documents."
        },
        "searchFields": {
          "type": "string",
          "description": "The comma-separated list of field names to which to scope the full-text search.\nWhen using fielded search (fieldName:searchExpression) in a full Lucene query,\nthe field names of each fielded search expression take precedence over any\nfield names listed in this parameter."
        },
        "searchMode": {
          "$ref": "#/definitions/SearchMode",
          "description": "A value that specifies whether any or all of the search terms must be matched\nin order to count the document as a match."
        },
        "select": {
          "type": "string",
          "description": "The comma-separated list of fields to retrieve. If unspecified, all fields\nmarked as retrievable in the schema are included."
        },
        "skip": {
          "type": "integer",
          "format": "int32",
          "description": "The number of search results to skip. This value cannot be greater than\n100,000. If you need to scan documents in sequence, but cannot use skip due to\nthis limitation, consider using orderby on a totally-ordered key and filter\nwith a range query instead."
        },
        "top": {
          "type": "integer",
          "format": "int32",
          "description": "The number of search results to retrieve. This can be used in conjunction with\n$skip to implement client-side paging of search results. If results are\ntruncated due to server-side paging, the response will include a continuation\ntoken that can be used to issue another Search request for the next page of\nresults."
        },
        "semanticConfiguration": {
          "type": "string",
          "description": "The name of a semantic configuration that will be used when processing\ndocuments for queries of type semantic."
        },
        "semanticErrorHandling": {
          "$ref": "#/definitions/SemanticErrorMode",
          "description": "Allows the user to choose whether a semantic call should fail completely\n(default / current behavior), or to return partial results."
        },
        "semanticMaxWaitInMilliseconds": {
          "type": "integer",
          "format": "int32",
          "description": "Allows the user to set an upper bound on the amount of time it takes for\nsemantic enrichment to finish processing before the request fails.",
          "minimum": 700
        },
        "semanticQuery": {
          "type": "string",
          "description": "Allows setting a separate search query that will be solely used for semantic\nreranking, semantic captions and semantic answers. Is useful for scenarios\nwhere there is a need to use different queries between the base retrieval and\nranking phase, and the L2 semantic phase."
        },
        "answers": {
          "$ref": "#/definitions/QueryAnswerType",
          "description": "A value that specifies whether answers should be returned as part of the search\nresponse."
        },
        "captions": {
          "$ref": "#/definitions/QueryCaptionType",
          "description": "A value that specifies whether captions should be returned as part of the\nsearch response."
        },
        "vectorQueries": {
          "type": "array",
          "description": "The query parameters for vector and hybrid search queries.",
          "items": {
            "$ref": "#/definitions/VectorQuery"
          },
          "x-ms-identifiers": []
        },
        "vectorFilterMode": {
          "$ref": "#/definitions/VectorFilterMode",
          "description": "Determines whether or not filters are applied before or after the vector search\nis performed. Default is 'preFilter' for new indexes."
        }
      }
    },
    "SearchResourceEncryptionKey": {
      "type": "object",
      "description": "A customer-managed encryption key in Azure Key Vault. Keys that you create and\nmanage can be used to encrypt or decrypt data-at-rest, such as indexes and\nsynonym maps.",
      "properties": {
        "keyVaultKeyName": {
          "type": "string",
          "description": "The name of your Azure Key Vault key to be used to encrypt your data at rest."
        },
        "keyVaultKeyVersion": {
          "type": "string",
          "description": "The version of your Azure Key Vault key to be used to encrypt your data at rest."
        },
        "keyVaultUri": {
          "type": "string",
          "description": "The URI of your Azure Key Vault, also referred to as DNS name, that contains\nthe key to be used to encrypt your data at rest. An example URI might be\n`https://my-keyvault-name.vault.azure.net`."
        },
        "accessCredentials": {
          "$ref": "#/definitions/AzureActiveDirectoryApplicationCredentials",
          "description": "Optional Azure Active Directory credentials used for accessing your Azure Key\nVault. Not required if using managed identity instead."
        }
      },
      "required": [
        "keyVaultKeyName",
        "keyVaultKeyVersion",
        "keyVaultUri"
      ]
    },
    "SearchResult": {
      "type": "object",
      "description": "Contains a document found by a search query, plus associated metadata.",
      "properties": {
        "@search.score": {
          "type": "number",
          "format": "double",
          "description": "The relevance score of the document compared to other documents returned by the\nquery.",
          "x-ms-client-name": "score"
        },
        "@search.rerankerScore": {
          "type": "number",
          "format": "double",
          "description": "The relevance score computed by the semantic ranker for the top search results.\nSearch results are sorted by the RerankerScore first and then by the Score.\nRerankerScore is only returned for queries of type 'semantic'.",
          "x-ms-client-name": "rerankerScore"
        },
        "@search.highlights": {
          "type": "object",
          "description": "Text fragments from the document that indicate the matching search terms,\norganized by each applicable field; null if hit highlighting was not enabled\nfor the query.",
          "additionalProperties": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "x-ms-client-name": "highlights"
        },
        "@search.captions": {
          "type": "array",
          "description": "Captions are the most representative passages from the document relatively to\nthe search query. They are often used as document summary. Captions are only\nreturned for queries of type 'semantic'.",
          "items": {
            "$ref": "#/definitions/QueryCaptionResult"
          },
          "x-ms-client-name": "captions",
          "x-ms-identifiers": []
        }
      },
      "required": [
        "@search.score"
      ],
      "additionalProperties": {}
    },
    "SearchServiceCounters": {
      "type": "object",
      "description": "Represents service-level resource counters and quotas.",
      "properties": {
        "documentCount": {
          "$ref": "#/definitions/ResourceCounter",
          "description": "Total number of documents across all indexes in the service."
        },
        "indexesCount": {
          "$ref": "#/definitions/ResourceCounter",
          "description": "Total number of indexes."
        },
        "indexersCount": {
          "$ref": "#/definitions/ResourceCounter",
          "description": "Total number of indexers."
        },
        "dataSourcesCount": {
          "$ref": "#/definitions/ResourceCounter",
          "description": "Total number of data sources."
        },
        "storageSize": {
          "$ref": "#/definitions/ResourceCounter",
          "description": "Total size of used storage in bytes."
        },
        "synonymMaps": {
          "$ref": "#/definitions/ResourceCounter",
          "description": "Total number of synonym maps."
        },
        "skillsetCount": {
          "$ref": "#/definitions/ResourceCounter",
          "description": "Total number of skillsets."
        },
        "vectorIndexSize": {
          "$ref": "#/definitions/ResourceCounter",
          "description": "Total memory consumption of all vector indexes within the service, in bytes."
        }
      },
      "required": [
        "documentCount",
        "indexesCount",
        "indexersCount",
        "dataSourcesCount",
        "storageSize",
        "synonymMaps",
        "skillsetCount",
        "vectorIndexSize"
      ]
    },
    "SearchServiceLimits": {
      "type": "object",
      "description": "Represents various service level limits.",
      "properties": {
        "maxFieldsPerIndex": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum allowed fields per index."
        },
        "maxFieldNestingDepthPerIndex": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum depth which you can nest sub-fields in an index, including the\ntop-level complex field. For example, a/b/c has a nesting depth of 3."
        },
        "maxComplexCollectionFieldsPerIndex": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum number of fields of type Collection(Edm.ComplexType) allowed in an\nindex."
        },
        "maxComplexObjectsInCollectionsPerDocument": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum number of objects in complex collections allowed per document."
        },
        "maxStoragePerIndex": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum amount of storage in bytes allowed per index."
        }
      }
    },
    "SearchServiceStatistics": {
      "type": "object",
      "description": "Response from a get service statistics request. If successful, it includes\nservice level counters and limits.",
      "properties": {
        "counters": {
          "$ref": "#/definitions/SearchServiceCounters",
          "description": "Service level resource counters."
        },
        "limits": {
          "$ref": "#/definitions/SearchServiceLimits",
          "description": "Service level general limits."
        }
      },
      "required": [
        "counters",
        "limits"
      ]
    },
    "SearchSuggester": {
      "type": "object",
      "description": "Defines how the Suggest API should apply to a group of fields in the index.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the suggester."
        },
        "searchMode": {
          "type": "string",
          "description": "A value indicating the capabilities of the suggester.",
          "enum": [
            "analyzingInfixMatching"
          ],
          "x-ms-enum": {
            "modelAsString": false
          }
        },
        "sourceFields": {
          "type": "array",
          "description": "The list of field names to which the suggester applies. Each field must be\nsearchable.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "name",
        "searchMode",
        "sourceFields"
      ]
    },
    "SemanticConfiguration": {
      "type": "object",
      "description": "Defines a specific configuration to be used in the context of semantic\ncapabilities.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the semantic configuration."
        },
        "prioritizedFields": {
          "$ref": "#/definitions/SemanticPrioritizedFields",
          "description": "Describes the title, content, and keyword fields to be used for semantic\nranking, captions, highlights, and answers. At least one of the three sub\nproperties (titleField, prioritizedKeywordsFields and prioritizedContentFields)\nneed to be set."
        }
      },
      "required": [
        "name",
        "prioritizedFields"
      ]
    },
    "SemanticErrorMode": {
      "type": "string",
      "description": "Allows the user to choose whether a semantic call should fail completely, or to\nreturn partial results.",
      "enum": [
        "partial",
        "fail"
      ],
      "x-ms-enum": {
        "name": "SemanticErrorMode",
        "modelAsString": true,
        "values": [
          {
            "name": "Partial",
            "value": "partial",
            "description": "If the semantic processing fails, partial results still return. The definition\nof partial results depends on what semantic step failed and what was the reason\nfor failure."
          },
          {
            "name": "Fail",
            "value": "fail",
            "description": "If there is an exception during the semantic processing step, the query will\nfail and return the appropriate HTTP code depending on the error."
          }
        ]
      }
    },
    "SemanticErrorReason": {
      "type": "string",
      "description": "Reason that a partial response was returned for a semantic ranking request.",
      "enum": [
        "maxWaitExceeded",
        "capacityOverloaded",
        "transient"
      ],
      "x-ms-enum": {
        "name": "SemanticErrorReason",
        "modelAsString": true,
        "values": [
          {
            "name": "MaxWaitExceeded",
            "value": "maxWaitExceeded",
            "description": "If `semanticMaxWaitInMilliseconds` was set and the semantic processing duration\nexceeded that value. Only the base results were returned."
          },
          {
            "name": "CapacityOverloaded",
            "value": "capacityOverloaded",
            "description": "The request was throttled. Only the base results were returned."
          },
          {
            "name": "Transient",
            "value": "transient",
            "description": "At least one step of the semantic process failed."
          }
        ]
      }
    },
    "SemanticField": {
      "type": "object",
      "description": "A field that is used as part of the semantic configuration.",
      "properties": {
        "fieldName": {
          "type": "string",
          "description": "File name"
        }
      },
      "required": [
        "fieldName"
      ]
    },
    "SemanticPrioritizedFields": {
      "type": "object",
      "description": "Describes the title, content, and keywords fields to be used for semantic\nranking, captions, highlights, and answers.",
      "properties": {
        "titleField": {
          "$ref": "#/definitions/SemanticField",
          "description": "Defines the title field to be used for semantic ranking, captions, highlights,\nand answers. If you don't have a title field in your index, leave this blank."
        },
        "prioritizedContentFields": {
          "type": "array",
          "description": "Defines the content fields to be used for semantic ranking, captions,\nhighlights, and answers. For the best result, the selected fields should\ncontain text in natural language form. The order of the fields in the array\nrepresents their priority. Fields with lower priority may get truncated if the\ncontent is long.",
          "items": {
            "$ref": "#/definitions/SemanticField"
          },
          "x-ms-identifiers": []
        },
        "prioritizedKeywordsFields": {
          "type": "array",
          "description": "Defines the keyword fields to be used for semantic ranking, captions,\nhighlights, and answers. For the best result, the selected fields should\ncontain a list of keywords. The order of the fields in the array represents\ntheir priority. Fields with lower priority may get truncated if the content is\nlong.",
          "items": {
            "$ref": "#/definitions/SemanticField"
          },
          "x-ms-identifiers": []
        }
      }
    },
    "SemanticSearch": {
      "type": "object",
      "description": "Defines parameters for a search index that influence semantic capabilities.",
      "properties": {
        "defaultConfiguration": {
          "type": "string",
          "description": "Allows you to set the name of a default semantic configuration in your index,\nmaking it optional to pass it on as a query parameter every time."
        },
        "configurations": {
          "type": "array",
          "description": "The semantic configurations for the index.",
          "items": {
            "$ref": "#/definitions/SemanticConfiguration"
          },
          "x-ms-identifiers": []
        }
      }
    },
    "SemanticSearchResultsType": {
      "type": "string",
      "description": "Type of partial response that was returned for a semantic ranking request.",
      "enum": [
        "baseResults",
        "rerankedResults"
      ],
      "x-ms-enum": {
        "name": "SemanticSearchResultsType",
        "modelAsString": true,
        "values": [
          {
            "name": "BaseResults",
            "value": "baseResults",
            "description": "Results without any semantic enrichment or reranking."
          },
          {
            "name": "RerankedResults",
            "value": "rerankedResults",
            "description": "Results have been reranked with the reranker model and will include semantic\ncaptions. They will not include any answers, answers highlights or caption\nhighlights."
          }
        ]
      }
    },
    "SentimentSkill": {
      "type": "object",
      "description": "This skill is deprecated. Use the V3.SentimentSkill instead.",
      "properties": {
        "defaultLanguageCode": {
          "$ref": "#/definitions/SentimentSkillLanguage",
          "description": "A value indicating which language code to use. Default is `en`."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.SentimentSkill"
    },
    "SentimentSkillLanguage": {
      "type": "string",
      "description": "Deprecated. The language codes supported for input text by SentimentSkill.",
      "enum": [
        "da",
        "nl",
        "en",
        "fi",
        "fr",
        "de",
        "el",
        "it",
        "no",
        "pl",
        "pt-PT",
        "ru",
        "es",
        "sv",
        "tr"
      ],
      "x-ms-enum": {
        "name": "SentimentSkillLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "da",
            "value": "da",
            "description": "Danish"
          },
          {
            "name": "nl",
            "value": "nl",
            "description": "Dutch"
          },
          {
            "name": "en",
            "value": "en",
            "description": "English"
          },
          {
            "name": "fi",
            "value": "fi",
            "description": "Finnish"
          },
          {
            "name": "fr",
            "value": "fr",
            "description": "French"
          },
          {
            "name": "de",
            "value": "de",
            "description": "German"
          },
          {
            "name": "el",
            "value": "el",
            "description": "Greek"
          },
          {
            "name": "it",
            "value": "it",
            "description": "Italian"
          },
          {
            "name": "no",
            "value": "no",
            "description": "Norwegian (Bokmaal)"
          },
          {
            "name": "pl",
            "value": "pl",
            "description": "Polish"
          },
          {
            "name": "pt-PT",
            "value": "pt-PT",
            "description": "Portuguese (Portugal)"
          },
          {
            "name": "ru",
            "value": "ru",
            "description": "Russian"
          },
          {
            "name": "es",
            "value": "es",
            "description": "Spanish"
          },
          {
            "name": "sv",
            "value": "sv",
            "description": "Swedish"
          },
          {
            "name": "tr",
            "value": "tr",
            "description": "Turkish"
          }
        ]
      }
    },
    "SentimentSkillV3": {
      "type": "object",
      "description": "Using the Text Analytics API, evaluates unstructured text and for each record,\nprovides sentiment labels (such as \"negative\", \"neutral\" and \"positive\") based\non the highest confidence score found by the service at a sentence and\ndocument-level.",
      "properties": {
        "defaultLanguageCode": {
          "type": "string",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "includeOpinionMining": {
          "type": "boolean",
          "description": "If set to true, the skill output will include information from Text Analytics\nfor opinion mining, namely targets (nouns or verbs) and their associated\nassessment (adjective) in the text. Default is false."
        },
        "modelVersion": {
          "type": "string",
          "description": "The version of the model to use when calling the Text Analytics service. It\nwill default to the latest available when not specified. We recommend you do\nnot specify this value unless absolutely necessary."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.V3.SentimentSkill"
    },
    "ShaperSkill": {
      "type": "object",
      "description": "A skill for reshaping the outputs. It creates a complex type to support\ncomposite fields (also known as multipart fields).",
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Util.ShaperSkill"
    },
    "ShingleTokenFilter": {
      "type": "object",
      "description": "Creates combinations of tokens as a single token. This token filter is\nimplemented using Apache Lucene.",
      "properties": {
        "maxShingleSize": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum shingle size. Default and minimum value is 2.",
          "default": 2,
          "minimum": 2
        },
        "minShingleSize": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum shingle size. Default and minimum value is 2. Must be less than the\nvalue of maxShingleSize.",
          "default": 2,
          "minimum": 2
        },
        "outputUnigrams": {
          "type": "boolean",
          "description": "A value indicating whether the output stream will contain the input tokens\n(unigrams) as well as shingles. Default is true.",
          "default": true
        },
        "outputUnigramsIfNoShingles": {
          "type": "boolean",
          "description": "A value indicating whether to output unigrams for those times when no shingles\nare available. This property takes precedence when outputUnigrams is set to\nfalse. Default is false."
        },
        "tokenSeparator": {
          "type": "string",
          "description": "The string to use when joining adjacent tokens to form a shingle. Default is a\nsingle space (\" \").",
          "default": " "
        },
        "filterToken": {
          "type": "string",
          "description": "The string to insert for each position at which there is no token. Default is\nan underscore (\"_\").",
          "default": "_"
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.ShingleTokenFilter"
    },
    "SimilarityAlgorithm": {
      "type": "object",
      "description": "Base type for similarity algorithms. Similarity algorithms are used to\ncalculate scores that tie queries to documents. The higher the score, the more\nrelevant the document is to that specific query. Those scores are used to rank\nthe search results.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type"
      ]
    },
    "SnowballTokenFilter": {
      "type": "object",
      "description": "A filter that stems words using a Snowball-generated stemmer. This token filter\nis implemented using Apache Lucene.",
      "properties": {
        "language": {
          "$ref": "#/definitions/SnowballTokenFilterLanguage",
          "description": "The language to use."
        }
      },
      "required": [
        "language"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.SnowballTokenFilter"
    },
    "SnowballTokenFilterLanguage": {
      "type": "string",
      "description": "The language to use for a Snowball token filter.",
      "enum": [
        "armenian",
        "basque",
        "catalan",
        "danish",
        "dutch",
        "english",
        "finnish",
        "french",
        "german",
        "german2",
        "hungarian",
        "italian",
        "kp",
        "lovins",
        "norwegian",
        "porter",
        "portuguese",
        "romanian",
        "russian",
        "spanish",
        "swedish",
        "turkish"
      ],
      "x-ms-enum": {
        "name": "SnowballTokenFilterLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "Armenian",
            "value": "armenian",
            "description": "Selects the Lucene Snowball stemming tokenizer for Armenian."
          },
          {
            "name": "Basque",
            "value": "basque",
            "description": "Selects the Lucene Snowball stemming tokenizer for Basque."
          },
          {
            "name": "Catalan",
            "value": "catalan",
            "description": "Selects the Lucene Snowball stemming tokenizer for Catalan."
          },
          {
            "name": "Danish",
            "value": "danish",
            "description": "Selects the Lucene Snowball stemming tokenizer for Danish."
          },
          {
            "name": "Dutch",
            "value": "dutch",
            "description": "Selects the Lucene Snowball stemming tokenizer for Dutch."
          },
          {
            "name": "English",
            "value": "english",
            "description": "Selects the Lucene Snowball stemming tokenizer for English."
          },
          {
            "name": "Finnish",
            "value": "finnish",
            "description": "Selects the Lucene Snowball stemming tokenizer for Finnish."
          },
          {
            "name": "French",
            "value": "french",
            "description": "Selects the Lucene Snowball stemming tokenizer for French."
          },
          {
            "name": "German",
            "value": "german",
            "description": "Selects the Lucene Snowball stemming tokenizer for German."
          },
          {
            "name": "German2",
            "value": "german2",
            "description": "Selects the Lucene Snowball stemming tokenizer that uses the German variant\nalgorithm."
          },
          {
            "name": "Hungarian",
            "value": "hungarian",
            "description": "Selects the Lucene Snowball stemming tokenizer for Hungarian."
          },
          {
            "name": "Italian",
            "value": "italian",
            "description": "Selects the Lucene Snowball stemming tokenizer for Italian."
          },
          {
            "name": "Kp",
            "value": "kp",
            "description": "Selects the Lucene Snowball stemming tokenizer for Dutch that uses the\nKraaij-Pohlmann stemming algorithm."
          },
          {
            "name": "Lovins",
            "value": "lovins",
            "description": "Selects the Lucene Snowball stemming tokenizer for English that uses the Lovins\nstemming algorithm."
          },
          {
            "name": "Norwegian",
            "value": "norwegian",
            "description": "Selects the Lucene Snowball stemming tokenizer for Norwegian."
          },
          {
            "name": "Porter",
            "value": "porter",
            "description": "Selects the Lucene Snowball stemming tokenizer for English that uses the Porter\nstemming algorithm."
          },
          {
            "name": "Portuguese",
            "value": "portuguese",
            "description": "Selects the Lucene Snowball stemming tokenizer for Portuguese."
          },
          {
            "name": "Romanian",
            "value": "romanian",
            "description": "Selects the Lucene Snowball stemming tokenizer for Romanian."
          },
          {
            "name": "Russian",
            "value": "russian",
            "description": "Selects the Lucene Snowball stemming tokenizer for Russian."
          },
          {
            "name": "Spanish",
            "value": "spanish",
            "description": "Selects the Lucene Snowball stemming tokenizer for Spanish."
          },
          {
            "name": "Swedish",
            "value": "swedish",
            "description": "Selects the Lucene Snowball stemming tokenizer for Swedish."
          },
          {
            "name": "Turkish",
            "value": "turkish",
            "description": "Selects the Lucene Snowball stemming tokenizer for Turkish."
          }
        ]
      }
    },
    "SoftDeleteColumnDeletionDetectionPolicy": {
      "type": "object",
      "description": "Defines a data deletion detection policy that implements a soft-deletion\nstrategy. It determines whether an item should be deleted based on the value of\na designated 'soft delete' column.",
      "properties": {
        "softDeleteColumnName": {
          "type": "string",
          "description": "The name of the column to use for soft-deletion detection."
        },
        "softDeleteMarkerValue": {
          "type": "string",
          "description": "The marker value that identifies an item as deleted."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/DataDeletionDetectionPolicy"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
    },
    "SplitSkill": {
      "type": "object",
      "description": "A skill to split a string into chunks of text.",
      "properties": {
        "defaultLanguageCode": {
          "$ref": "#/definitions/SplitSkillLanguage",
          "description": "A value indicating which language code to use. Default is `en`."
        },
        "textSplitMode": {
          "$ref": "#/definitions/TextSplitMode",
          "description": "A value indicating which split mode to perform."
        },
        "maximumPageLength": {
          "type": "integer",
          "format": "int32",
          "description": "The desired maximum page length. Default is 10000."
        },
        "pageOverlapLength": {
          "type": "integer",
          "format": "int32",
          "description": "Only applicable when textSplitMode is set to 'pages'. If specified, n+1th chunk\nwill start with this number of characters/tokens from the end of the nth chunk."
        },
        "maximumPagesToTake": {
          "type": "integer",
          "format": "int32",
          "description": "Only applicable when textSplitMode is set to 'pages'. If specified, the\nSplitSkill will discontinue splitting after processing the first\n'maximumPagesToTake' pages, in order to improve performance when only a few\ninitial pages are needed from each document."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.SplitSkill"
    },
    "SplitSkillLanguage": {
      "type": "string",
      "description": "The language codes supported for input text by SplitSkill.",
      "enum": [
        "am",
        "bs",
        "cs",
        "da",
        "de",
        "en",
        "es",
        "et",
        "fi",
        "fr",
        "he",
        "hi",
        "hr",
        "hu",
        "id",
        "is",
        "it",
        "ja",
        "ko",
        "lv",
        "nb",
        "nl",
        "pl",
        "pt",
        "pt-br",
        "ru",
        "sk",
        "sl",
        "sr",
        "sv",
        "tr",
        "ur",
        "zh"
      ],
      "x-ms-enum": {
        "name": "SplitSkillLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "am",
            "value": "am",
            "description": "Amharic"
          },
          {
            "name": "bs",
            "value": "bs",
            "description": "Bosnian"
          },
          {
            "name": "cs",
            "value": "cs",
            "description": "Czech"
          },
          {
            "name": "da",
            "value": "da",
            "description": "Danish"
          },
          {
            "name": "de",
            "value": "de",
            "description": "German"
          },
          {
            "name": "en",
            "value": "en",
            "description": "English"
          },
          {
            "name": "es",
            "value": "es",
            "description": "Spanish"
          },
          {
            "name": "et",
            "value": "et",
            "description": "Estonian"
          },
          {
            "name": "fi",
            "value": "fi",
            "description": "Finnish"
          },
          {
            "name": "fr",
            "value": "fr",
            "description": "French"
          },
          {
            "name": "he",
            "value": "he",
            "description": "Hebrew"
          },
          {
            "name": "hi",
            "value": "hi",
            "description": "Hindi"
          },
          {
            "name": "hr",
            "value": "hr",
            "description": "Croatian"
          },
          {
            "name": "hu",
            "value": "hu",
            "description": "Hungarian"
          },
          {
            "name": "id",
            "value": "id",
            "description": "Indonesian"
          },
          {
            "name": "is",
            "value": "is",
            "description": "Icelandic"
          },
          {
            "name": "it",
            "value": "it",
            "description": "Italian"
          },
          {
            "name": "ja",
            "value": "ja",
            "description": "Japanese"
          },
          {
            "name": "ko",
            "value": "ko",
            "description": "Korean"
          },
          {
            "name": "lv",
            "value": "lv",
            "description": "Latvian"
          },
          {
            "name": "nb",
            "value": "nb",
            "description": "Norwegian"
          },
          {
            "name": "nl",
            "value": "nl",
            "description": "Dutch"
          },
          {
            "name": "pl",
            "value": "pl",
            "description": "Polish"
          },
          {
            "name": "pt",
            "value": "pt",
            "description": "Portuguese (Portugal)"
          },
          {
            "name": "pt-br",
            "value": "pt-br",
            "description": "Portuguese (Brazil)"
          },
          {
            "name": "ru",
            "value": "ru",
            "description": "Russian"
          },
          {
            "name": "sk",
            "value": "sk",
            "description": "Slovak"
          },
          {
            "name": "sl",
            "value": "sl",
            "description": "Slovenian"
          },
          {
            "name": "sr",
            "value": "sr",
            "description": "Serbian"
          },
          {
            "name": "sv",
            "value": "sv",
            "description": "Swedish"
          },
          {
            "name": "tr",
            "value": "tr",
            "description": "Turkish"
          },
          {
            "name": "ur",
            "value": "ur",
            "description": "Urdu"
          },
          {
            "name": "zh",
            "value": "zh",
            "description": "Chinese (Simplified)"
          }
        ]
      }
    },
    "SqlIntegratedChangeTrackingPolicy": {
      "type": "object",
      "description": "Defines a data change detection policy that captures changes using the\nIntegrated Change Tracking feature of Azure SQL Database.",
      "allOf": [
        {
          "$ref": "#/definitions/DataChangeDetectionPolicy"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
    },
    "StemmerOverrideTokenFilter": {
      "type": "object",
      "description": "Provides the ability to override other stemming filters with custom\ndictionary-based stemming. Any dictionary-stemmed terms will be marked as\nkeywords so that they will not be stemmed with stemmers down the chain. Must be\nplaced before any stemming filters. This token filter is implemented using\nApache Lucene.",
      "properties": {
        "rules": {
          "type": "array",
          "description": "A list of stemming rules in the following format: \"word => stem\", for example:\n\"ran => run\".",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "rules"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.StemmerOverrideTokenFilter"
    },
    "StemmerTokenFilter": {
      "type": "object",
      "description": "Language specific stemming filter. This token filter is implemented using\nApache Lucene.",
      "properties": {
        "language": {
          "$ref": "#/definitions/StemmerTokenFilterLanguage",
          "description": "The language to use."
        }
      },
      "required": [
        "language"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.StemmerTokenFilter"
    },
    "StemmerTokenFilterLanguage": {
      "type": "string",
      "description": "The language to use for a stemmer token filter.",
      "enum": [
        "arabic",
        "armenian",
        "basque",
        "brazilian",
        "bulgarian",
        "catalan",
        "czech",
        "danish",
        "dutch",
        "dutchKp",
        "english",
        "lightEnglish",
        "minimalEnglish",
        "possessiveEnglish",
        "porter2",
        "lovins",
        "finnish",
        "lightFinnish",
        "french",
        "lightFrench",
        "minimalFrench",
        "galician",
        "minimalGalician",
        "german",
        "german2",
        "lightGerman",
        "minimalGerman",
        "greek",
        "hindi",
        "hungarian",
        "lightHungarian",
        "indonesian",
        "irish",
        "italian",
        "lightItalian",
        "sorani",
        "latvian",
        "norwegian",
        "lightNorwegian",
        "minimalNorwegian",
        "lightNynorsk",
        "minimalNynorsk",
        "portuguese",
        "lightPortuguese",
        "minimalPortuguese",
        "portugueseRslp",
        "romanian",
        "russian",
        "lightRussian",
        "spanish",
        "lightSpanish",
        "swedish",
        "lightSwedish",
        "turkish"
      ],
      "x-ms-enum": {
        "name": "StemmerTokenFilterLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "Arabic",
            "value": "arabic",
            "description": "Selects the Lucene stemming tokenizer for Arabic."
          },
          {
            "name": "Armenian",
            "value": "armenian",
            "description": "Selects the Lucene stemming tokenizer for Armenian."
          },
          {
            "name": "Basque",
            "value": "basque",
            "description": "Selects the Lucene stemming tokenizer for Basque."
          },
          {
            "name": "Brazilian",
            "value": "brazilian",
            "description": "Selects the Lucene stemming tokenizer for Portuguese (Brazil)."
          },
          {
            "name": "Bulgarian",
            "value": "bulgarian",
            "description": "Selects the Lucene stemming tokenizer for Bulgarian."
          },
          {
            "name": "Catalan",
            "value": "catalan",
            "description": "Selects the Lucene stemming tokenizer for Catalan."
          },
          {
            "name": "Czech",
            "value": "czech",
            "description": "Selects the Lucene stemming tokenizer for Czech."
          },
          {
            "name": "Danish",
            "value": "danish",
            "description": "Selects the Lucene stemming tokenizer for Danish."
          },
          {
            "name": "Dutch",
            "value": "dutch",
            "description": "Selects the Lucene stemming tokenizer for Dutch."
          },
          {
            "name": "DutchKp",
            "value": "dutchKp",
            "description": "Selects the Lucene stemming tokenizer for Dutch that uses the Kraaij-Pohlmann\nstemming algorithm."
          },
          {
            "name": "English",
            "value": "english",
            "description": "Selects the Lucene stemming tokenizer for English."
          },
          {
            "name": "LightEnglish",
            "value": "lightEnglish",
            "description": "Selects the Lucene stemming tokenizer for English that does light stemming."
          },
          {
            "name": "MinimalEnglish",
            "value": "minimalEnglish",
            "description": "Selects the Lucene stemming tokenizer for English that does minimal stemming."
          },
          {
            "name": "PossessiveEnglish",
            "value": "possessiveEnglish",
            "description": "Selects the Lucene stemming tokenizer for English that removes trailing\npossessives from words."
          },
          {
            "name": "Porter2",
            "value": "porter2",
            "description": "Selects the Lucene stemming tokenizer for English that uses the Porter2\nstemming algorithm."
          },
          {
            "name": "Lovins",
            "value": "lovins",
            "description": "Selects the Lucene stemming tokenizer for English that uses the Lovins stemming\nalgorithm."
          },
          {
            "name": "Finnish",
            "value": "finnish",
            "description": "Selects the Lucene stemming tokenizer for Finnish."
          },
          {
            "name": "LightFinnish",
            "value": "lightFinnish",
            "description": "Selects the Lucene stemming tokenizer for Finnish that does light stemming."
          },
          {
            "name": "French",
            "value": "french",
            "description": "Selects the Lucene stemming tokenizer for French."
          },
          {
            "name": "LightFrench",
            "value": "lightFrench",
            "description": "Selects the Lucene stemming tokenizer for French that does light stemming."
          },
          {
            "name": "MinimalFrench",
            "value": "minimalFrench",
            "description": "Selects the Lucene stemming tokenizer for French that does minimal stemming."
          },
          {
            "name": "Galician",
            "value": "galician",
            "description": "Selects the Lucene stemming tokenizer for Galician."
          },
          {
            "name": "MinimalGalician",
            "value": "minimalGalician",
            "description": "Selects the Lucene stemming tokenizer for Galician that does minimal stemming."
          },
          {
            "name": "German",
            "value": "german",
            "description": "Selects the Lucene stemming tokenizer for German."
          },
          {
            "name": "German2",
            "value": "german2",
            "description": "Selects the Lucene stemming tokenizer that uses the German variant algorithm."
          },
          {
            "name": "LightGerman",
            "value": "lightGerman",
            "description": "Selects the Lucene stemming tokenizer for German that does light stemming."
          },
          {
            "name": "MinimalGerman",
            "value": "minimalGerman",
            "description": "Selects the Lucene stemming tokenizer for German that does minimal stemming."
          },
          {
            "name": "Greek",
            "value": "greek",
            "description": "Selects the Lucene stemming tokenizer for Greek."
          },
          {
            "name": "Hindi",
            "value": "hindi",
            "description": "Selects the Lucene stemming tokenizer for Hindi."
          },
          {
            "name": "Hungarian",
            "value": "hungarian",
            "description": "Selects the Lucene stemming tokenizer for Hungarian."
          },
          {
            "name": "LightHungarian",
            "value": "lightHungarian",
            "description": "Selects the Lucene stemming tokenizer for Hungarian that does light stemming."
          },
          {
            "name": "Indonesian",
            "value": "indonesian",
            "description": "Selects the Lucene stemming tokenizer for Indonesian."
          },
          {
            "name": "Irish",
            "value": "irish",
            "description": "Selects the Lucene stemming tokenizer for Irish."
          },
          {
            "name": "Italian",
            "value": "italian",
            "description": "Selects the Lucene stemming tokenizer for Italian."
          },
          {
            "name": "LightItalian",
            "value": "lightItalian",
            "description": "Selects the Lucene stemming tokenizer for Italian that does light stemming."
          },
          {
            "name": "Sorani",
            "value": "sorani",
            "description": "Selects the Lucene stemming tokenizer for Sorani."
          },
          {
            "name": "Latvian",
            "value": "latvian",
            "description": "Selects the Lucene stemming tokenizer for Latvian."
          },
          {
            "name": "Norwegian",
            "value": "norwegian",
            "description": "Selects the Lucene stemming tokenizer for Norwegian (Bokmål)."
          },
          {
            "name": "LightNorwegian",
            "value": "lightNorwegian",
            "description": "Selects the Lucene stemming tokenizer for Norwegian (Bokmål) that does light\nstemming."
          },
          {
            "name": "MinimalNorwegian",
            "value": "minimalNorwegian",
            "description": "Selects the Lucene stemming tokenizer for Norwegian (Bokmål) that does minimal\nstemming."
          },
          {
            "name": "LightNynorsk",
            "value": "lightNynorsk",
            "description": "Selects the Lucene stemming tokenizer for Norwegian (Nynorsk) that does light\nstemming."
          },
          {
            "name": "MinimalNynorsk",
            "value": "minimalNynorsk",
            "description": "Selects the Lucene stemming tokenizer for Norwegian (Nynorsk) that does minimal\nstemming."
          },
          {
            "name": "Portuguese",
            "value": "portuguese",
            "description": "Selects the Lucene stemming tokenizer for Portuguese."
          },
          {
            "name": "LightPortuguese",
            "value": "lightPortuguese",
            "description": "Selects the Lucene stemming tokenizer for Portuguese that does light stemming."
          },
          {
            "name": "MinimalPortuguese",
            "value": "minimalPortuguese",
            "description": "Selects the Lucene stemming tokenizer for Portuguese that does minimal stemming."
          },
          {
            "name": "PortugueseRslp",
            "value": "portugueseRslp",
            "description": "Selects the Lucene stemming tokenizer for Portuguese that uses the RSLP\nstemming algorithm."
          },
          {
            "name": "Romanian",
            "value": "romanian",
            "description": "Selects the Lucene stemming tokenizer for Romanian."
          },
          {
            "name": "Russian",
            "value": "russian",
            "description": "Selects the Lucene stemming tokenizer for Russian."
          },
          {
            "name": "LightRussian",
            "value": "lightRussian",
            "description": "Selects the Lucene stemming tokenizer for Russian that does light stemming."
          },
          {
            "name": "Spanish",
            "value": "spanish",
            "description": "Selects the Lucene stemming tokenizer for Spanish."
          },
          {
            "name": "LightSpanish",
            "value": "lightSpanish",
            "description": "Selects the Lucene stemming tokenizer for Spanish that does light stemming."
          },
          {
            "name": "Swedish",
            "value": "swedish",
            "description": "Selects the Lucene stemming tokenizer for Swedish."
          },
          {
            "name": "LightSwedish",
            "value": "lightSwedish",
            "description": "Selects the Lucene stemming tokenizer for Swedish that does light stemming."
          },
          {
            "name": "Turkish",
            "value": "turkish",
            "description": "Selects the Lucene stemming tokenizer for Turkish."
          }
        ]
      }
    },
    "StopAnalyzer": {
      "type": "object",
      "description": "Divides text at non-letters; Applies the lowercase and stopword token filters.\nThis analyzer is implemented using Apache Lucene.",
      "properties": {
        "stopwords": {
          "type": "array",
          "description": "A list of stopwords.",
          "items": {
            "type": "string"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalAnalyzer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.StopAnalyzer"
    },
    "StopwordsList": {
      "type": "string",
      "description": "Identifies a predefined list of language-specific stopwords.",
      "enum": [
        "arabic",
        "armenian",
        "basque",
        "brazilian",
        "bulgarian",
        "catalan",
        "czech",
        "danish",
        "dutch",
        "english",
        "finnish",
        "french",
        "galician",
        "german",
        "greek",
        "hindi",
        "hungarian",
        "indonesian",
        "irish",
        "italian",
        "latvian",
        "norwegian",
        "persian",
        "portuguese",
        "romanian",
        "russian",
        "sorani",
        "spanish",
        "swedish",
        "thai",
        "turkish"
      ],
      "x-ms-enum": {
        "name": "StopwordsList",
        "modelAsString": true,
        "values": [
          {
            "name": "Arabic",
            "value": "arabic",
            "description": "Selects the stopword list for Arabic."
          },
          {
            "name": "Armenian",
            "value": "armenian",
            "description": "Selects the stopword list for Armenian."
          },
          {
            "name": "Basque",
            "value": "basque",
            "description": "Selects the stopword list for Basque."
          },
          {
            "name": "Brazilian",
            "value": "brazilian",
            "description": "Selects the stopword list for Portuguese (Brazil)."
          },
          {
            "name": "Bulgarian",
            "value": "bulgarian",
            "description": "Selects the stopword list for Bulgarian."
          },
          {
            "name": "Catalan",
            "value": "catalan",
            "description": "Selects the stopword list for Catalan."
          },
          {
            "name": "Czech",
            "value": "czech",
            "description": "Selects the stopword list for Czech."
          },
          {
            "name": "Danish",
            "value": "danish",
            "description": "Selects the stopword list for Danish."
          },
          {
            "name": "Dutch",
            "value": "dutch",
            "description": "Selects the stopword list for Dutch."
          },
          {
            "name": "English",
            "value": "english",
            "description": "Selects the stopword list for English."
          },
          {
            "name": "Finnish",
            "value": "finnish",
            "description": "Selects the stopword list for Finnish."
          },
          {
            "name": "French",
            "value": "french",
            "description": "Selects the stopword list for French."
          },
          {
            "name": "Galician",
            "value": "galician",
            "description": "Selects the stopword list for Galician."
          },
          {
            "name": "German",
            "value": "german",
            "description": "Selects the stopword list for German."
          },
          {
            "name": "Greek",
            "value": "greek",
            "description": "Selects the stopword list for Greek."
          },
          {
            "name": "Hindi",
            "value": "hindi",
            "description": "Selects the stopword list for Hindi."
          },
          {
            "name": "Hungarian",
            "value": "hungarian",
            "description": "Selects the stopword list for Hungarian."
          },
          {
            "name": "Indonesian",
            "value": "indonesian",
            "description": "Selects the stopword list for Indonesian."
          },
          {
            "name": "Irish",
            "value": "irish",
            "description": "Selects the stopword list for Irish."
          },
          {
            "name": "Italian",
            "value": "italian",
            "description": "Selects the stopword list for Italian."
          },
          {
            "name": "Latvian",
            "value": "latvian",
            "description": "Selects the stopword list for Latvian."
          },
          {
            "name": "Norwegian",
            "value": "norwegian",
            "description": "Selects the stopword list for Norwegian."
          },
          {
            "name": "Persian",
            "value": "persian",
            "description": "Selects the stopword list for Persian."
          },
          {
            "name": "Portuguese",
            "value": "portuguese",
            "description": "Selects the stopword list for Portuguese."
          },
          {
            "name": "Romanian",
            "value": "romanian",
            "description": "Selects the stopword list for Romanian."
          },
          {
            "name": "Russian",
            "value": "russian",
            "description": "Selects the stopword list for Russian."
          },
          {
            "name": "Sorani",
            "value": "sorani",
            "description": "Selects the stopword list for Sorani."
          },
          {
            "name": "Spanish",
            "value": "spanish",
            "description": "Selects the stopword list for Spanish."
          },
          {
            "name": "Swedish",
            "value": "swedish",
            "description": "Selects the stopword list for Swedish."
          },
          {
            "name": "Thai",
            "value": "thai",
            "description": "Selects the stopword list for Thai."
          },
          {
            "name": "Turkish",
            "value": "turkish",
            "description": "Selects the stopword list for Turkish."
          }
        ]
      }
    },
    "StopwordsTokenFilter": {
      "type": "object",
      "description": "Removes stop words from a token stream. This token filter is implemented using\nApache Lucene.",
      "properties": {
        "stopwords": {
          "type": "array",
          "description": "The list of stopwords. This property and the stopwords list property cannot\nboth be set.",
          "items": {
            "type": "string"
          }
        },
        "stopwordsList": {
          "$ref": "#/definitions/StopwordsList",
          "description": "A predefined list of stopwords to use. This property and the stopwords property\ncannot both be set. Default is English."
        },
        "ignoreCase": {
          "type": "boolean",
          "description": "A value indicating whether to ignore case. If true, all words are converted to\nlower case first. Default is false."
        },
        "removeTrailing": {
          "type": "boolean",
          "description": "A value indicating whether to ignore the last search term if it's a stop word.\nDefault is true.",
          "default": true
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.StopwordsTokenFilter"
    },
    "SuggestDocumentsResult": {
      "type": "object",
      "description": "Response containing suggestion query results from an index.",
      "properties": {
        "value": {
          "type": "array",
          "description": "The sequence of results returned by the query.",
          "items": {
            "$ref": "#/definitions/SuggestResult"
          },
          "x-ms-identifiers": []
        },
        "@search.coverage": {
          "type": "number",
          "format": "double",
          "description": "A value indicating the percentage of the index that was included in the query,\nor null if minimumCoverage was not set in the request.",
          "x-ms-client-name": "coverage"
        }
      },
      "required": [
        "value"
      ]
    },
    "SuggestRequest": {
      "type": "object",
      "description": "Parameters for filtering, sorting, fuzzy matching, and other suggestions query\nbehaviors.",
      "properties": {
        "filter": {
          "type": "string",
          "description": "An OData expression that filters the documents considered for suggestions."
        },
        "fuzzy": {
          "type": "boolean",
          "description": "A value indicating whether to use fuzzy matching for the suggestion query.\nDefault is false. When set to true, the query will find suggestions even if\nthere's a substituted or missing character in the search text. While this\nprovides a better experience in some scenarios, it comes at a performance cost\nas fuzzy suggestion searches are slower and consume more resources."
        },
        "highlightPostTag": {
          "type": "string",
          "description": "A string tag that is appended to hit highlights. Must be set with\nhighlightPreTag. If omitted, hit highlighting of suggestions is disabled."
        },
        "highlightPreTag": {
          "type": "string",
          "description": "A string tag that is prepended to hit highlights. Must be set with\nhighlightPostTag. If omitted, hit highlighting of suggestions is disabled."
        },
        "minimumCoverage": {
          "type": "number",
          "format": "double",
          "description": "A number between 0 and 100 indicating the percentage of the index that must be\ncovered by a suggestion query in order for the query to be reported as a\nsuccess. This parameter can be useful for ensuring search availability even for\nservices with only one replica. The default is 80."
        },
        "orderby": {
          "type": "string",
          "description": "The comma-separated list of OData $orderby expressions by which to sort the\nresults. Each expression can be either a field name or a call to either the\ngeo.distance() or the search.score() functions. Each expression can be followed\nby asc to indicate ascending, or desc to indicate descending. The default is\nascending order. Ties will be broken by the match scores of documents. If no\n$orderby is specified, the default sort order is descending by document match\nscore. There can be at most 32 $orderby clauses."
        },
        "search": {
          "type": "string",
          "description": "The search text to use to suggest documents. Must be at least 1 character, and\nno more than 100 characters."
        },
        "searchFields": {
          "type": "string",
          "description": "The comma-separated list of field names to search for the specified search\ntext. Target fields must be included in the specified suggester."
        },
        "select": {
          "type": "string",
          "description": "The comma-separated list of fields to retrieve. If unspecified, only the key\nfield will be included in the results."
        },
        "suggesterName": {
          "type": "string",
          "description": "The name of the suggester as specified in the suggesters collection that's part\nof the index definition."
        },
        "top": {
          "type": "integer",
          "format": "int32",
          "description": "The number of suggestions to retrieve. This must be a value between 1 and 100.\nThe default is 5."
        }
      },
      "required": [
        "search",
        "suggesterName"
      ]
    },
    "SuggestResult": {
      "type": "object",
      "description": "A result containing a document found by a suggestion query, plus associated\nmetadata.",
      "properties": {
        "@search.text": {
          "type": "string",
          "description": "The text of the suggestion result.",
          "x-ms-client-name": "text"
        }
      },
      "required": [
        "@search.text"
      ],
      "additionalProperties": {}
    },
    "SynonymMap": {
      "type": "object",
      "description": "Represents a synonym map definition.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the synonym map."
        },
        "format": {
          "type": "string",
          "description": "The format of the synonym map. Only the 'solr' format is currently supported.",
          "enum": [
            "solr"
          ],
          "x-ms-enum": {
            "modelAsString": false
          }
        },
        "synonyms": {
          "type": "string",
          "description": "A series of synonym rules in the specified synonym map format. The rules must\nbe separated by newlines."
        },
        "encryptionKey": {
          "$ref": "#/definitions/SearchResourceEncryptionKey",
          "description": "A description of an encryption key that you create in Azure Key Vault. This key\nis used to provide an additional level of encryption-at-rest for your data when\nyou want full assurance that no one, not even Microsoft, can decrypt your data.\nOnce you have encrypted your data, it will always remain encrypted. The search\nservice will ignore attempts to set this property to null. You can change this\nproperty as needed if you want to rotate your encryption key; Your data will be\nunaffected. Encryption with customer-managed keys is not available for free\nsearch services, and is only available for paid services created on or after\nJanuary 1, 2019."
        },
        "@odata.etag": {
          "type": "string",
          "description": "The ETag of the synonym map.",
          "x-ms-client-name": "eTag"
        }
      },
      "required": [
        "name",
        "format",
        "synonyms"
      ]
    },
    "SynonymTokenFilter": {
      "type": "object",
      "description": "Matches single or multi-word synonyms in a token stream. This token filter is\nimplemented using Apache Lucene.",
      "properties": {
        "synonyms": {
          "type": "array",
          "description": "A list of synonyms in following one of two formats: 1. incredible,\nunbelievable, fabulous => amazing - all terms on the left side of => symbol\nwill be replaced with all terms on its right side; 2. incredible, unbelievable,\nfabulous, amazing - comma separated list of equivalent words. Set the expand\noption to change how this list is interpreted.",
          "items": {
            "type": "string"
          }
        },
        "ignoreCase": {
          "type": "boolean",
          "description": "A value indicating whether to case-fold input for matching. Default is false."
        },
        "expand": {
          "type": "boolean",
          "description": "A value indicating whether all words in the list of synonyms (if => notation is\nnot used) will map to one another. If true, all words in the list of synonyms\n(if => notation is not used) will map to one another. The following list:\nincredible, unbelievable, fabulous, amazing is equivalent to: incredible,\nunbelievable, fabulous, amazing => incredible, unbelievable, fabulous, amazing.\nIf false, the following list: incredible, unbelievable, fabulous, amazing will\nbe equivalent to: incredible, unbelievable, fabulous, amazing => incredible.\nDefault is true.",
          "default": true
        }
      },
      "required": [
        "synonyms"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.SynonymTokenFilter"
    },
    "TagScoringFunction": {
      "type": "object",
      "description": "Defines a function that boosts scores of documents with string values matching\na given list of tags.",
      "properties": {
        "tag": {
          "$ref": "#/definitions/TagScoringParameters",
          "description": "Parameter values for the tag scoring function."
        }
      },
      "required": [
        "tag"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/ScoringFunction"
        }
      ],
      "x-ms-discriminator-value": "tag"
    },
    "TagScoringParameters": {
      "type": "object",
      "description": "Provides parameter values to a tag scoring function.",
      "properties": {
        "tagsParameter": {
          "type": "string",
          "description": "The name of the parameter passed in search queries to specify the list of tags\nto compare against the target field."
        }
      },
      "required": [
        "tagsParameter"
      ]
    },
    "TextSplitMode": {
      "type": "string",
      "description": "A value indicating which split mode to perform.",
      "enum": [
        "pages",
        "sentences"
      ],
      "x-ms-enum": {
        "name": "TextSplitMode",
        "modelAsString": true,
        "values": [
          {
            "name": "Pages",
            "value": "pages",
            "description": "Split the text into individual pages."
          },
          {
            "name": "Sentences",
            "value": "sentences",
            "description": "Split the text into individual sentences."
          }
        ]
      }
    },
    "TextTranslationSkill": {
      "type": "object",
      "description": "A skill to translate text from one language to another.",
      "properties": {
        "defaultToLanguageCode": {
          "$ref": "#/definitions/TextTranslationSkillLanguage",
          "description": "The language code to translate documents into for documents that don't specify\nthe to language explicitly."
        },
        "defaultFromLanguageCode": {
          "$ref": "#/definitions/TextTranslationSkillLanguage",
          "description": "The language code to translate documents from for documents that don't specify\nthe from language explicitly."
        },
        "suggestedFrom": {
          "$ref": "#/definitions/TextTranslationSkillLanguage",
          "description": "The language code to translate documents from when neither the fromLanguageCode\ninput nor the defaultFromLanguageCode parameter are provided, and the automatic\nlanguage detection is unsuccessful. Default is `en`."
        }
      },
      "required": [
        "defaultToLanguageCode"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Text.TranslationSkill"
    },
    "TextTranslationSkillLanguage": {
      "type": "string",
      "description": "The language codes supported for input text by TextTranslationSkill.",
      "enum": [
        "af",
        "ar",
        "bn",
        "bs",
        "bg",
        "yue",
        "ca",
        "zh-Hans",
        "zh-Hant",
        "hr",
        "cs",
        "da",
        "nl",
        "en",
        "et",
        "fj",
        "fil",
        "fi",
        "fr",
        "de",
        "el",
        "ht",
        "he",
        "hi",
        "mww",
        "hu",
        "is",
        "id",
        "it",
        "ja",
        "sw",
        "tlh",
        "tlh-Latn",
        "tlh-Piqd",
        "ko",
        "lv",
        "lt",
        "mg",
        "ms",
        "mt",
        "nb",
        "fa",
        "pl",
        "pt",
        "pt-br",
        "pt-PT",
        "otq",
        "ro",
        "ru",
        "sm",
        "sr-Cyrl",
        "sr-Latn",
        "sk",
        "sl",
        "es",
        "sv",
        "ty",
        "ta",
        "te",
        "th",
        "to",
        "tr",
        "uk",
        "ur",
        "vi",
        "cy",
        "yua",
        "ga",
        "kn",
        "mi",
        "ml",
        "pa"
      ],
      "x-ms-enum": {
        "name": "TextTranslationSkillLanguage",
        "modelAsString": true,
        "values": [
          {
            "name": "af",
            "value": "af",
            "description": "Afrikaans"
          },
          {
            "name": "ar",
            "value": "ar",
            "description": "Arabic"
          },
          {
            "name": "bn",
            "value": "bn",
            "description": "Bangla"
          },
          {
            "name": "bs",
            "value": "bs",
            "description": "Bosnian (Latin)"
          },
          {
            "name": "bg",
            "value": "bg",
            "description": "Bulgarian"
          },
          {
            "name": "yue",
            "value": "yue",
            "description": "Cantonese (Traditional)"
          },
          {
            "name": "ca",
            "value": "ca",
            "description": "Catalan"
          },
          {
            "name": "zh-Hans",
            "value": "zh-Hans",
            "description": "Chinese Simplified"
          },
          {
            "name": "zh-Hant",
            "value": "zh-Hant",
            "description": "Chinese Traditional"
          },
          {
            "name": "hr",
            "value": "hr",
            "description": "Croatian"
          },
          {
            "name": "cs",
            "value": "cs",
            "description": "Czech"
          },
          {
            "name": "da",
            "value": "da",
            "description": "Danish"
          },
          {
            "name": "nl",
            "value": "nl",
            "description": "Dutch"
          },
          {
            "name": "en",
            "value": "en",
            "description": "English"
          },
          {
            "name": "et",
            "value": "et",
            "description": "Estonian"
          },
          {
            "name": "fj",
            "value": "fj",
            "description": "Fijian"
          },
          {
            "name": "fil",
            "value": "fil",
            "description": "Filipino"
          },
          {
            "name": "fi",
            "value": "fi",
            "description": "Finnish"
          },
          {
            "name": "fr",
            "value": "fr",
            "description": "French"
          },
          {
            "name": "de",
            "value": "de",
            "description": "German"
          },
          {
            "name": "el",
            "value": "el",
            "description": "Greek"
          },
          {
            "name": "ht",
            "value": "ht",
            "description": "Haitian Creole"
          },
          {
            "name": "he",
            "value": "he",
            "description": "Hebrew"
          },
          {
            "name": "hi",
            "value": "hi",
            "description": "Hindi"
          },
          {
            "name": "mww",
            "value": "mww",
            "description": "Hmong Daw"
          },
          {
            "name": "hu",
            "value": "hu",
            "description": "Hungarian"
          },
          {
            "name": "is",
            "value": "is",
            "description": "Icelandic"
          },
          {
            "name": "id",
            "value": "id",
            "description": "Indonesian"
          },
          {
            "name": "it",
            "value": "it",
            "description": "Italian"
          },
          {
            "name": "ja",
            "value": "ja",
            "description": "Japanese"
          },
          {
            "name": "sw",
            "value": "sw",
            "description": "Kiswahili"
          },
          {
            "name": "tlh",
            "value": "tlh",
            "description": "Klingon"
          },
          {
            "name": "tlh-Latn",
            "value": "tlh-Latn",
            "description": "Klingon (Latin script)"
          },
          {
            "name": "tlh-Piqd",
            "value": "tlh-Piqd",
            "description": "Klingon (Klingon script)"
          },
          {
            "name": "ko",
            "value": "ko",
            "description": "Korean"
          },
          {
            "name": "lv",
            "value": "lv",
            "description": "Latvian"
          },
          {
            "name": "lt",
            "value": "lt",
            "description": "Lithuanian"
          },
          {
            "name": "mg",
            "value": "mg",
            "description": "Malagasy"
          },
          {
            "name": "ms",
            "value": "ms",
            "description": "Malay"
          },
          {
            "name": "mt",
            "value": "mt",
            "description": "Maltese"
          },
          {
            "name": "nb",
            "value": "nb",
            "description": "Norwegian"
          },
          {
            "name": "fa",
            "value": "fa",
            "description": "Persian"
          },
          {
            "name": "pl",
            "value": "pl",
            "description": "Polish"
          },
          {
            "name": "pt",
            "value": "pt",
            "description": "Portuguese"
          },
          {
            "name": "pt-br",
            "value": "pt-br",
            "description": "Portuguese (Brazil)"
          },
          {
            "name": "pt-PT",
            "value": "pt-PT",
            "description": "Portuguese (Portugal)"
          },
          {
            "name": "otq",
            "value": "otq",
            "description": "Queretaro Otomi"
          },
          {
            "name": "ro",
            "value": "ro",
            "description": "Romanian"
          },
          {
            "name": "ru",
            "value": "ru",
            "description": "Russian"
          },
          {
            "name": "sm",
            "value": "sm",
            "description": "Samoan"
          },
          {
            "name": "sr-Cyrl",
            "value": "sr-Cyrl",
            "description": "Serbian (Cyrillic)"
          },
          {
            "name": "sr-Latn",
            "value": "sr-Latn",
            "description": "Serbian (Latin)"
          },
          {
            "name": "sk",
            "value": "sk",
            "description": "Slovak"
          },
          {
            "name": "sl",
            "value": "sl",
            "description": "Slovenian"
          },
          {
            "name": "es",
            "value": "es",
            "description": "Spanish"
          },
          {
            "name": "sv",
            "value": "sv",
            "description": "Swedish"
          },
          {
            "name": "ty",
            "value": "ty",
            "description": "Tahitian"
          },
          {
            "name": "ta",
            "value": "ta",
            "description": "Tamil"
          },
          {
            "name": "te",
            "value": "te",
            "description": "Telugu"
          },
          {
            "name": "th",
            "value": "th",
            "description": "Thai"
          },
          {
            "name": "to",
            "value": "to",
            "description": "Tongan"
          },
          {
            "name": "tr",
            "value": "tr",
            "description": "Turkish"
          },
          {
            "name": "uk",
            "value": "uk",
            "description": "Ukrainian"
          },
          {
            "name": "ur",
            "value": "ur",
            "description": "Urdu"
          },
          {
            "name": "vi",
            "value": "vi",
            "description": "Vietnamese"
          },
          {
            "name": "cy",
            "value": "cy",
            "description": "Welsh"
          },
          {
            "name": "yua",
            "value": "yua",
            "description": "Yucatec Maya"
          },
          {
            "name": "ga",
            "value": "ga",
            "description": "Irish"
          },
          {
            "name": "kn",
            "value": "kn",
            "description": "Kannada"
          },
          {
            "name": "mi",
            "value": "mi",
            "description": "Maori"
          },
          {
            "name": "ml",
            "value": "ml",
            "description": "Malayalam"
          },
          {
            "name": "pa",
            "value": "pa",
            "description": "Punjabi"
          }
        ]
      }
    },
    "TextWeights": {
      "type": "object",
      "description": "Defines weights on index fields for which matches should boost scoring in\nsearch queries.",
      "properties": {
        "weights": {
          "type": "object",
          "description": "The dictionary of per-field weights to boost document scoring. The keys are\nfield names and the values are the weights for each field.",
          "additionalProperties": {
            "format": "double",
            "type": "number"
          }
        }
      },
      "required": [
        "weights"
      ]
    },
    "TokenCharacterKind": {
      "type": "string",
      "description": "Represents classes of characters on which a token filter can operate.",
      "enum": [
        "letter",
        "digit",
        "whitespace",
        "punctuation",
        "symbol"
      ],
      "x-ms-enum": {
        "name": "TokenCharacterKind",
        "modelAsString": true,
        "values": [
          {
            "name": "Letter",
            "value": "letter",
            "description": "Keeps letters in tokens."
          },
          {
            "name": "Digit",
            "value": "digit",
            "description": "Keeps digits in tokens."
          },
          {
            "name": "Whitespace",
            "value": "whitespace",
            "description": "Keeps whitespace in tokens."
          },
          {
            "name": "Punctuation",
            "value": "punctuation",
            "description": "Keeps punctuation in tokens."
          },
          {
            "name": "Symbol",
            "value": "symbol",
            "description": "Keeps symbols in tokens."
          }
        ]
      }
    },
    "TokenFilter": {
      "type": "object",
      "description": "Base type for token filters.",
      "properties": {
        "@odata.type": {
          "type": "string",
          "description": "The discriminator for derived types."
        },
        "name": {
          "type": "string",
          "description": "The name of the token filter. It must only contain letters, digits, spaces,\ndashes or underscores, can only start and end with alphanumeric characters, and\nis limited to 128 characters."
        }
      },
      "discriminator": "@odata.type",
      "required": [
        "@odata.type",
        "name"
      ]
    },
    "TokenFilterName": {
      "type": "string",
      "description": "Defines the names of all token filters supported by the search engine.",
      "enum": [
        "arabic_normalization",
        "apostrophe",
        "asciifolding",
        "cjk_bigram",
        "cjk_width",
        "classic",
        "common_grams",
        "edgeNGram_v2",
        "elision",
        "german_normalization",
        "hindi_normalization",
        "indic_normalization",
        "keyword_repeat",
        "kstem",
        "length",
        "limit",
        "lowercase",
        "nGram_v2",
        "persian_normalization",
        "phonetic",
        "porter_stem",
        "reverse",
        "scandinavian_normalization",
        "scandinavian_folding",
        "shingle",
        "snowball",
        "sorani_normalization",
        "stemmer",
        "stopwords",
        "trim",
        "truncate",
        "unique",
        "uppercase",
        "word_delimiter"
      ],
      "x-ms-enum": {
        "name": "TokenFilterName",
        "modelAsString": true,
        "values": [
          {
            "name": "ArabicNormalization",
            "value": "arabic_normalization",
            "description": "A token filter that applies the Arabic normalizer to normalize the orthography.\nSee\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ar/ArabicNormalizationFilter.html"
          },
          {
            "name": "Apostrophe",
            "value": "apostrophe",
            "description": "Strips all characters after an apostrophe (including the apostrophe itself).\nSee\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/tr/ApostropheFilter.html"
          },
          {
            "name": "AsciiFolding",
            "value": "asciifolding",
            "description": "Converts alphabetic, numeric, and symbolic Unicode characters which are not in\nthe first 127 ASCII characters (the \"Basic Latin\" Unicode block) into their\nASCII equivalents, if such equivalents exist. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html"
          },
          {
            "name": "CjkBigram",
            "value": "cjk_bigram",
            "description": "Forms bigrams of CJK terms that are generated from the standard tokenizer. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKBigramFilter.html"
          },
          {
            "name": "CjkWidth",
            "value": "cjk_width",
            "description": "Normalizes CJK width differences. Folds fullwidth ASCII variants into the\nequivalent basic Latin, and half-width Katakana variants into the equivalent\nKana. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKWidthFilter.html"
          },
          {
            "name": "Classic",
            "value": "classic",
            "description": "Removes English possessives, and dots from acronyms. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicFilter.html"
          },
          {
            "name": "CommonGram",
            "value": "common_grams",
            "description": "Construct bigrams for frequently occurring terms while indexing. Single terms\nare still indexed too, with bigrams overlaid. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/commongrams/CommonGramsFilter.html"
          },
          {
            "name": "EdgeNGram",
            "value": "edgeNGram_v2",
            "description": "Generates n-grams of the given size(s) starting from the front or the back of\nan input token. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.html"
          },
          {
            "name": "Elision",
            "value": "elision",
            "description": "Removes elisions. For example, \"l'avion\" (the plane) will be converted to\n\"avion\" (plane). See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/util/ElisionFilter.html"
          },
          {
            "name": "GermanNormalization",
            "value": "german_normalization",
            "description": "Normalizes German characters according to the heuristics of the German2\nsnowball algorithm. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/de/GermanNormalizationFilter.html"
          },
          {
            "name": "HindiNormalization",
            "value": "hindi_normalization",
            "description": "Normalizes text in Hindi to remove some differences in spelling variations. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/hi/HindiNormalizationFilter.html"
          },
          {
            "name": "IndicNormalization",
            "value": "indic_normalization",
            "description": "Normalizes the Unicode representation of text in Indian languages. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/in/IndicNormalizationFilter.html"
          },
          {
            "name": "KeywordRepeat",
            "value": "keyword_repeat",
            "description": "Emits each incoming token twice, once as keyword and once as non-keyword. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/KeywordRepeatFilter.html"
          },
          {
            "name": "KStem",
            "value": "kstem",
            "description": "A high-performance kstem filter for English. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/en/KStemFilter.html"
          },
          {
            "name": "Length",
            "value": "length",
            "description": "Removes words that are too long or too short. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LengthFilter.html"
          },
          {
            "name": "Limit",
            "value": "limit",
            "description": "Limits the number of tokens while indexing. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LimitTokenCountFilter.html"
          },
          {
            "name": "Lowercase",
            "value": "lowercase",
            "description": "Normalizes token text to lower case. See\nhttps://lucene.apache.org/core/6_6_1/analyzers-common/org/apache/lucene/analysis/core/LowerCaseFilter.html"
          },
          {
            "name": "NGram",
            "value": "nGram_v2",
            "description": "Generates n-grams of the given size(s). See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenFilter.html"
          },
          {
            "name": "PersianNormalization",
            "value": "persian_normalization",
            "description": "Applies normalization for Persian. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/fa/PersianNormalizationFilter.html"
          },
          {
            "name": "Phonetic",
            "value": "phonetic",
            "description": "Create tokens for phonetic matches. See\nhttps://lucene.apache.org/core/4_10_3/analyzers-phonetic/org/apache/lucene/analysis/phonetic/package-tree.html"
          },
          {
            "name": "PorterStem",
            "value": "porter_stem",
            "description": "Uses the Porter stemming algorithm to transform the token stream. See\nhttp://tartarus.org/~martin/PorterStemmer"
          },
          {
            "name": "Reverse",
            "value": "reverse",
            "description": "Reverses the token string. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/reverse/ReverseStringFilter.html"
          },
          {
            "name": "ScandinavianNormalization",
            "value": "scandinavian_normalization",
            "description": "Normalizes use of the interchangeable Scandinavian characters. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianNormalizationFilter.html"
          },
          {
            "name": "ScandinavianFoldingNormalization",
            "value": "scandinavian_folding",
            "description": "Folds Scandinavian characters åÅäæÄÆ-&gt;a and öÖøØ-&gt;o. It also\ndiscriminates against use of double vowels aa, ae, ao, oe and oo, leaving just\nthe first one. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianFoldingFilter.html"
          },
          {
            "name": "Shingle",
            "value": "shingle",
            "description": "Creates combinations of tokens as a single token. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/shingle/ShingleFilter.html"
          },
          {
            "name": "Snowball",
            "value": "snowball",
            "description": "A filter that stems words using a Snowball-generated stemmer. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/snowball/SnowballFilter.html"
          },
          {
            "name": "SoraniNormalization",
            "value": "sorani_normalization",
            "description": "Normalizes the Unicode representation of Sorani text. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ckb/SoraniNormalizationFilter.html"
          },
          {
            "name": "Stemmer",
            "value": "stemmer",
            "description": "Language specific stemming filter. See\nhttps://learn.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#TokenFilters"
          },
          {
            "name": "Stopwords",
            "value": "stopwords",
            "description": "Removes stop words from a token stream. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopFilter.html"
          },
          {
            "name": "Trim",
            "value": "trim",
            "description": "Trims leading and trailing whitespace from tokens. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TrimFilter.html"
          },
          {
            "name": "Truncate",
            "value": "truncate",
            "description": "Truncates the terms to a specific length. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TruncateTokenFilter.html"
          },
          {
            "name": "Unique",
            "value": "unique",
            "description": "Filters out tokens with same text as the previous token. See\nhttp://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/RemoveDuplicatesTokenFilter.html"
          },
          {
            "name": "Uppercase",
            "value": "uppercase",
            "description": "Normalizes token text to upper case. See\nhttps://lucene.apache.org/core/6_6_1/analyzers-common/org/apache/lucene/analysis/core/UpperCaseFilter.html"
          },
          {
            "name": "WordDelimiter",
            "value": "word_delimiter",
            "description": "Splits words into subwords and performs optional transformations on subword\ngroups."
          }
        ]
      }
    },
    "TruncateTokenFilter": {
      "type": "object",
      "description": "Truncates the terms to a specific length. This token filter is implemented\nusing Apache Lucene.",
      "properties": {
        "length": {
          "type": "integer",
          "format": "int32",
          "description": "The length at which terms will be truncated. Default and maximum is 300.",
          "default": 300,
          "maximum": 300
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.TruncateTokenFilter"
    },
    "UaxUrlEmailTokenizer": {
      "type": "object",
      "description": "Tokenizes urls and emails as one token. This tokenizer is implemented using\nApache Lucene.",
      "properties": {
        "maxTokenLength": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum token length. Default is 255. Tokens longer than the maximum length\nare split. The maximum token length that can be used is 300 characters.",
          "default": 255,
          "maximum": 300
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/LexicalTokenizer"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.UaxUrlEmailTokenizer"
    },
    "UniqueTokenFilter": {
      "type": "object",
      "description": "Filters out tokens with same text as the previous token. This token filter is\nimplemented using Apache Lucene.",
      "properties": {
        "onlyOnSamePosition": {
          "type": "boolean",
          "description": "A value indicating whether to remove duplicates only at the same position.\nDefault is false."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.UniqueTokenFilter"
    },
    "VectorEncodingFormat": {
      "type": "string",
      "description": "The encoding format for interpreting vector field contents.",
      "enum": [
        "packedBit"
      ],
      "x-ms-enum": {
        "name": "VectorEncodingFormat",
        "modelAsString": true,
        "values": [
          {
            "name": "PackedBit",
            "value": "packedBit",
            "description": "Encoding format representing bits packed into a wider data type."
          }
        ]
      }
    },
    "VectorFilterMode": {
      "type": "string",
      "description": "Determines whether or not filters are applied before or after the vector search\nis performed.",
      "enum": [
        "postFilter",
        "preFilter"
      ],
      "x-ms-enum": {
        "name": "VectorFilterMode",
        "modelAsString": true,
        "values": [
          {
            "name": "PostFilter",
            "value": "postFilter",
            "description": "The filter will be applied after the candidate set of vector results is\nreturned. Depending on the filter selectivity, this can result in fewer results\nthan requested by the parameter 'k'."
          },
          {
            "name": "PreFilter",
            "value": "preFilter",
            "description": "The filter will be applied before the search query."
          }
        ]
      }
    },
    "VectorQuery": {
      "type": "object",
      "description": "The query parameters for vector and hybrid search queries.",
      "properties": {
        "k": {
          "type": "integer",
          "format": "int32",
          "description": "Number of nearest neighbors to return as top hits."
        },
        "fields": {
          "type": "string",
          "description": "Vector Fields of type Collection(Edm.Single) to be included in the vector\nsearched."
        },
        "exhaustive": {
          "type": "boolean",
          "description": "When true, triggers an exhaustive k-nearest neighbor search across all vectors\nwithin the vector index. Useful for scenarios where exact matches are critical,\nsuch as determining ground truth values."
        },
        "oversampling": {
          "type": "number",
          "format": "double",
          "description": "Oversampling factor. Minimum value is 1. It overrides the 'defaultOversampling'\nparameter configured in the index definition. It can be set only when 'rerankWithOriginalVectors'\nis true. This parameter is only permitted when a\ncompression method is used on the underlying vector field."
        },
        "weight": {
          "type": "number",
          "format": "float",
          "description": "Relative weight of the vector query when compared to other vector query and/or\nthe text query within the same search request. This value is used when\ncombining the results of multiple ranking lists produced by the different\nvector queries and/or the results retrieved through the text query. The higher\nthe weight, the higher the documents that matched that query will be in the\nfinal ranking. Default is 1.0 and the value needs to be a positive number\nlarger than zero."
        },
        "kind": {
          "$ref": "#/definitions/VectorQueryKind",
          "description": "Type of query."
        }
      },
      "discriminator": "kind",
      "required": [
        "kind"
      ]
    },
    "VectorQueryKind": {
      "type": "string",
      "description": "The kind of vector query being performed.",
      "enum": [
        "vector",
        "text"
      ],
      "x-ms-enum": {
        "name": "VectorQueryKind",
        "modelAsString": true,
        "values": [
          {
            "name": "Vector",
            "value": "vector",
            "description": "Vector query where a raw vector value is provided."
          },
          {
            "name": "Text",
            "value": "text",
            "description": "Vector query where a text value that needs to be vectorized is provided."
          }
        ]
      }
    },
    "VectorSearch": {
      "type": "object",
      "description": "Contains configuration options related to vector search.",
      "properties": {
        "profiles": {
          "type": "array",
          "description": "Defines combinations of configurations to use with vector search.",
          "items": {
            "$ref": "#/definitions/VectorSearchProfile"
          },
          "x-ms-identifiers": []
        },
        "algorithms": {
          "type": "array",
          "description": "Contains configuration options specific to the algorithm used during indexing\nor querying.",
          "items": {
            "$ref": "#/definitions/VectorSearchAlgorithmConfiguration"
          },
          "x-ms-identifiers": []
        },
        "vectorizers": {
          "type": "array",
          "description": "Contains configuration options on how to vectorize text vector queries.",
          "items": {
            "$ref": "#/definitions/VectorSearchVectorizer"
          },
          "x-ms-identifiers": []
        },
        "compressions": {
          "type": "array",
          "description": "Contains configuration options specific to the compression method used during\nindexing or querying.",
          "items": {
            "$ref": "#/definitions/VectorSearchCompression"
          },
          "x-ms-identifiers": []
        }
      }
    },
    "VectorSearchAlgorithmConfiguration": {
      "type": "object",
      "description": "Contains configuration options specific to the algorithm used during indexing\nor querying.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name to associate with this particular configuration."
        },
        "kind": {
          "$ref": "#/definitions/VectorSearchAlgorithmKind",
          "description": "Type of VectorSearchAlgorithmConfiguration."
        }
      },
      "discriminator": "kind",
      "required": [
        "name",
        "kind"
      ]
    },
    "VectorSearchAlgorithmKind": {
      "type": "string",
      "description": "The algorithm used for indexing and querying.",
      "enum": [
        "hnsw",
        "exhaustiveKnn"
      ],
      "x-ms-enum": {
        "name": "VectorSearchAlgorithmKind",
        "modelAsString": true,
        "values": [
          {
            "name": "Hnsw",
            "value": "hnsw",
            "description": "HNSW (Hierarchical Navigable Small World), a type of approximate nearest\nneighbors algorithm."
          },
          {
            "name": "ExhaustiveKnn",
            "value": "exhaustiveKnn",
            "description": "Exhaustive KNN algorithm which will perform brute-force search."
          }
        ]
      }
    },
    "VectorSearchAlgorithmMetric": {
      "type": "string",
      "description": "The similarity metric to use for vector comparisons. It is recommended to\nchoose the same similarity metric as the embedding model was trained on.",
      "enum": [
        "cosine",
        "euclidean",
        "dotProduct",
        "hamming"
      ],
      "x-ms-enum": {
        "name": "VectorSearchAlgorithmMetric",
        "modelAsString": true,
        "values": [
          {
            "name": "Cosine",
            "value": "cosine",
            "description": "Measures the angle between vectors to quantify their similarity, disregarding\nmagnitude. The smaller the angle, the closer the similarity."
          },
          {
            "name": "Euclidean",
            "value": "euclidean",
            "description": "Computes the straight-line distance between vectors in a multi-dimensional\nspace. The smaller the distance, the closer the similarity."
          },
          {
            "name": "DotProduct",
            "value": "dotProduct",
            "description": "Calculates the sum of element-wise products to gauge alignment and magnitude\nsimilarity. The larger and more positive, the closer the similarity."
          },
          {
            "name": "Hamming",
            "value": "hamming",
            "description": "Only applicable to bit-packed binary data types. Determines dissimilarity by\ncounting differing positions in binary vectors. The fewer differences, the\ncloser the similarity."
          }
        ]
      }
    },
    "VectorSearchCompression": {
      "type": "object",
      "description": "Contains configuration options specific to the compression method used during\nindexing or querying.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name to associate with this particular configuration."
        },
        "rerankWithOriginalVectors": {
          "type": "boolean",
          "description": "If set to true, once the ordered set of results calculated using compressed\nvectors are obtained, they will be reranked again by recalculating the\nfull-precision similarity scores. This will improve recall at the expense of\nlatency.",
          "default": true
        },
        "defaultOversampling": {
          "type": "number",
          "format": "double",
          "description": "Default oversampling factor. Oversampling will internally request more\ndocuments (specified by this multiplier) in the initial search. This increases\nthe set of results that will be reranked using recomputed similarity scores\nfrom full-precision vectors. Minimum value is 1, meaning no oversampling (1x).\nThis parameter can only be set when rerankWithOriginalVectors is true. Higher\nvalues improve recall at the expense of latency."
        },
        "kind": {
          "$ref": "#/definitions/VectorSearchCompressionKind",
          "description": "Type of VectorSearchCompression."
        }
      },
      "discriminator": "kind",
      "required": [
        "name",
        "kind"
      ]
    },
    "VectorSearchCompressionKind": {
      "type": "string",
      "description": "The compression method used for indexing and querying.",
      "enum": [
        "scalarQuantization",
        "binaryQuantization"
      ],
      "x-ms-enum": {
        "name": "VectorSearchCompressionKind",
        "modelAsString": true,
        "values": [
          {
            "name": "ScalarQuantization",
            "value": "scalarQuantization",
            "description": "Scalar Quantization, a type of compression method. In scalar quantization, the\noriginal vectors values are compressed to a narrower type by discretizing and\nrepresenting each component of a vector using a reduced set of quantized\nvalues, thereby reducing the overall data size."
          },
          {
            "name": "BinaryQuantization",
            "value": "binaryQuantization",
            "description": "Binary Quantization, a type of compression method. In binary quantization, the\noriginal vectors values are compressed to the narrower binary type by discretizing\nand representing each component of a vector using binary values,\nthereby reducing the overall data size."
          }
        ]
      }
    },
    "VectorSearchCompressionTarget": {
      "type": "string",
      "description": "The quantized data type of compressed vector values.",
      "enum": [
        "int8"
      ],
      "x-ms-enum": {
        "name": "VectorSearchCompressionTarget",
        "modelAsString": true,
        "values": [
          {
            "name": "Int8",
            "value": "int8",
            "description": "8-bit signed integer."
          }
        ]
      }
    },
    "VectorSearchProfile": {
      "type": "object",
      "description": "Defines a combination of configurations to use with vector search.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name to associate with this particular vector search profile."
        },
        "algorithm": {
          "type": "string",
          "description": "The name of the vector search algorithm configuration that specifies the\nalgorithm and optional parameters."
        },
        "vectorizer": {
          "type": "string",
          "description": "The name of the vectorization being configured for use with vector search."
        },
        "compression": {
          "type": "string",
          "description": "The name of the compression method configuration that specifies the compression\nmethod and optional parameters."
        }
      },
      "required": [
        "name",
        "algorithm"
      ]
    },
    "VectorSearchVectorizer": {
      "type": "object",
      "description": "Specifies the vectorization method to be used during query time.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name to associate with this particular vectorization method."
        },
        "kind": {
          "$ref": "#/definitions/VectorSearchVectorizerKind",
          "description": "Type of VectorSearchVectorizer."
        }
      },
      "discriminator": "kind",
      "required": [
        "name",
        "kind"
      ]
    },
    "VectorSearchVectorizerKind": {
      "type": "string",
      "description": "The vectorization method to be used during query time.",
      "enum": [
        "azureOpenAI",
        "customWebApi"
      ],
      "x-ms-enum": {
        "name": "VectorSearchVectorizerKind",
        "modelAsString": true,
        "values": [
          {
            "name": "AzureOpenAI",
            "value": "azureOpenAI",
            "description": "Generate embeddings using an Azure OpenAI resource at query time."
          },
          {
            "name": "CustomWebApi",
            "value": "customWebApi",
            "description": "Generate embeddings using a custom web endpoint at query time."
          }
        ]
      }
    },
    "VectorizableTextQuery": {
      "type": "object",
      "description": "The query parameters to use for vector search when a text value that needs to\nbe vectorized is provided.",
      "properties": {
        "text": {
          "type": "string",
          "description": "The text to be vectorized to perform a vector search query."
        }
      },
      "required": [
        "text"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/VectorQuery"
        }
      ],
      "x-ms-discriminator-value": "text"
    },
    "VectorizedQuery": {
      "type": "object",
      "description": "The query parameters to use for vector search when a raw vector value is\nprovided.",
      "properties": {
        "vector": {
          "type": "array",
          "description": "The vector representation of a search query.",
          "items": {
            "type": "number",
            "format": "float"
          }
        }
      },
      "required": [
        "vector"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/VectorQuery"
        }
      ],
      "x-ms-discriminator-value": "vector"
    },
    "VisualFeature": {
      "type": "string",
      "description": "The strings indicating what visual feature types to return.",
      "enum": [
        "adult",
        "brands",
        "categories",
        "description",
        "faces",
        "objects",
        "tags"
      ],
      "x-ms-enum": {
        "name": "VisualFeature",
        "modelAsString": true,
        "values": [
          {
            "name": "Adult",
            "value": "adult",
            "description": "Visual features recognized as adult persons."
          },
          {
            "name": "Brands",
            "value": "brands",
            "description": "Visual features recognized as commercial brands."
          },
          {
            "name": "Categories",
            "value": "categories",
            "description": "Categories."
          },
          {
            "name": "Description",
            "value": "description",
            "description": "Description."
          },
          {
            "name": "Faces",
            "value": "faces",
            "description": "Visual features recognized as people faces."
          },
          {
            "name": "Objects",
            "value": "objects",
            "description": "Visual features recognized as objects."
          },
          {
            "name": "Tags",
            "value": "tags",
            "description": "Tags."
          }
        ]
      }
    },
    "WebApiSkill": {
      "type": "object",
      "description": "A skill that can call a Web API endpoint, allowing you to extend a skillset by\nhaving it call your custom code.",
      "properties": {
        "uri": {
          "type": "string",
          "description": "The url for the Web API."
        },
        "httpHeaders": {
          "type": "object",
          "description": "The headers required to make the http request.",
          "additionalProperties": {
            "type": "string"
          }
        },
        "httpMethod": {
          "type": "string",
          "description": "The method for the http request."
        },
        "timeout": {
          "type": "string",
          "format": "duration",
          "description": "The desired timeout for the request. Default is 30 seconds."
        },
        "batchSize": {
          "type": "integer",
          "format": "int32",
          "description": "The desired batch size which indicates number of documents."
        },
        "degreeOfParallelism": {
          "type": "integer",
          "format": "int32",
          "description": "If set, the number of parallel calls that can be made to the Web API."
        },
        "authResourceId": {
          "type": "string",
          "description": "Applies to custom skills that connect to external code in an Azure function or\nsome other application that provides the transformations. This value should be\nthe application ID created for the function or app when it was registered with\nAzure Active Directory. When specified, the custom skill connects to the\nfunction or app using a managed ID (either system or user-assigned) of the\nsearch service and the access token of the function or app, using this value as\nthe resource id for creating the scope of the access token."
        },
        "authIdentity": {
          "$ref": "#/definitions/SearchIndexerDataIdentity",
          "description": "The user-assigned managed identity used for outbound connections. If an\nauthResourceId is provided and it's not specified, the system-assigned managed\nidentity is used. On updates to the indexer, if the identity is unspecified,\nthe value remains unchanged. If set to \"none\", the value of this property is\ncleared."
        }
      },
      "required": [
        "uri"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/SearchIndexerSkill"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Skills.Custom.WebApiSkill"
    },
    "WebApiVectorizer": {
      "type": "object",
      "description": "Specifies a user-defined vectorizer for generating the vector embedding of a\nquery string. Integration of an external vectorizer is achieved using the\ncustom Web API interface of a skillset.",
      "properties": {
        "customWebApiParameters": {
          "$ref": "#/definitions/WebApiVectorizerParameters",
          "description": "Specifies the properties of the user-defined vectorizer."
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/VectorSearchVectorizer"
        }
      ],
      "x-ms-discriminator-value": "customWebApi"
    },
    "WebApiVectorizerParameters": {
      "type": "object",
      "description": "Specifies the properties for connecting to a user-defined vectorizer.",
      "properties": {
        "uri": {
          "type": "string",
          "format": "uri",
          "description": "The URI of the Web API providing the vectorizer."
        },
        "httpHeaders": {
          "type": "object",
          "description": "The headers required to make the HTTP request.",
          "additionalProperties": {
            "type": "string"
          }
        },
        "httpMethod": {
          "type": "string",
          "description": "The method for the HTTP request."
        },
        "timeout": {
          "type": "string",
          "format": "duration",
          "description": "The desired timeout for the request. Default is 30 seconds."
        },
        "authResourceId": {
          "type": "string",
          "description": "Applies to custom endpoints that connect to external code in an Azure function\nor some other application that provides the transformations. This value should\nbe the application ID created for the function or app when it was registered\nwith Azure Active Directory. When specified, the vectorization connects to the\nfunction or app using a managed ID (either system or user-assigned) of the\nsearch service and the access token of the function or app, using this value as\nthe resource id for creating the scope of the access token."
        },
        "authIdentity": {
          "$ref": "#/definitions/SearchIndexerDataIdentity",
          "description": "The user-assigned managed identity used for outbound connections. If an\nauthResourceId is provided and it's not specified, the system-assigned managed\nidentity is used. On updates to the indexer, if the identity is unspecified,\nthe value remains unchanged. If set to \"none\", the value of this property is\ncleared."
        }
      }
    },
    "WordDelimiterTokenFilter": {
      "type": "object",
      "description": "Splits words into subwords and performs optional transformations on subword\ngroups. This token filter is implemented using Apache Lucene.",
      "properties": {
        "generateWordParts": {
          "type": "boolean",
          "description": "A value indicating whether to generate part words. If set, causes parts of\nwords to be generated; for example \"AzureSearch\" becomes \"Azure\" \"Search\".\nDefault is true.",
          "default": true
        },
        "generateNumberParts": {
          "type": "boolean",
          "description": "A value indicating whether to generate number subwords. Default is true.",
          "default": true
        },
        "catenateWords": {
          "type": "boolean",
          "description": "A value indicating whether maximum runs of word parts will be catenated. For\nexample, if this is set to true, \"Azure-Search\" becomes \"AzureSearch\". Default\nis false."
        },
        "catenateNumbers": {
          "type": "boolean",
          "description": "A value indicating whether maximum runs of number parts will be catenated. For\nexample, if this is set to true, \"1-2\" becomes \"12\". Default is false."
        },
        "catenateAll": {
          "type": "boolean",
          "description": "A value indicating whether all subword parts will be catenated. For example, if\nthis is set to true, \"Azure-Search-1\" becomes \"AzureSearch1\". Default is false."
        },
        "splitOnCaseChange": {
          "type": "boolean",
          "description": "A value indicating whether to split words on caseChange. For example, if this\nis set to true, \"AzureSearch\" becomes \"Azure\" \"Search\". Default is true.",
          "default": true
        },
        "preserveOriginal": {
          "type": "boolean",
          "description": "A value indicating whether original words will be preserved and added to the\nsubword list. Default is false."
        },
        "splitOnNumerics": {
          "type": "boolean",
          "description": "A value indicating whether to split on numbers. For example, if this is set to\ntrue, \"Azure1Search\" becomes \"Azure\" \"1\" \"Search\". Default is true.",
          "default": true
        },
        "stemEnglishPossessive": {
          "type": "boolean",
          "description": "A value indicating whether to remove trailing \"'s\" for each subword. Default is\ntrue.",
          "default": true
        },
        "protectedWords": {
          "type": "array",
          "description": "A list of tokens to protect from being delimited.",
          "items": {
            "type": "string"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/TokenFilter"
        }
      ],
      "x-ms-discriminator-value": "#Microsoft.Azure.Search.WordDelimiterTokenFilter"
    }
  },
  "parameters": {
    "Azure.Core.ClientRequestIdHeader": {
      "name": "x-ms-client-request-id",
      "in": "header",
      "description": "An opaque, globally-unique, client-generated string identifier for the request.",
      "required": false,
      "type": "string",
      "format": "uuid",
      "x-ms-parameter-location": "method",
      "x-ms-client-name": "clientRequestId"
    },
    "Azure.Core.Foundations.ApiVersionParameter": {
      "name": "api-version",
      "in": "query",
      "description": "The API version to use for this operation.",
      "required": true,
      "type": "string",
      "minLength": 1,
      "x-ms-parameter-location": "method",
      "x-ms-client-name": "apiVersion"
    }
  }
}
