import "@typespec/rest";
import "@typespec/http";
import "@azure-tools/typespec-azure-core";
import "./models-shared.tsp";

using TypeSpec.Rest;
using TypeSpec.Http;
namespace Search;

/**
 * Allows the user to choose whether a semantic call should fail completely, or to
 * return partial results.
 */
union SemanticErrorMode {
  string,

  /**
   * If the semantic processing fails, partial results still return. The definition
   * of partial results depends on what semantic step failed and what was the reason
   * for failure.
   */
  Partial: "partial",

  /**
   * If there is an exception during the semantic processing step, the query will
   * fail and return the appropriate HTTP code depending on the error.
   */
  Fail: "fail",
}

/**
 * This parameter is only valid if the query type is `semantic`. If set, the query
 * returns answers extracted from key passages in the highest ranked documents.
 * The number of answers returned can be configured by appending the pipe
 * character `|` followed by the `count-<number of answers>` option after the
 * answers parameter value, such as `extractive|count-3`. Default count is 1. The
 * confidence threshold can be configured by appending the pipe character `|`
 * followed by the `threshold-<confidence threshold>` option after the answers
 * parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.
 */
union QueryAnswerType {
  string,

  /**
   * Do not return answers for the query.
   */
  None: "none",

  /**
   * Extracts answer candidates from the contents of the documents returned in
   * response to a query expressed as a question in natural language.
   */
  Extractive: "extractive",
}

/**
 * This parameter is only valid if the query type is `semantic`. If set, the query
 * returns captions extracted from key passages in the highest ranked documents.
 * When Captions is set to `extractive`, highlighting is enabled by default, and
 * can be configured by appending the pipe character `|` followed by the
 * `highlight-<true/false>` option, such as `extractive|highlight-true`. Defaults
 * to `None`.
 */
union QueryCaptionType {
  string,

  /**
   * Do not return captions for the query.
   */
  None: "none",

  /**
   * Extracts captions from the matching documents that contain passages relevant to
   * the search query.
   */
  Extractive: "extractive",
}

/**
 * The kind of vector query being performed.
 */
union VectorQueryKind {
  string,

  /**
   * Vector query where a raw vector value is provided.
   */
  Vector: "vector",

  /**
   * Vector query where a text value that needs to be vectorized is provided.
   */
  Text: "text",
}

/**
 * Determines whether or not filters are applied before or after the vector search
 * is performed.
 */
union VectorFilterMode {
  string,

  /**
   * The filter will be applied after the candidate set of vector results is
   * returned. Depending on the filter selectivity, this can result in fewer results
   * than requested by the parameter 'k'.
   */
  PostFilter: "postFilter",

  /**
   * The filter will be applied before the search query.
   */
  PreFilter: "preFilter",
}

/**
 * Reason that a partial response was returned for a semantic ranking request.
 */
union SemanticErrorReason {
  string,

  /**
   * If `semanticMaxWaitInMilliseconds` was set and the semantic processing duration
   * exceeded that value. Only the base results were returned.
   */
  MaxWaitExceeded: "maxWaitExceeded",

  /**
   * The request was throttled. Only the base results were returned.
   */
  CapacityOverloaded: "capacityOverloaded",

  /**
   * At least one step of the semantic process failed.
   */
  Transient: "transient",
}

/**
 * Type of partial response that was returned for a semantic ranking request.
 */
union SemanticSearchResultsType {
  string,

  /**
   * Results without any semantic enrichment or reranking.
   */
  BaseResults: "baseResults",

  /**
   * Results have been reranked with the reranker model and will include semantic
   * captions. They will not include any answers, answers highlights or caption
   * highlights.
   */
  RerankedResults: "rerankedResults",
}

/**
 * Specifies the syntax of the search query. The default is 'simple'. Use 'full'
 * if your query uses the Lucene query syntax.
 */
union QueryType {
  string,

  /**
   * Uses the simple query syntax for searches. Search text is interpreted using a
   * simple query language that allows for symbols such as +, * and "". Queries are
   * evaluated across all searchable fields by default, unless the searchFields
   * parameter is specified.
   */
  Simple: "simple",

  /**
   * Uses the full Lucene query syntax for searches. Search text is interpreted
   * using the Lucene query language which allows field-specific and weighted
   * searches, as well as other advanced features.
   */
  Full: "full",

  /**
   * Best suited for queries expressed in natural language as opposed to keywords.
   * Improves precision of search results by re-ranking the top search results using
   * a ranking model trained on the Web corpus.
   */
  Semantic: "semantic",
}

/**
 * Specifies whether any or all of the search terms must be matched in order to
 * count the document as a match.
 */
union SearchMode {
  string,

  /**
   * Any of the search terms must be matched in order to count the document as a
   * match.
   */
  Any: "any",

  /**
   * All of the search terms must be matched in order to count the document as a
   * match.
   */
  All: "all",
}

/**
 * A value that specifies whether we want to calculate scoring statistics (such as
 * document frequency) globally for more consistent scoring, or locally, for lower
 * latency. The default is 'local'. Use 'global' to aggregate scoring statistics
 * globally before scoring. Using global scoring statistics can increase latency
 * of search queries.
 */
union ScoringStatistics {
  string,

  /**
   * The scoring statistics will be calculated locally for lower latency.
   */
  Local: "local",

  /**
   * The scoring statistics will be calculated globally for more consistent scoring.
   */
  Global: "global",
}

/**
 * The operation to perform on a document in an indexing batch.
 */
union IndexActionType {
  string,

  /**
   * Inserts the document into the index if it is new and updates it if it exists.
   * All fields are replaced in the update case.
   */
  Upload: "upload",

  /**
   * Merges the specified field values with an existing document. If the document
   * does not exist, the merge will fail. Any field you specify in a merge will
   * replace the existing field in the document. This also applies to collections of
   * primitive and complex types.
   */
  Merge: "merge",

  /**
   * Behaves like merge if a document with the given key already exists in the
   * index. If the document does not exist, it behaves like upload with a new
   * document.
   */
  MergeOrUpload: "mergeOrUpload",

  /**
   * Removes the specified document from the index. Any field you specify in a
   * delete operation other than the key field will be ignored. If you want to
   * remove an individual field from a document, use merge instead and set the field
   * explicitly to null.
   */
  Delete: "delete",
}

/**
 * Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
 * to get shingles and 'oneTermWithContext' to use the current context in
 * producing autocomplete terms.
 */
union AutocompleteMode {
  string,

  /**
   * Only one term is suggested. If the query has two terms, only the last term is
   * completed. For example, if the input is 'washington medic', the suggested terms
   * could include 'medicaid', 'medicare', and 'medicine'.
   */
  OneTerm: "oneTerm",

  /**
   * Matching two-term phrases in the index will be suggested. For example, if the
   * input is 'medic', the suggested terms could include 'medicare coverage' and 'medical assistant'.
   */
  TwoTerms: "twoTerms",

  /**
   * Completes the last term in a query with two or more terms, where the last two
   * terms are a phrase that exists in the index. For example, if the input is 'washington medic', the suggested terms could include 'washington medicaid' and 'washington medical'.
   */
  OneTermWithContext: "oneTermWithContext",
}

/**
 * Response containing search results from an index.
 */
model SearchDocumentsResult {
  /**
   * The total count of results found by the search operation, or null if the count
   * was not requested. If present, the count may be greater than the number of
   * results in this response. This can happen if you use the $top or $skip
   * parameters, or if the query can't return all the requested documents in a
   * single response.
   */
  @encodedName("application/json", "@odata.count")
  count?: int64;

  /**
   * A value indicating the percentage of the index that was included in the query,
   * or null if minimumCoverage was not specified in the request.
   */
  @encodedName("application/json", "@search.coverage")
  coverage?: float64;

  /**
   * The facet query results for the search operation, organized as a collection of
   * buckets for each faceted field; null if the query did not include any facet
   * expressions.
   */
  @encodedName("application/json", "@search.facets")
  facets?: Record<FacetResult[]>;

  /**
   * The answers query results for the search operation; null if the answers query
   * parameter was not specified or set to 'none'.
   */
  @encodedName("application/json", "@search.answers")
  answers?: QueryAnswerResult[];

  /**
   * Continuation JSON payload returned when the query can't return all the
   * requested results in a single response. You can use this JSON along with
   * @odata.nextLink to formulate another POST Search request to get the next part
   * of the search response.
   */
  @encodedName("application/json", "@search.nextPageParameters")
  nextPageParameters?: SearchRequest;

  /**
   * The sequence of results returned by the query.
   */
  value: SearchResult[];

  /**
   * Continuation URL returned when the query can't return all the requested results
   * in a single response. You can use this URL to formulate another GET or POST
   * Search request to get the next part of the search response. Make sure to use
   * the same verb (GET or POST) as the request that produced this response.
   */
  @encodedName("application/json", "@odata.nextLink")
  nextLink?: string;

  /**
   * Reason that a partial response was returned for a semantic ranking request.
   */
  @encodedName("application/json", "@search.semanticPartialResponseReason")
  semanticPartialResponseReason?: SemanticErrorReason;

  /**
   * Type of partial response that was returned for a semantic ranking request.
   */
  @encodedName("application/json", "@search.semanticPartialResponseType")
  semanticPartialResponseType?: SemanticSearchResultsType;
}

/**
 * A single bucket of a facet query result. Reports the number of documents with a
 * field value falling within a particular range or having a particular value or
 * interval.
 */
#suppress "@azure-tools/typespec-azure-core/bad-record-type" "model should have additionalProperties"
model FacetResult is Record<unknown> {
  /**
   * The approximate count of documents falling within the bucket described by this
   * facet.
   */
  count?: int64;
}

/**
 * An answer is a text passage extracted from the contents of the most relevant
 * documents that matched the query. Answers are extracted from the top search
 * results. Answer candidates are scored and the top answers are selected.
 */
#suppress "@azure-tools/typespec-azure-core/bad-record-type" "model should have additionalProperties"
model QueryAnswerResult is Record<unknown> {
  /**
   * The score value represents how relevant the answer is to the query relative to
   * other answers returned for the query.
   */
  score?: float64;

  /**
   * The key of the document the answer was extracted from.
   */
  key?: string;

  /**
   * The text passage extracted from the document contents as the answer.
   */
  text?: string;

  /**
   * Same text passage as in the Text property with highlighted text phrases most
   * relevant to the query.
   */
  highlights?: string;
}

/**
 * Parameters for filtering, sorting, faceting, paging, and other search query
 * behaviors.
 */
model SearchRequest {
  /**
   * A value that specifies whether to fetch the total count of results. Default is
   * false. Setting this value to true may have a performance impact. Note that the
   * count returned is an approximation.
   */
  count?: boolean;

  /**
   * The list of facet expressions to apply to the search query. Each facet
   * expression contains a field name, optionally followed by a comma-separated list
   * of name:value pairs.
   */
  facets?: string[];

  /**
   * The OData $filter expression to apply to the search query.
   */
  filter?: string;

  /**
   * The comma-separated list of field names to use for hit highlights. Only
   * searchable fields can be used for hit highlighting.
   */
  highlight?: string;

  /**
   * A string tag that is appended to hit highlights. Must be set with
   * highlightPreTag. Default is &lt;/em&gt;.
   */
  highlightPostTag?: string;

  /**
   * A string tag that is prepended to hit highlights. Must be set with
   * highlightPostTag. Default is &lt;em&gt;.
   */
  highlightPreTag?: string;

  /**
   * A number between 0 and 100 indicating the percentage of the index that must be
   * covered by a search query in order for the query to be reported as a success.
   * This parameter can be useful for ensuring search availability even for services
   * with only one replica. The default is 100.
   */
  minimumCoverage?: float64;

  /**
   * The comma-separated list of OData $orderby expressions by which to sort the
   * results. Each expression can be either a field name or a call to either the
   * geo.distance() or the search.score() functions. Each expression can be followed
   * by asc to indicate ascending, or desc to indicate descending. The default is
   * ascending order. Ties will be broken by the match scores of documents. If no
   * $orderby is specified, the default sort order is descending by document match
   * score. There can be at most 32 $orderby clauses.
   */
  orderby?: string;

  /**
   * A value that specifies the syntax of the search query. The default is 'simple'.
   * Use 'full' if your query uses the Lucene query syntax.
   */
  queryType?: QueryType;

  /**
   * A value that specifies whether we want to calculate scoring statistics (such as
   * document frequency) globally for more consistent scoring, or locally, for lower
   * latency. The default is 'local'. Use 'global' to aggregate scoring statistics
   * globally before scoring. Using global scoring statistics can increase latency
   * of search queries.
   */
  scoringStatistics?: ScoringStatistics;

  /**
   * A value to be used to create a sticky session, which can help getting more
   * consistent results. As long as the same sessionId is used, a best-effort
   * attempt will be made to target the same replica set. Be wary that reusing the
   * same sessionID values repeatedly can interfere with the load balancing of the
   * requests across replicas and adversely affect the performance of the search
   * service. The value used as sessionId cannot start with a '_' character.
   */
  sessionId?: string;

  /**
   * The list of parameter values to be used in scoring functions (for example,
   * referencePointParameter) using the format name-values. For example, if the
   * scoring profile defines a function with a parameter called 'mylocation' the
   * parameter string would be "mylocation--122.2,44.8" (without the quotes).
   */
  scoringParameters?: string[];

  /**
   * The name of a scoring profile to evaluate match scores for matching documents
   * in order to sort the results.
   */
  scoringProfile?: string;

  /**
   * A full-text search query expression; Use "*" or omit this parameter to match
   * all documents.
   */
  search?: string;

  /**
   * The comma-separated list of field names to which to scope the full-text search.
   * When using fielded search (fieldName:searchExpression) in a full Lucene query,
   * the field names of each fielded search expression take precedence over any
   * field names listed in this parameter.
   */
  searchFields?: string;

  /**
   * A value that specifies whether any or all of the search terms must be matched
   * in order to count the document as a match.
   */
  searchMode?: SearchMode;

  /**
   * The comma-separated list of fields to retrieve. If unspecified, all fields
   * marked as retrievable in the schema are included.
   */
  select?: string;

  /**
   * The number of search results to skip. This value cannot be greater than
   * 100,000. If you need to scan documents in sequence, but cannot use skip due to
   * this limitation, consider using orderby on a totally-ordered key and filter
   * with a range query instead.
   */
  skip?: int32;

  /**
   * The number of search results to retrieve. This can be used in conjunction with
   * $skip to implement client-side paging of search results. If results are
   * truncated due to server-side paging, the response will include a continuation
   * token that can be used to issue another Search request for the next page of
   * results.
   */
  top?: int32;

  /**
   * The name of a semantic configuration that will be used when processing
   * documents for queries of type semantic.
   */
  semanticConfiguration?: string;

  /**
   * Allows the user to choose whether a semantic call should fail completely
   * (default / current behavior), or to return partial results.
   */
  semanticErrorHandling?: SemanticErrorMode;

  /**
   * Allows the user to set an upper bound on the amount of time it takes for
   * semantic enrichment to finish processing before the request fails.
   */
  @minValue(700)
  semanticMaxWaitInMilliseconds?: int32;

  /**
   * Allows setting a separate search query that will be solely used for semantic
   * reranking, semantic captions and semantic answers. Is useful for scenarios
   * where there is a need to use different queries between the base retrieval and
   * ranking phase, and the L2 semantic phase.
   */
  semanticQuery?: string;

  /**
   * A value that specifies whether answers should be returned as part of the search
   * response.
   */
  answers?: QueryAnswerType;

  /**
   * A value that specifies whether captions should be returned as part of the
   * search response.
   */
  captions?: QueryCaptionType;

  /**
   * The query parameters for vector and hybrid search queries.
   */
  vectorQueries?: VectorQuery[];

  /**
   * Determines whether or not filters are applied before or after the vector search
   * is performed. Default is 'preFilter' for new indexes.
   */
  vectorFilterMode?: VectorFilterMode;
}

/**
 * The query parameters for vector and hybrid search queries.
 */
@discriminator("kind")
model VectorQuery {
  /**
   * Number of nearest neighbors to return as top hits.
   */
  k?: int32;

  /**
   * Vector Fields of type Collection(Edm.Single) to be included in the vector
   * searched.
   */
  fields?: string;

  /**
   * When true, triggers an exhaustive k-nearest neighbor search across all vectors
   * within the vector index. Useful for scenarios where exact matches are critical,
   * such as determining ground truth values.
   */
  exhaustive?: boolean;

  /**
   * Oversampling factor. Minimum value is 1. It overrides the 'defaultOversampling'
   * parameter configured in the index definition. It can be set only when 'rerankWithOriginalVectors'
   * is true. This parameter is only permitted when a
   * compression method is used on the underlying vector field.
   */
  oversampling?: float64;

  /**
   * Relative weight of the vector query when compared to other vector query and/or
   * the text query within the same search request. This value is used when
   * combining the results of multiple ranking lists produced by the different
   * vector queries and/or the results retrieved through the text query. The higher
   * the weight, the higher the documents that matched that query will be in the
   * final ranking. Default is 1.0 and the value needs to be a positive number
   * larger than zero.
   */
  weight?: float32;

  /**
   * Type of query.
   */
  kind: VectorQueryKind;
}

/**
 * Contains a document found by a search query, plus associated metadata.
 */
#suppress "@azure-tools/typespec-azure-core/bad-record-type" "model should have additionalProperties"
model SearchResult {
  ...Record<unknown>;

  /**
   * The relevance score of the document compared to other documents returned by the
   * query.
   */
  @encodedName("application/json", "@search.score")
  score: float64;

  /**
   * The relevance score computed by the semantic ranker for the top search results.
   * Search results are sorted by the RerankerScore first and then by the Score.
   * RerankerScore is only returned for queries of type 'semantic'.
   */
  @encodedName("application/json", "@search.rerankerScore")
  rerankerScore?: float64;

  /**
   * Text fragments from the document that indicate the matching search terms,
   * organized by each applicable field; null if hit highlighting was not enabled
   * for the query.
   */
  @encodedName("application/json", "@search.highlights")
  highlights?: Record<string[]>;

  /**
   * Captions are the most representative passages from the document relatively to
   * the search query. They are often used as document summary. Captions are only
   * returned for queries of type 'semantic'.
   */
  @encodedName("application/json", "@search.captions")
  captions?: QueryCaptionResult[];
}

/**
 * Captions are the most representative passages from the document relatively to
 * the search query. They are often used as document summary. Captions are only
 * returned for queries of type `semantic`.
 */
#suppress "@azure-tools/typespec-azure-core/bad-record-type" "model should have additionalProperties"
model QueryCaptionResult {
  ...Record<unknown>;

  /**
   * A representative text passage extracted from the document most relevant to the
   * search query.
   */
  text?: string;

  /**
   * Same text passage as in the Text property with highlighted phrases most
   * relevant to the query.
   */
  highlights?: string;
}

/**
 * Response containing suggestion query results from an index.
 */
model SuggestDocumentsResult {
  /**
   * The sequence of results returned by the query.
   */
  value: SuggestResult[];

  /**
   * A value indicating the percentage of the index that was included in the query,
   * or null if minimumCoverage was not set in the request.
   */
  @encodedName("application/json", "@search.coverage")
  coverage?: float64;
}

/**
 * A result containing a document found by a suggestion query, plus associated
 * metadata.
 */
#suppress "@azure-tools/typespec-azure-core/bad-record-type" "model should have additionalProperties"
model SuggestResult {
  ...Record<unknown>;

  /**
   * The text of the suggestion result.
   */
  @encodedName("application/json", "@search.text")
  text: string;
}

/**
 * Parameters for filtering, sorting, fuzzy matching, and other suggestions query
 * behaviors.
 */
model SuggestRequest {
  /**
   * An OData expression that filters the documents considered for suggestions.
   */
  filter?: string;

  /**
   * A value indicating whether to use fuzzy matching for the suggestion query.
   * Default is false. When set to true, the query will find suggestions even if
   * there's a substituted or missing character in the search text. While this
   * provides a better experience in some scenarios, it comes at a performance cost
   * as fuzzy suggestion searches are slower and consume more resources.
   */
  fuzzy?: boolean;

  /**
   * A string tag that is appended to hit highlights. Must be set with
   * highlightPreTag. If omitted, hit highlighting of suggestions is disabled.
   */
  highlightPostTag?: string;

  /**
   * A string tag that is prepended to hit highlights. Must be set with
   * highlightPostTag. If omitted, hit highlighting of suggestions is disabled.
   */
  highlightPreTag?: string;

  /**
   * A number between 0 and 100 indicating the percentage of the index that must be
   * covered by a suggestion query in order for the query to be reported as a
   * success. This parameter can be useful for ensuring search availability even for
   * services with only one replica. The default is 80.
   */
  minimumCoverage?: float64;

  /**
   * The comma-separated list of OData $orderby expressions by which to sort the
   * results. Each expression can be either a field name or a call to either the
   * geo.distance() or the search.score() functions. Each expression can be followed
   * by asc to indicate ascending, or desc to indicate descending. The default is
   * ascending order. Ties will be broken by the match scores of documents. If no
   * $orderby is specified, the default sort order is descending by document match
   * score. There can be at most 32 $orderby clauses.
   */
  orderby?: string;

  /**
   * The search text to use to suggest documents. Must be at least 1 character, and
   * no more than 100 characters.
   */
  search: string;

  /**
   * The comma-separated list of field names to search for the specified search
   * text. Target fields must be included in the specified suggester.
   */
  searchFields?: string;

  /**
   * The comma-separated list of fields to retrieve. If unspecified, only the key
   * field will be included in the results.
   */
  select?: string;

  /**
   * The name of the suggester as specified in the suggesters collection that's part
   * of the index definition.
   */
  suggesterName: string;

  /**
   * The number of suggestions to retrieve. This must be a value between 1 and 100.
   * The default is 5.
   */
  top?: int32;
}

/**
 * Contains a batch of document write actions to send to the index.
 */
model IndexBatch {
  /**
   * The actions in the batch.
   */
  value: IndexAction[];
}

/**
 * Represents an index action that operates on a document.
 */
#suppress "@azure-tools/typespec-azure-core/bad-record-type" "model should have additionalProperties"
model IndexAction {
  ...Record<unknown>;

  /**
   * The operation to perform on a document in an indexing batch.
   */
  @encodedName("application/json", "@search.action")
  actionType?: IndexActionType;
}

/**
 * A document retrieved via a document lookup operation.
 */
#suppress "@azure-tools/typespec-azure-core/bad-record-type" "model should have additionalProperties"
model LookupDocument {
  ...Record<unknown>;
}

/**
 * Response containing the status of operations for all documents in the indexing
 * request.
 */
model IndexDocumentsResult {
  /**
   * Response containing the status of operations for all actions in the batch.
   */
  #suppress "@azure-tools/typespec-azure-core/no-closed-literal-union" "return status code"
  @statusCode
  _: 200 | 207;

  /**
   * The list of status information for each document in the indexing request.
   */
  value: IndexingResult[];
}

/**
 * Status of an indexing operation for a single document.
 */
model IndexingResult {
  /**
   * The key of a document that was in the indexing request.
   */
  key: string;

  /**
   * The error message explaining why the indexing operation failed for the document
   * identified by the key; null if indexing succeeded.
   */
  errorMessage?: string;

  /**
   * A value indicating whether the indexing operation succeeded for the document
   * identified by the key.
   */
  status: boolean;

  /**
   * The status code of the indexing operation. Possible values include: 200 for a
   * successful update or delete, 201 for successful document creation, 400 for a
   * malformed input document, 404 for document not found, 409 for a version
   * conflict, 422 when the index is temporarily unavailable, or 503 for when the
   * service is too busy.
   */
  statusCode: int32;
}

/**
 * The result of Autocomplete query.
 */
model AutocompleteResult {
  /**
   * A value indicating the percentage of the index that was considered by the
   * autocomplete request, or null if minimumCoverage was not specified in the
   * request.
   */
  @encodedName("application/json", "@search.coverage")
  coverage?: float64;

  /**
   * The list of returned Autocompleted items.
   */
  value: AutocompleteItem[];
}

/**
 * The result of Autocomplete requests.
 */
model AutocompleteItem {
  /**
   * The completed term.
   */
  text: string;

  /**
   * The query along with the completed term.
   */
  queryPlusText: string;
}

/**
 * Parameters for fuzzy matching, and other autocomplete query behaviors.
 */
model AutocompleteRequest {
  /**
   * The search text on which to base autocomplete results.
   */
  search: string;

  /**
   * Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
   * to get shingles and 'oneTermWithContext' to use the current context while
   * producing auto-completed terms.
   */
  autocompleteMode?: AutocompleteMode;

  /**
   * An OData expression that filters the documents used to produce completed terms
   * for the Autocomplete result.
   */
  filter?: string;

  /**
   * A value indicating whether to use fuzzy matching for the autocomplete query.
   * Default is false. When set to true, the query will autocomplete terms even if
   * there's a substituted or missing character in the search text. While this
   * provides a better experience in some scenarios, it comes at a performance cost
   * as fuzzy autocomplete queries are slower and consume more resources.
   */
  fuzzy?: boolean;

  /**
   * A string tag that is appended to hit highlights. Must be set with
   * highlightPreTag. If omitted, hit highlighting is disabled.
   */
  highlightPostTag?: string;

  /**
   * A string tag that is prepended to hit highlights. Must be set with
   * highlightPostTag. If omitted, hit highlighting is disabled.
   */
  highlightPreTag?: string;

  /**
   * A number between 0 and 100 indicating the percentage of the index that must be
   * covered by an autocomplete query in order for the query to be reported as a
   * success. This parameter can be useful for ensuring search availability even for
   * services with only one replica. The default is 80.
   */
  minimumCoverage?: float64;

  /**
   * The comma-separated list of field names to consider when querying for
   * auto-completed terms. Target fields must be included in the specified
   * suggester.
   */
  searchFields?: string;

  /**
   * The name of the suggester as specified in the suggesters collection that's part
   * of the index definition.
   */
  suggesterName: string;

  /**
   * The number of auto-completed terms to retrieve. This must be a value between 1
   * and 100. The default is 5.
   */
  top?: int32;
}

/**
 * The query parameters to use for vector search when a raw vector value is
 * provided.
 */
model VectorizedQuery extends VectorQuery {
  /**
   * The vector representation of a search query.
   */
  vector: float32[];

  /**
   * The kind of vector query being performed.
   */
  kind: "vector";
}

/**
 * The query parameters to use for vector search when a text value that needs to
 * be vectorized is provided.
 */
model VectorizableTextQuery extends VectorQuery {
  /**
   * The text to be vectorized to perform a vector search query.
   */
  text: string;

  /**
   * The kind of vector query being performed.
   */
  kind: "text";
}
