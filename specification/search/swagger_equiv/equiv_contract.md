# Semantic Equivalency Contract for Swagger Comparison

This document defines the **strict semantic equivalency contract** used to compare Swagger/OpenAPI 2.0 specifications
during the Search API TypeSpec migration.

We must determine whether the TypeSpec-compiled Swagger is **semantically identical** to the original hand-authored
Swagger files, ignoring only documentation-related noise and ordering differences.

## Inputs

### **Input A: Three hand-authored Swagger files**

- searchservice:
  - path: "../data-plane/Azure.Search/preview/2025-11-01-preview/searchservice.json"
- searchindex:
  - path: "../data-plane/Azure.Search/preview/2025-11-01-preview/searchindex.json"
- knowledgebase:
  - path: "../data-plane/Azure.Search/preview/2025-11-01-preview/knowledgebase.json"
- common_types:
  - path: "../../common-types/data-plane/v1/types.json"
  - description: "external dependencies"

These three files describe the original API surface and must first be merged into a single canonical hand-authored spec.

### **Input B: TypeSpec-compiled Swagger**

- path: "../data-plane/Search/preview/2025-11-01-preview/search.json"

This file is generated by TypeSpec and represents the new canonical API description.

After merging Input A into a single spec and canonicalizing both A and B, we perform strict semantic comparison as
defined below.

---

# 1. Semantic Equivalency Contract

Two Swagger specifications are considered **semantically equivalent** if and only if:

> After canonicalization (removing documentation-only fields and ordering differences), the two Swagger files describe
> the **exact same API surface** and **the exact same request/response contract**.

Semantic equivalency is evaluated across three dimensions:

1. **Paths + HTTP methods**
2. **Operations** (parameters, request bodies, responses)
3. **Schemas / definitions**

Any mismatch in these dimensions means **not equivalent**.

---

# 2. Allowed Differences (Removed During Canonicalization)

The following elements do **not** affect API runtime behavior and must be removed or normalized before comparison.

## 2.1 Documentation Fields

These are ignored everywhere (root, operations, parameters, responses, schemas):

- `description`
- `summary`
- `externalDocs`

## 2.2 Example Fields

- `example`
- `examples`
- `x-ms-examples`

## 2.3 Tags (Non-behavioral)

- Top-level `tags`
- Per-operation `tags`

## 2.4 Documentation-only Vendor Extensions

We maintain a whitelist (expandable as needed):

- `x-ms-summary`
- Other doc-only `x-ms-*` fields

## 2.5 Ordering Differences

All orderings are ignored:

- JSON object key order
- Array order for set-like fields:
  - `consumes`
  - `produces`
  - `schemes`
  - `security`
  - Other set-like arrays as designated

These are canonicalized into sorted, deduplicated sets.

---

# 3. Required to Match Exactly

After canonicalization, all remaining fields represent the _true API contract_ and must match **exactly**.

## 3.1 Paths and Methods

- Path set must be identical.
- For each path, the HTTP method set must be identical (`GET`, `POST`, `PUT`, `DELETE`, etc.).

Any missing or extra path/method → **not equivalent**.

## 3.2 Operations

### 3.2.1 operationId

- Must match exactly, unless explicitly configured otherwise.

### 3.2.2 Parameters

Parameters are keyed by `(in, name)` (e.g., `("query", "api-version")`).

For each parameter:

- `in`
- `name`
- `required`
- Full schema for body parameters
- For non-body parameters:
  - `type`, `format`
  - Constraints:
    - `minimum`, `maximum`
    - `exclusiveMinimum`, `exclusiveMaximum`
    - `pattern`
    - `maxLength`, `minLength`
    - `maxItems`, `minItems`
    - `uniqueItems`
  - `enum` (must be exact match)
  - `default` (must match exactly)

Any mismatch → **not equivalent**.

### 3.2.3 Request Body

- Content types (`consumes`) must match.
- Body schema must match exactly.

### 3.2.4 Responses

- Status code set must match.
- For each status code:
  - Content types must match.
  - Response schema must match.
  - Response headers must match.

`description` is ignored, but everything else is strict.

---

# 4. Schema / Definition Equivalency

Schemas are compared recursively.
Two schemas are equivalent only when the following all match:

## 4.1 Core Schema Fields

- `type`
- `format`
  - No coercion: `integer` ≠ `number`, `int32` ≠ `int64`

## 4.2 Object Schemas

- Property sets must match exactly.
- Each property schema must be equivalent.
- `required` sets must match.
- `additionalProperties`:
  - Bool must match exactly, OR
  - Schema must match if present.

## 4.3 Array Schemas

- `items` schema must match.
- Array constraints must match:
  - `maxItems`, `minItems`, `uniqueItems`

## 4.4 Enums

- Enum sets must match exactly (ordering ignored).

## 4.5 References

- `$ref` values must match exactly.

## 4.6 Composed Schemas

(`allOf`, `oneOf`, `anyOf`)

- Component counts must match.
- Component schemas must match.
- Component sequences compared as lists or sorted sets (but consistently for both sides).

## 4.7 Definitions

- Definition name sets must match.
- Each definition’s schema must be equivalent.

---

# 5. Final Equivalency Rule

After canonicalization:

> **Two Swagger specs are semantically equivalent if and only if their canonical forms are deeply equal.**

If any difference is present in:

- paths
- methods
- parameters
- request bodies
- responses
- schemas
- definitions

then the specs are **not semantically equivalent**.

---

# Appendix: Why `openapi-diff` Cannot Be Used for This Comparison

We evaluated `openapi-diff` as a potential tool for equivalency checking and found it unsuitable for our needs
for three core reasons.

## A. `openapi-diff` is a structural diff tool, not a semantic comparator

- It reports _all_ differences between two specs.
- It does not understand our custom canonicalization rules.
- It cannot express the logic:
  - “ignore descriptions/tags/examples, but enforce strict equality on all behavioral fields.”

Even after we normalized descriptions/examples/tags in the hand-authored spec, `openapi-diff` continued reporting
structural differences irrelevant to our contract.

## B. Our comparison requires merging 3 legacy swagger files into 1

The original API surface is split across:

- `searchservice.json`
- `searchindex.json`
- `knowledgebases.json`

But TypeSpec generates a **single** Swagger file.

`openapi-diff` cannot model or validate this kind of “N-to-1 equivalence” without custom pre-processing,
and even after merging, its structural diff model remains incompatible with our rules.

## C. We need a deterministic pass/fail equivalence gate

For TypeSpec migration, we need:

- A clear boolean result: **equivalent / not equivalent**
- A small, human-readable list of meaningful differences:
  - Missing path
  - Missing GET operation
  - Mismatched schema field type

`openapi-diff` produces large, noisy diffs that do not correspond to our equivalency contract and cannot cleanly
serve as a migration gate.

Because of these constraints, we must implement a **custom semantic equivalency checker** that supports:

- Canonicalization of both specs
- Strict comparison of behavioral fields only
- Clean diff output for genuine contract mismatches
