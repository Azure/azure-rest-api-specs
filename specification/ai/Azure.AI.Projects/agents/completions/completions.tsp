import "../messages/messages.tsp";
import "../models.tsp";

namespace Azure.AI.Projects;

/**
 * Represents advanced options for controlling agent completions.
 */
@doc("Represents advanced options for controlling agent completions.")
model CompletionsOptions {
  /**
   * Strategy for truncating messages when input exceeds model limits.
   */
  @doc("Strategy for truncating messages when input exceeds model limits.")
  truncationStrategy?: TruncationStrategy;
}

/**
 * Describes how to truncate messages if they exceed model or provider limits.
 */
@doc("Describes how to truncate messages if they exceed model or provider limits.")
model TruncationStrategy {
  /**
   * The type of truncation strategy to apply.
   */
  @doc("The type of truncation strategy to apply.")
  type: "auto" | "lastMessages" | string;

  /**
   * The number of most recent messages to retain when using 'lastMessages' strategy.
   */
  @doc("The number of most recent messages to retain when using 'lastMessages' strategy.")
  lastMessages?: int32;
}

/**
 * Parameters for creating a new completion request.
 */
@doc("Parameters for creating a new completion request.")
model CompleteParams {
  /**
   * The agent responsible for generating the completion.
   */
  @doc("The agent responsible for generating the completion.")
  agent: AgentOptions;

  /**
   * The list of input messages for the completion.
   */
  @doc("The list of input messages for the completion.")
  input: ChatMessage[];

  /**
   * Optional identifier for an existing conversation thread.
   */
  @doc("Optional identifier for an existing conversation thread.")
  threadId?: string;

  /**
   * Optional metadata associated with the completion request.
   */
  @doc("Optional metadata associated with the completion request.")
  metadata?: Record<string>;

  /**
   * Optional configuration for completion generation.
   */
  @doc("Optional configuration for completion generation.")
  options?: CompletionsOptions;

  /**
   * Identifier for the user making the request.
   */
  @doc("Identifier for the user making the request.")
  userId?: string;

  /**
   * Flag indicating whether to store the completion and associated messages.
   */
  @doc("Flag indicating whether to store the completion and associated messages.")
  store?: boolean;
}

/**
 * Parameters for creating a new completion with agent overrides.
 */
@doc("Parameters for creating a new completion with agent overrides.")
model AgentCompleteParams {
  /**
   * The overrides for the agent responsible for generating the completion.
   */
  @doc("The overrides for the agent responsible for generating the completion.")
  overrides: AgentOptions;

  /**
   * The list of input messages for the completion.
   */
  @doc("The list of input messages for the completion.")
  input: ChatMessage[];

  /**
   * Optional identifier for an existing conversation thread.
   */
  @doc("Optional identifier for an existing conversation thread.")
  threadId?: string;

  /**
   * Optional metadata associated with the completion request.
   */
  @doc("Optional metadata associated with the completion request.")
  metadata?: Record<string>;

  /**
   * Optional configuration for completion generation.
   */
  @doc("Optional configuration for completion generation.")
  options?: CompletionsOptions;

  /**
   * Identifier for the user making the request.
   */
  @doc("Identifier for the user making the request.")
  userId?: string;

  /**
   * Flag indicating whether to store the completion and associated messages.
   */
  @doc("Flag indicating whether to store the completion and associated messages.")
  store?: boolean;
}

/**
 * Detailed token usage data for a completion request.
 */
@doc("Detailed token usage data for a completion request.")
model CompletionUsage {
  /**
   * Number of completion tokens used over the course of the run step.
   */
  @doc("Number of completion tokens used over the course of the run step.")
  outputTokens: int64;

  /**
   * Number of prompt tokens used over the course of the run step.
   */
  @doc("Number of prompt tokens used over the course of the run step.")
  inputTokens: int64;

  /**
   * Total number of tokens used (prompt + completion).
   */
  @doc("Total number of tokens used (prompt + completion).")
  totalTokens: int64;

  /**
   * Details of the prompt tokens.
   */
  @doc("Details of the prompt tokens.")
  inputTokenDetails?: {
    /**
     * The number of cached prompt tokens.
     */
    @doc("The number of cached prompt tokens.")
    cachedTokens?: int32;
  };

  /**
   * Breakdown of tokens used in a completion.
   */
  @doc("Breakdown of tokens used in a completion.")
  outputTokenDetails?: {
    /**
     * Tokens generated by the model for reasoning.
     */
    @doc("Tokens generated by the model for reasoning.")
    reasoningTokens?: int32;
  };
}

/**
 * A streaming operation describing how to modify a partial response in real-time.
 */
@doc("A streaming operation describing how to modify a partial response in real-time.")
model StreamingOperation {
  /**
   * The type of operation being performed.
   */
  @doc("The type of operation being performed.")
  type: "append" | "remove" | "replace" | "set" | string;

  /**
   * The JSON path to the operation.
   */
  @doc("The JSON path to the operation.")
  jsonPath: string;

  /**
   * The value to apply to the operation, expressed as a JSON-compatible type.
   *
   * Here we use JSONAny from models.tsp to ensure we don't use 'unknown'.
   */
  @doc("The value to apply to the operation, expressed as a JSON-compatible type.")
  value?: JSONAny;
}

/**
 * A streaming update indicating incremental changes to an agent-generated completion.
 */
@doc("A streaming update indicating incremental changes to an agent-generated completion.")
model StreamingAgentCompletionUpdate {
  /**
   * Identifier of the message being updated.
   */
  @doc("Identifier of the message being updated.")
  messageId: string;

  /**
   * Optional name of the message author.
   */
  @doc("Optional name of the message author.")
  authorName?: string;

  /**
   * Role of the author for the updated message.
   */
  @doc("Role of the author for the updated message.")
  authorRole?: AuthorRole;

  /**
   * Optional content updates from the AI.
   */
  @doc("Optional content updates from the AI.")
  update?: StreamingOperation;

  /**
   * Token usage information associated with this streaming update.
   */
  @doc("Token usage information associated with this streaming update.")
  usage: CompletionUsage;
}

/**
 * An agent-generated completion record, including messages and status.
 */
@doc("An agent-generated completion record, including messages and status.")
model AgentCompletion {
  /**
   * Unique identifier for the agent responsible for the completion.
   */
  @doc("Unique identifier for the agent responsible for the completion.")
  agentId: string;

  /**
   * Unique identifier for this completion.
   */
  @doc("Unique identifier for this completion.")
  completionId: string;

  /**
   * Timestamp when the completion was initiated (Unix time).
   */
  @doc("Timestamp when the completion was initiated (Unix time).")
  createdAt: safeint;

  /**
   * Timestamp when the completion finished processing (Unix time).
   */
  @doc("Timestamp when the completion finished processing (Unix time).")
  completedAt: safeint;

  /**
   * Final status of the completion request.
   */
  @doc("Final status of the completion request.")
  status:
    | "inProgress"
    | "incomplete"
    | "cancelled"
    | "failed"
    | "completed"
    | string;

  /**
   * List of output messages generated by the agent.
   */
  @doc("List of output messages generated by the agent.")
  output: ChatMessage[];

  /**
   * Identifier for the thread associated with the completion.
   */
  @doc("Identifier for the thread associated with the completion.")
  threadId: string;

  /**
   * Token usage details for this completion.
   */
  @doc("Token usage details for this completion.")
  usage: CompletionUsage;

  /**
   * Details about why the response is incomplete, if applicable.
   */
  @doc("Details about why the response is incomplete, if applicable.")
  incompleteDetails: {
    /**
     * Reason describing why the response is incomplete.
     */
    reason: string;
  };
}
