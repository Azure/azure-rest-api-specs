import "@azure-tools/typespec-azure-core";
import "@typespec/rest";
import "@typespec/streams";
import "@typespec/versioning";
import "../models.tsp";

using TypeSpec.Rest;
using TypeSpec.Http;

namespace Azure.AI.Projects;

@doc("An abstract representation of a structured content item within a chat message.")
@discriminator("type")
model AIContent {
  type: string;
}

@doc("Annotations applied to parts of the message or content.")
model Annotations {
  @doc("The type of annotation.")
  type: string;

  @doc("The tool call ID associated with the annotation.")
  ToolCallId?: string;

  @doc("The JSON path associated with the annotation.")
  jsonPath?: string;

  @doc("The URL associated with the annotation.")
  url?: string;

  @doc("The start position of the annotation.")
  start?: int32;

  @doc("The end position of the annotation.")
  end?: int32;
}

@doc("A structured chat content item containing plain text.")
model TextContent extends AIContent {
  type: "text";

  @doc("The text content.")
  text: string;

  @doc("A list of annotations in the text content.")
  annotations?: Annotations[];
}

@doc("A structured chat content item containing model refusal information for a structured outputs request.")
model RefusalContent extends AIContent {
  type: "refusal";

  @doc("Reason for refusal.")
  refusal: string;
}

@doc("A structured chat content item containing a content filter.")
model ContentFilterContent extends AIContent {
  type: "contentFilter";

  @doc("Content filter data.")
  contentFilter: string;

  @doc("Whether content was flagged/detected.")
  detected: boolean;
}

@doc("A base content block for referencing file-like or binary data.")
model BinaryContent<Properties extends Reflection.Model> extends AIContent {
  ...Properties;

  @doc("The file name for this binary content.")
  fileName?: string;

  @doc("The MIME type for this binary content.")
  mimeType?: string;

  @doc("URI where the binary content can be retrieved.")
  uri?: url;

  @doc("Data URI containing the binary content inlined.")
  dataUri?: url;

  @doc("Raw bytes for the binary content.")
  data?: bytes;
}

@doc("A structured chat content item containing a file data item.")
model FileContent
  is BinaryContent<{
    type: "file";
  }>;

@doc("A structured chat content item containing an image reference.")
model ImageContent
  is BinaryContent<{
    type: "image";

    @doc("Width of the image in pixels (optional).")
    width?: int16;

    @doc("Height of the image in pixels (optional).")
    height?: int16;
  }>;

@doc("A structured chat content item containing an audio reference.")
model AudioContent
  is BinaryContent<{
    type: "audio";

    @doc("Duration of audio in seconds (optional).")
    duration?: int16;
  }>;

@doc("A structured chat content item containing a video reference.")
model VideoContent
  is BinaryContent<{
    type: "video";

    @doc("Duration of video in seconds (optional).")
    duration?: int16;

    @doc("Width of video in pixels (optional).")
    width?: int16;

    @doc("Height of video in pixels (optional).")
    height?: int16;
  }>;

@doc("A structured chat content item describing a tool call request.")
model ToolCallContent extends AIContent {
  type: "toolCall";

  @doc("The name of the tool to call.")
  name: string;

  @doc("The unique ID of the tool call.")
  toolCallId: string;

  @doc("Arguments passed to this tool call, expressed as JSON-like data rather than `unknown`.")
  arguments?: JSONAny;
}

@doc("A structured chat content item describing a tool result.")
model ToolResultContent extends AIContent {
  type: "toolResult";

  @doc("The ID of the tool call to which this result pertains.")
  toolCallId: string;

  @doc("The results returned from the tool, using JSONAny instead of `unknown`.")
  results?: JSONAny;
}

@doc("Possible roles of the message author.")
union AuthorRole {
  user: "user",
  agent: "agent",
  system: "system",
  tool: "tool",
  developer: "developer",
  string,
}

@Rest.resource("message")
@Rest.parentResource(Thread)
@discriminator("role")
@doc("A base model for representing a chat message.")
model ChatMessage {
  @doc("The ID of the user who created the message (if applicable).")
  userId?: string;

  @doc("The ID of the agent who created the message (if applicable).")
  agentId?: string;

  @doc("A unique identifier for this message.")
  @key
  @visibility(Lifecycle.Read)
  messageId: string;

  @doc("A unique run ID, if this message was generated by a run process.")
  agentRunId?: string;

  @doc("The thread to which this message belongs.")
  @visibility(Lifecycle.Read)
  threadId: string;

  @doc("The role of this message's author.")
  role?: AuthorRole = "user";

  @doc("The contents of the message.")
  content: AIContent[];

  @doc("An optional display name for the author.")
  authorName?: string;

  @doc("The timestamp (in Unix time) when this message was created.")
  createdAt?: int64;

  @doc("The timestamp (in Unix time) when this message was completed, if applicable.")
  completedAt?: int64;
}

#suppress "@azure-tools/typespec-autorest/union-unsupported" "We intentionally use a union for OAS 3."
@doc("A user message within a chat, always with the 'user' role.")
model UserMessage extends ChatMessage {
  @doc("Always 'user' for user messages.")
  role: AuthorRole.user;

  @doc("The contents of the user message.")
  content: (
    | TextContent
    | ImageContent
    | AudioContent
    | VideoContent
    | FileContent)[];
}

@doc("A developer message within a chat, always with the 'developer' role.")
model DeveloperMessage extends ChatMessage {
  @doc("Always 'developer' for developer messages.")
  role: AuthorRole.developer;

  @doc("The contents of the developer message.")
  content: TextContent[];
}

#suppress "@azure-tools/typespec-autorest/union-unsupported" "We intentionally use a union for OAS 3."
@doc("An agent message within a chat, always with the 'agent' role.")
model AgentMessage extends ChatMessage {
  @doc("Always 'agent' for agent messages.")
  role: AuthorRole.agent;

  @doc("The contents of the agent message.")
  content: (
    | TextContent
    | RefusalContent
    | ContentFilterContent
    | ImageContent
    | AudioContent
    | VideoContent
    | FileContent
    | ToolCallContent)[];
}

@doc("A system message within a chat, always with the 'system' role.")
model SystemMessage extends ChatMessage {
  @doc("Always 'system' for system messages.")
  role: AuthorRole.system;

  @doc("The contents of the system message.")
  content: TextContent[];
}

@doc("A tool message within a chat, always with the 'tool' role.")
model ToolMessage extends ChatMessage {
  @doc("Always 'tool' for tool messages.")
  role: AuthorRole.tool;

  @doc("The contents of the tool message.")
  content: ToolResultContent[];
}

@doc("Represents a chat thread, which can contain multiple messages.")
@resource("threads")
model Thread {
  @doc("A unique identifier for this thread.")
  @key
  @visibility(Lifecycle.Read)
  threadId: string;

  @doc("A list of messages in this thread.")
  messages: ChatMessage[];
}
