import "@azure-tools/typespec-client-generator-core";

import "./main.tsp";

using Azure.ClientGenerator.Core;

#suppress "@azure-tools/typespec-azure-core/casing-style" "OpenAI is a case-sensitive name"
@TypeSpec.Versioning.versioned(Azure.AI.OpenAI.Assistants.ServiceApiVersions)
namespace Azure.AI.OpenAI.Assistants;

// Trivial response value containers should treat these containers as internal details and instead surface a shimmed
// operation that exposes the underlying data directly.
@@projectedName(AssistantDeletionStatus,
  "csharp",
  "InternalAssistantDeletionStatus"
);
@@projectedName(deleteAssistant, "csharp", "InternalDeleteAssistant");
@@projectedName(AssistantFileDeletionStatus,
  "csharp",
  "InternalAssistantFileDeletionStatus"
);
@@projectedName(deleteAssistantFile, "csharp", "InternalUnlinkAssistantFile");
@@projectedName(deleteThread, "csharp", "InternalDeleteThread");
@@projectedName(listAssistants, "csharp", "InternalGetAssistants");
@@projectedName(listAssistantFiles, "csharp", "InternalGetAssistantFiles");
@@projectedName(listMessageFiles, "csharp", "InternalGetMessageFiles");
@@projectedName(listRunSteps, "csharp", "InternalGetRunSteps");
@@projectedName(listMessages, "csharp", "InternalGetMessages");
@@projectedName(listRuns, "csharp", "InternalGetRuns");
@@projectedName(FileListResponse, "csharp", "InternalFileListResponse");
@@projectedName(listFiles, "csharp", "InternalListFiles");
@@projectedName(FileDeletionStatus, "csharp", "InternalFileDeletionStatus");
@@projectedName(deleteFile, "csharp", "InternalDeleteFile");

// In addition to top-level response value containers, trivial intermediate structure -- levels of single-use model
// hierarchy that don't convey explanatory or functional benefit to consumers of the surface -- should also be
// internalized and merged into the more useful top-level type.

// FunctionToolDefinition: merge FunctionDefinition structure to recast e.g. toolDefinition.function.name into
// toolDefinition.name

@@access(FunctionDefinition, Access.internal);
@@projectedName(FunctionDefinition, "csharp", "InternalFunctionDefinition");
@@projectedName(FunctionToolDefinition.function, "csharp", "InternalFunction");

// SubmitToolOutputsAction: include .tool_calls directly rather than via an intermediate .details.

@@access(SubmitToolOutputsDetails, Access.internal);
@@projectedName(SubmitToolOutputsDetails,
  "csharp",
  "InternalSubmitToolOutputsDetails"
);
@@projectedName(SubmitToolOutputsAction.submitToolOutputs,
  "csharp",
  "InternalDetails"
);

// FunctionToolCall: include name/arguments directly

@@access(FunctionToolCallDetails, Access.internal);
@@projectedName(FunctionToolCallDetails,
  "csharp",
  "InternalFunctionToolCallDetails"
);
@@projectedName(FunctionToolCall.function, "csharp", "InternalDetails");

// CodeInterpreterToolCall: include input/outputs directly

@@access(CodeInterpreterToolCallDetails, Access.internal);
@@projectedName(CodeInterpreterToolCallDetails,
  "csharp",
  "InternalCodeInterpreterToolCallDetails"
);
@@projectedName(CodeInterpreterToolCall.codeInterpreter,
  "csharp",
  "InternalDetails"
);

// MessageTextContent: text/annotations can also merge

@@access(MessageTextDetails, Access.internal);
@@projectedName(MessageTextDetails, "csharp", "InternalMessageTextDetails");
@@projectedName(MessageTextContent.text, "csharp", "InternalDetails");

// MessageFileCitationTextAnnotation: file_id/quote don't need another type

@@access(MessageTextFileCitationDetails, Access.internal);
@@projectedName(MessageTextFileCitationDetails,
  "csharp",
  "InternalMessageTextFileCitationDetails"
);
@@projectedName(MessageFileCitationTextAnnotation.fileCitation,
  "csharp",
  "InternalDetails"
);

// MessageFilePathTextAnnotation: file_id doesn't need a separate details client type

@@access(MessageFilePathDetails, Access.internal);
@@projectedName(MessageFilePathDetails,
  "csharp",
  "InternalMessageFilePathDetails"
);
@@projectedName(MessageFilePathTextAnnotation.filePath,
  "csharp",
  "InternalDetails"
);

// MessageImageFileContent: *two* levels of intermediate structure can be squashed to bring file_id to the parent
// type. Per earlier precedent with image generation, even the introduction of more image file representations (e.g.
// base64) are better accomplished via another approach at the client layer.

@@access(MessageImageFileDetails, Access.internal);
@@access(MessageImageFileIdDetails, Access.internal);
@@projectedName(MessageImageFileDetails,
  "csharp",
  "InternalMessageImageFileDetails"
);
@@projectedName(MessageImageFileContent.imageFile, "csharp", "InternalDetails");
@@projectedName(MessageImageFileIdDetails,
  "csharp",
  "InternalMessageImageFileIdDetails"
);
@@projectedName(MessageImageFileDetails.fileId, "csharp", "InternalDetails");

// Several of the content item types are not intended to be used as input

@@usage(MessageTextContent, Usage.output);
@@usage(MessageImageFileContent, Usage.output);
@@usage(MessageTextContent, Usage.output);
@@usage(MessageFileCitationTextAnnotation, Usage.output);
@@usage(MessageFilePathTextAnnotation, Usage.output);

// Ensure some shared types remain public despite interaction with previously internalized details

@@access(MessageFilePathTextAnnotation, Access.public);
@@access(MessageFileCitationTextAnnotation, Access.public);
@@usage(FilePurpose, Usage.input | Usage.output);
@@usage(ListSortOrder, Usage.input | Usage.output);

// Additional, language-specific idiomatic renames

@@projectedName(OpenAIFile, "csharp", "OpenAIFile");
@@projectedName(OpenAIFile.bytes, "csharp", "Size");
@@projectedName(FilePurpose, "csharp", "OpenAIFilePurpose");
@@projectedName(ThreadMessage.content, "csharp", "ContentItems");
@@projectedName(MessageTextDetails.value, "csharp", "Text");
@@projectedName(CreateAndRunThreadOptions.`model`,
  "csharp",
  "OverrideModelName"
);
@@projectedName(CreateAndRunThreadOptions.instructions,
  "csharp",
  "OverrideInstructions"
);
@@projectedName(CreateAndRunThreadOptions.tools, "csharp", "OverrideTools");
// From https://platform.openai.com/docs/assistants/how-it-works
// "Note that deleting an AssistantFile doesnâ€™t delete the original File object, it simply deletes the association
// between that File and the Assistant."
@@projectedName(createAssistantFile, "csharp", "LinkAssistantFile");
// 'Unlink' counterpart already renamed for DeletionStatus merge
