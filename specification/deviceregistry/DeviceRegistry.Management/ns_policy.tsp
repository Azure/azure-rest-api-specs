import "@typespec/http";
import "@typespec/rest";
import "@typespec/versioning";
import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-azure-resource-manager";

using TypeSpec.Http;
using TypeSpec.Rest;
using TypeSpec.Versioning;
using Azure.ResourceManager;
using Azure.Core;

namespace Microsoft.DeviceRegistry;

@added(Versions.v2025_02_01)
@doc("A Credential Policy")
@parentResource(Credential)
model Policy is TrackedResource<PolicyProperties> {
  @doc("The name of the Policy tracked resource.")
  @minLength(3)
  @maxLength(63)
  @pattern("^[0-9a-zA-Z][a-zA-Z0-9-]*$")
  @key("policyName")
  @segment("policies")
  @path
  name: string;
}

@added(Versions.v2025_02_01)
@doc("Details of the Credential Policy.")
model PolicyProperties {
  @visibility(Lifecycle.Read)
  @doc("The status of the last operation.")
  provisioningState?: ProvisioningState;

  @doc("The certificate configuration.")
  certificate?: CertificateConfiguration;

  @doc("The Bring Your Own Certificate Authority (BYOCA) configuration.")
  bringYourOwnCertificateAuthority?: BringYourOwnCertificateAuthority;
}

@added(Versions.v2025_02_01)
@doc("The certificate configuration.")
model CertificateConfiguration {
  @doc("The configuration to set up an ICA.")
  certificateAuthorityConfiguration: CertificateAuthorityConfiguration;

  @doc("The leaf certificate configuration.")
  leafCertificateConfiguration: LeafCertificateConfiguration;
}

@added(Versions.v2025_02_01)
@doc("The configuration to set up an ICA.")
model CertificateAuthorityConfiguration {
  @doc("Crypto type: ECC.")
  @visibility(Lifecycle.Create, Lifecycle.Read)
  keyType: SupportedKeyType;

  @doc("Certificate subject.")
  @visibility(Lifecycle.Read)
  subject?: string;

  @doc("Certificate is valid not before this date. Format ISO8601. Generated based on on validity period.")
  @visibility(Lifecycle.Read)
  validityNotBefore?: utcDateTime;

  @doc("Certificate is valid not after this date. Format ISO8601. Generated based on validity period.")
  @visibility(Lifecycle.Read)
  validityNotAfter?: utcDateTime;
}

@added(Versions.v2025_02_01)
@doc("Supported key types.")
union SupportedKeyType {
  string,

  @doc("Indicates the ECC key type.")
  ECC: "ECC",
}

@added(Versions.v2025_02_01)
@doc("The leaf certificate configuration.")
model LeafCertificateConfiguration {
  @doc("The validity period in days.")
  @minValue(7)
  @maxValue(90)
  validityPeriodInDays: int32;
}

@added(Versions.v2025_02_01)
@doc("Configuration for Bring Your Own Certificate Authority (BYOCA). When enabled, customers provide their own CA-signed certificates instead of using the service-managed CA.")
model BringYourOwnCertificateAuthority {
  @doc("Indicates whether BYOCA is enabled for this policy. This can only be set at creation time and cannot be changed afterward.")
  @visibility(Lifecycle.Create, Lifecycle.Read)
  enabled: boolean;

  @doc("The Certificate Signing Request (CSR) in PEM format generated by the service. The customer must use this CSR to obtain a signed certificate from their own CA.")
  @visibility(Lifecycle.Read)
  certificateSigningRequest?: string;

  @doc("The signed certificate in PEM format provided by the customer. This certificate must be signed by the customer's CA using the CSR provided by the service.")
  signedCertificate?: string;

  @doc("The certificate chain in PEM format provided by the customer. This should include all intermediate certificates up to the root CA.")
  certificateChain?: string;

  @doc("The status of the BYOCA configuration, indicating the current state of the certificate lifecycle.")
  @visibility(Lifecycle.Read)
  status?: BringYourOwnCertificateAuthorityStatus;

  @doc("Details about the certificate revocation. Only populated when status is 'Revoked'.")
  @visibility(Lifecycle.Read)
  revocationDetails?: RevocationDetails;
}

@added(Versions.v2025_02_01)
@doc("Status of the Bring Your Own Certificate Authority (BYOCA) configuration.")
union BringYourOwnCertificateAuthorityStatus {
  string,

  @doc("The CSR has been generated and is waiting for the customer to provide the signed certificate.")
  PendingActivation: "PendingActivation",

  @doc("The signed certificate has been successfully uploaded and validated, and the CA is active.")
  Active: "Active",

  @doc("The certificate is nearing expiration or has expired, and a new CSR has been generated. Waiting for the customer to provide a new signed certificate.")
  PendingRotation: "PendingRotation",

  @doc("The certificate activation or rotation has failed. Check error details for more information.")
  Failed: "Failed",

  @doc("The certificate has been revoked and is no longer valid for issuing leaf certificates.")
  Revoked: "Revoked",
}

@added(Versions.v2025_02_01)
@doc("Reasons for certificate revocation.")
union RevocationReason {
  string,

  @doc("The certificate's private key has been compromised.")
  KeyCompromise: "KeyCompromise",

  @doc("The Certificate Authority's private key has been compromised.")
  CACompromise: "CACompromise",

  @doc("The certificate is no longer needed for its original purpose.")
  CessationOfOperation: "CessationOfOperation",

  @doc("The certificate has been superseded by a new certificate.")
  Superseded: "Superseded",

  @doc("The reason for revocation is not specified.")
  Unspecified: "Unspecified",
}

@added(Versions.v2025_02_01)
@doc("Details about the certificate revocation.")
model RevocationDetails {
  @doc("The timestamp when the certificate was revoked. Format ISO8601.")
  @visibility(Lifecycle.Read)
  revokedAt: utcDateTime;

  @doc("The reason for certificate revocation.")
  @visibility(Lifecycle.Read)
  reason: RevocationReason;

  @doc("Optional additional information about the revocation.")
  @visibility(Lifecycle.Read)
  additionalInfo?: string;
}

@added(Versions.v2025_02_01)
@doc("Request payload for certificate revocation.")
model RevokeCertificateRequest {
  @doc("The reason for revoking the certificate.")
  reason: RevocationReason;

  @doc("Optional additional information about the revocation.")
  additionalInfo?: string;
}

@added(Versions.v2025_02_01)
@armResourceOperations
interface Policies {
  get is ArmResourceRead<Policy>;
  createOrUpdate is ArmResourceCreateOrUpdateAsync<Policy>;
  delete is ArmResourceDeleteWithoutOkAsync<Policy>;
  // Using 'ArmCustomPatchAsync' instead of 'ArmResourcePatchAsync' to define the correct patch payload for the resource.
  // This is a workaround to fix the patch payload that otherwise will expose the 'location' field (not present in patch),
  // since otherwise it extends the ARM TrackedResource type.
  @patch(#{ implicitOptionality: true })
  update is ArmCustomPatchAsync<
    Policy,
    Azure.ResourceManager.Foundations.ResourceUpdateModel<
      Policy,
      PolicyProperties
    >
  >;
  listByResourceGroup is ArmResourceListByParent<Policy>;

  @doc("Revokes the BYOCA certificate for this policy.")
  @action("revokeCertificate")
  @armResourceAction(Policy)
  @post
  revokeCertificate(
    ...ResourceInstanceParameters<Policy>,
    @doc("The revocation request payload.")
    @body
    body: RevokeCertificateRequest
  ): ArmResponse<Policy> | ErrorResponse;
}
