import "@typespec/http";
import "@typespec/rest";
import "@typespec/versioning";
import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-azure-resource-manager";

using TypeSpec.Http;
using TypeSpec.Rest;
using TypeSpec.Versioning;
using Azure.ResourceManager;
using Azure.Core;

namespace Microsoft.DeviceRegistry;

@added(Versions.v2025_11_01_preview)
@removed(Versions.v2026_03_01_preview)
@renamedFrom(Versions.v2026_03_01_preview, "Policy")
@doc("A Credential Policy")
@parentResource(Credential)
model PolicyV1 is TrackedResource<PolicyProperties> {
  @doc("The name of the Policy tracked resource.")
  @minLength(3)
  @maxLength(63)
  @pattern("^[0-9a-zA-Z][a-zA-Z0-9-]*$")
  @key("policyName")
  @segment("policies")
  @path
  name: string;
}

@added(Versions.v2026_03_01_preview)
@doc("A Credential Policy")
@parentResource(Credential)
model Policy is ProxyResource<PolicyProperties> {
  @doc("The name of the Policy proxy resource.")
  @minLength(3)
  @maxLength(63)
  @pattern("^[0-9a-zA-Z][a-zA-Z0-9-]*$")
  @key("policyName")
  @segment("policies")
  @path
  name: string;
}

@added(Versions.v2025_11_01_preview)
@doc("Details of the Credential Policy.")
model PolicyProperties {
  @visibility(Lifecycle.Read)
  @doc("The status of the last operation.")
  provisioningState?: ProvisioningState;

  @doc("The certificate configuration.")
  certificate?: CertificateConfiguration;
}

@added(Versions.v2025_11_01_preview)
@doc("The certificate configuration.")
model CertificateConfiguration {
  @doc("The configuration to set up an ICA.")
  certificateAuthorityConfiguration: CertificateAuthorityConfiguration;

  @doc("The leaf certificate configuration.")
  leafCertificateConfiguration: LeafCertificateConfiguration;
}

@added(Versions.v2025_11_01_preview)
@doc("The configuration to set up an ICA.")
model CertificateAuthorityConfiguration {
  @doc("Crypto type: ECC.")
  @visibility(Lifecycle.Create, Lifecycle.Read)
  keyType: SupportedKeyType;

  @doc("Certificate subject.")
  @visibility(Lifecycle.Read)
  subject?: string;

  @doc("Certificate is valid not before this date. Format ISO8601. Generated based on on validity period.")
  @visibility(Lifecycle.Read)
  validityNotBefore?: utcDateTime;

  @doc("Certificate is valid not after this date. Format ISO8601. Generated based on validity period.")
  @visibility(Lifecycle.Read)
  validityNotAfter?: utcDateTime;

  @added(Versions.v2026_03_01_preview)
  @doc("Configuration for Bring Your Own Root.")
  bringYourOwnRoot?: BringYourOwnRoot;
}

@added(Versions.v2026_03_01_preview)
@doc("Configuration for Bring Your Own Root. When enabled, customers provide their own CA-signed certificates instead of using the service-managed CA.")
model BringYourOwnRoot {
  @doc("Indicates whether Bring Your Own Root is enabled. This can only be set at creation time and cannot be changed afterward.")
  @visibility(Lifecycle.Create, Lifecycle.Read)
  enabled: boolean;

  @doc("Certificate Signing Request (CSR) in PEM format, generated by the service. Sign this CSR with your Certificate Authority and activate via the activateBringYourOwnRoot action. A new CSR is generated at policy creation and when certificates near expiration.")
  @visibility(Lifecycle.Read)
  certificateSigningRequest?: string;

  @doc("Thumbprint of the issuing certificate.")
  @visibility(Lifecycle.Read)
  issuingCertificateThumbprint?: string;

  @doc("The status of the Bring Your Own Root configuration, indicating the current state of the certificate lifecycle.")
  @visibility(Lifecycle.Read)
  status?: BringYourOwnRootStatus;
}

@added(Versions.v2025_11_01_preview)
@doc("Supported key types.")
union SupportedKeyType {
  string,

  @doc("Indicates the ECC key type.")
  ECC: "ECC",
}

@added(Versions.v2025_11_01_preview)
@doc("The leaf certificate configuration.")
model LeafCertificateConfiguration {
  @doc("The validity period in days.")
  @minValue(7)
  @maxValue(90)
  validityPeriodInDays: int32;
}

@added(Versions.v2026_03_01_preview)
@doc("Status of the Bring Your Own Root configuration.")
union BringYourOwnRootStatus {
  string,

  @doc("The CSR has been generated and is waiting for the customer to provide the signed certificate.")
  PendingActivation: "PendingActivation",

  @doc("The signed certificate has been successfully uploaded and validated, and the CA is active.")
  Active: "Active",

  @doc("The certificate is nearing expiration (within renewal window) or has expired. A new CSR has been generated and is waiting for the customer to provide a new signed certificate.")
  ActiveButPendingRenewal: "ActiveButPendingRenewal",
}

@added(Versions.v2026_03_01_preview)
@doc("Request payload for activating a Bring Your Own Root policy with a customer-provided signed certificate.")
model ActivateBringYourOwnRootRequest {
  @doc("Certificate chain in PEM format, including the signed certificate. The first certificate must be the signed certificate (matching the CSR generated by the service), followed by any intermediate CAs, and optionally the root CA. Certificates must be ordered from leaf to root and concatenated in PEM format.")
  certificateChain: string;
}

@added(Versions.v2026_03_01_preview)
@armResourceOperations(Policy)
interface Policies {
  @sharedRoute
  get is ArmResourceRead<Policy>;
  @sharedRoute
  createOrUpdate is ArmResourceCreateOrUpdateAsync<Policy>;
  @sharedRoute
  delete is ArmResourceDeleteWithoutOkAsync<Policy>;
  @sharedRoute
  @patch(#{ implicitOptionality: true })
  update is ArmCustomPatchAsync<
    Policy,
    Azure.ResourceManager.Foundations.ResourceUpdateModel<
      Policy,
      PolicyProperties
    >
  >;
  @sharedRoute
  listByResourceGroup is ArmResourceListByParent<Policy>;
  #suppress "@azure-tools/typespec-azure-resource-manager/arm-post-operation-response-codes" "lintdiff issue"
  revokeIssuer is ArmResourceActionNoContentAsync<Policy, void>;
  #suppress "@azure-tools/typespec-azure-resource-manager/arm-post-operation-response-codes" "lintdiff issue"
  @doc("Activates or renews a Bring Your Own Root policy by accepting a customer-provided signed certificate. This is a long-running operation that returns no content upon completion.")
  activateBringYourOwnRoot is ArmResourceActionNoContentAsync<
    Policy,
    ActivateBringYourOwnRootRequest
  >;
}

@added(Versions.v2025_11_01_preview)
@removed(Versions.v2026_03_01_preview)
@renamedFrom(Versions.v2026_03_01_preview, "Policies")
@armResourceOperations(PoliciesV1)
interface PoliciesV1 {
  @sharedRoute
  get is ArmResourceRead<PolicyV1>;
  @sharedRoute
  createOrUpdate is ArmResourceCreateOrUpdateAsync<PolicyV1>;
  @sharedRoute
  delete is ArmResourceDeleteWithoutOkAsync<PolicyV1>;
  // Using 'ArmCustomPatchAsync' instead of 'ArmResourcePatchAsync' to define the correct patch payload for the resource.
  // This is a workaround to fix the patch payload that otherwise will expose the 'location' field (not present in patch),
  // since otherwise it extends the ARM TrackedResource type.
  @sharedRoute
  @patch(#{ implicitOptionality: true })
  update is ArmCustomPatchAsync<
    PolicyV1,
    Azure.ResourceManager.Foundations.ResourceUpdateModel<
      PolicyV1,
      PolicyProperties
    >
  >;
  @sharedRoute
  listByResourceGroup is ArmResourceListByParent<PolicyV1>;
}
