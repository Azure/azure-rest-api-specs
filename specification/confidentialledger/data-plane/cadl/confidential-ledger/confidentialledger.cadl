import "@cadl-lang/rest";
import "@azure-tools/cadl-azure-core";
import "@azure-tools/cadl-autorest";

using Cadl.Http;
using Cadl.Rest;
using Azure.Core;
using OpenAPI;

//
// ** Service description **
//

// TODO: Use `Uri` type when available: https://github.com/microsoft/cadl/issues/654
@serviceTitle("Confidential Ledger Service")
@serviceVersion("2022-05-13")
@server(
  "{ledgerUri}",
  "Confidential Ledger Service",
  {
    ledgerUri: string,
  }
)
namespace Azure.Security.ConfidentialLedger;

//
// ** Parameter descriptions **
//

model CollectionIdParameter {
  @query
  @doc("The collection id.")
  collectionId?: string;
}

model TransactionIdParameter {
  // TODO: update definition so this parameter comes from KeysOf in operation, when model support is added.
  @path
  @doc("Identifies a write transaction.")
  transactionId: string;
}

model TransactionIdFromParameter {
  @query
  @doc("Specify the first transaction ID in a range.")
  fromTransactionId?: string;
}

model TransactionIdToParameter {
  @query
  @doc("Specify the last transaction ID in a range.")
  toTransactionId?: string;
}

model UserDetailsParameter {
  @body
  @doc("Details about a Confidential Ledger user.")
  userDetails: LedgerUser;
}

model UserDetailsParameterForPatch {
  @body
  @doc("Details about a Confidential Ledger user.")
  userDetails: LedgerUser;

  @header("content-type")
  contentType: "application/merge-patch+json";
}

model UserIdParameter {
  @path
  @doc("The user id, either an AAD object ID or certificate fingerprint.")
  @extension("x-ms-skip-url-encoding", true)
  userId: string;
}

//
// ** Model descriptions **
//

@doc("Identifier for collections.")
model Collection {
  @doc("Id of the collection")
  collectionId: string;
}

@doc("Information about the enclaves running the Confidential Ledger.")
model ConfidentialLedgerEnclaves {
  @doc("Id of the Confidential Ledger node responding to the request.")
  currentNodeId: string;

  enclaveQuotes: Record<EnclaveQuote>;
}

@doc("List of members in the consortium.")
model Consortium {
  @doc("List of members in the consortium")
  members: ConsortiumMember[];

  @doc("URI from which to retrieve the next page of results.")
  nextLink?: string;
}

@doc("Describes a member of the consortium.")
model ConsortiumMember {
  @doc("PEM-encoded certificate associated with the member.")
  certificate: string;

  @doc("Identifier assigned to the member.")
  id: string;
}

@doc("The governance script for the application.")
model Constitution {
  @doc("SHA256 digest of the constitution script.")
  digest: string;

  @doc("Contents of the constitution.")
  script: string;
}

@doc("Contains the enclave quote.")
model EnclaveQuote {
  @doc("Id assigned to this node.")
  nodeId: string;

  @doc("MRENCLAVE value of the code running in the enclave.")
  mrenclave?: string;

  @doc("Version of the quote presented.")
  quoteVersion: string;

  @doc("Raw SGX quote, parsable by tools like Open Enclave's oeverify.")
  raw: string;
}

@doc("An entry in the ledger.")
model LedgerEntry {
  @doc("Contents of the ledger entry.")
  contents: string;

  @visibility("read")
  @doc("Id of the collection containing the entry")
  collectionId?: string;

  ...TransactionIdOptionalReadOnly;
}

@doc("The result of querying for a ledger entry from an older transaction id. The ledger entry is available in the response only if the returned state is Ready.")
model LedgerQueryResult {
  state: LedgerQueryState;

  @doc("The ledger entry found as a result of the query. This is only available if the query is in Ready state.")
  entry?: LedgerEntry;
}

@doc("State of a ledger query.")
enum LedgerQueryState {
  Loading,
  Ready,
}

@doc("Details about a Confidential Ledger user.")
model LedgerUser {
  assignedRole: LedgerUserRole;

  ...UserIdReadOnly;
}

@doc("Represents an assignable role")
enum LedgerUserRole {
  Administrator,
  Contributor,
  Reader,
}

@doc("Returned as a result of a write to the Confidential Ledger, the transaction id in the response indicates when the write will become durable.")
model LedgerWriteResult {
  @doc("Id of the collection written to.")
  collectionId: string;

  @header("x-ms-ccf-transaction-id")
  @doc("The transaction id at which this write will become durable.")
  transactionId: string;
}

@doc("Paginated collections returned in response to a query.")
model PagedCollections {
  collections: Collection[];

  @doc("URI from which to retrieve the next page of results.")
  nextLink?: string;
}

@doc("Paginated ledger entries returned in response to a query.")
model PagedLedgerEntries {
  state: LedgerQueryState;

  @doc("URI from which to retrieve the next page of results.")
  nextLink?: string;

  entries: LedgerEntry[];
}

alias Pem = string;

@doc("Contents of a Confidential Ledger receipt")
model ReceiptContents {
  cert?: string;
  leaf?: string;
  leafComponents?: ReceiptLeafComponents;
  nodeId: string;
  proof: ReceiptElement[];
  root?: string;
  serviceEndorsements?: Pem[];
  signature: string;
}

model ReceiptElement {
  left?: string;
  right?: string;
}

model ReceiptLeafComponents {
  claimsDigest?: string;
  commitEvidence?: string;
  writeSetDigest?: string;
}

@doc("Object for assigning a role to a user.")
model RoleAssignment {
  roleName: LedgerUserRole;

  @doc("Description of the role")
  description?: string;
}

@doc("A receipt certifying the transaction at the specified id.")
model TransactionReceipt {
  receipt?: ReceiptContents;
  state: LedgerQueryState;
  ...TransactionId;
}

@doc("Represents the state of the transaction.")
enum TransactionState {
  Committed,
  Pending,
}

@doc("Response returned to a query for the transaction status.")
model TransactionStatus {
  state: TransactionState;
  ...TransactionId;
}

// Utility types
model TransactionId {
  @doc("A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.")
  transactionId: string;
}

model TransactionIdOptionalReadOnly {
  @visibility("read")
  @doc("A unique identifier for the state of the ledger. If returned as part of a LedgerEntry, it indicates the state from which the entry was read.")
  transactionId?: string;
}

model UserIdReadOnly {
  @visibility("read")
  @doc("Identifier for the user. This must either be an AAD object id or a certificate fingerprint.")
  userId: string;
}

// Routes
@route("/app/governance/constitution")
@summary("Gets the constitution used for governance.")
@doc("The constitution is a script that assesses and applies proposals from consortium members.")
@get
op GetConstitution(...Foundations.ApiVersionParameter): Constitution | Foundations.ErrorResponse;

// TODO: Pageable operations excluded from August MVP
// @route("/app/governance/members")
// @summary("Gets the consortium members.")
// @doc("Consortium members can manage the Confidential Ledger.")
// @get
// op ListConsortiumMembers(
//   ...Foundations.ApiVersionParameter
// ): Consortium | Foundations.ErrorResponse;
// TODO: Long-running operations excluded from August MVP

@route("/app/enclaveQuotes")
@summary("Gets quotes for all nodes of the Confidential Ledger.")
@doc("A quote is an SGX enclave measurement that can be used to verify the validity of a node and its enclave.")
@get
op GetEnclaveQuotes(...Foundations.ApiVersionParameter): ConfidentialLedgerEnclaves | Foundations.ErrorResponse;

// TODO: Pageable operations excluded from August MVP
// @route("/app/collections")
// @summary("Retrieves a list of collection ids present in the Confidential Ledger")
// @doc("Collection ids are user-created collections of ledger entries")
// @get // TODO: rewrite the operations in terms of Azure.Core operations, e.g. Azure.Core.Operations.ResourceAction<TResource, TResponse, TParams>, Azure.Core.Operations.ResourceList<TResource, TParams> etc. // This will also take care of not passing ApiVersionParameter everywhere.
// op ListCollections(
//   ...Foundations.ApiVersionParameter
// ): PagedCollections | Foundations.ErrorResponse;
// TODO: Long-running operations excluded from August MVP

// TODO: Pageable operations excluded from August MVP
// @route("/app/transactions")
// @summary("Gets ledger entries from a collection corresponding to a range.")
// @doc("A collection id may optionally be specified. Only entries in the specified (or default) collection will be returned.")
// @get
// op ListLedgerEntries(
//   ...Foundations.ApiVersionParameter,
//   ...CollectionIdParameter,
//   ...TransactionIdFromParameter,
//   ...TransactionIdToParameter,
// ): PagedLedgerEntries | Foundations.ErrorResponse;
// TODO: Long-running operations excluded from August MVP

@route("/app/transactions")
@summary("Writes a ledger entry.")
@doc("A collection id may optionally be specified.")
@post
op CreateLedgerEntry(
  ...Foundations.ApiVersionParameter,
  ...CollectionIdParameter,
  @body entry: LedgerEntry
): LedgerWriteResult | Foundations.ErrorResponse;

@route("/app/transactions/{transactionId}")
@summary("Gets the ledger entry at the specified transaction id. A collection id may optionally be specified to indicate the collection from which to fetch the value.")
@doc("To return older ledger entries, the relevant sections of the ledger must be read from disk and validated. To prevent blocking within the enclave, the response will indicate whether the entry is ready and part of the response, or if the loading is still ongoing.")
@get
op GetLedgerEntry(
  ...Foundations.ApiVersionParameter,
  ...CollectionIdParameter,
  ...TransactionIdParameter
): LedgerQueryResult | Foundations.ErrorResponse;

@route("/app/transactions/{transactionId}/receipt")
@summary("Gets a receipt certifying ledger contents at a particular transaction id.")
@get
op GetReceipt(
  ...Foundations.ApiVersionParameter,
  ...TransactionIdParameter
): TransactionReceipt | Foundations.ErrorResponse;

@route("/app/transactions/{transactionId}/status")
@summary("Gets the status of an entry identified by a transaction id.")
@get
op GetTransactionStatus(
  ...Foundations.ApiVersionParameter,
  ...TransactionIdParameter
): TransactionStatus | Foundations.ErrorResponse;

@route("/app/transactions/current")
@summary("Gets the current value available in the ledger.")
@get
op GetCurrentLedgerEntry(
  ...Foundations.ApiVersionParameter,
  ...CollectionIdParameter
): LedgerEntry | Foundations.ErrorResponse;

@route("/app/users/{userId}")
@summary("Deletes a user from the Confidential Ledger.")
@delete
op DeleteUser(
  ...Foundations.ApiVersionParameter,
  ...UserIdParameter
): NoContentResponse | Foundations.ErrorResponse;

@route("/app/users/{userId}")
@summary("Gets a user.")
@get
op GetUser(
  ...Foundations.ApiVersionParameter,
  ...UserIdParameter
): LedgerUser | Foundations.ErrorResponse;

@route("/app/users/{userId}")
@summary("Adds a user or updates a user's fields.")
@patch
op CreateOrUpdateUser(
  ...Foundations.ApiVersionParameter,
  ...UserIdParameter,
  ...UserDetailsParameterForPatch
): LedgerUser | Foundations.ErrorResponse;
