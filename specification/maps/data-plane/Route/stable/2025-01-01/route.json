{
  "swagger": "2.0",
  "info": {
    "title": "Maps Route",
    "version": "2025-01-01",
    "description": "Azure Maps Route REST APIs",
    "x-typespec-generated": [
      {
        "emitter": "@azure-tools/typespec-autorest"
      }
    ]
  },
  "schemes": [
    "https"
  ],
  "x-ms-parameterized-host": {
    "hostTemplate": "{endpoint}",
    "useSchemePrefix": false,
    "parameters": [
      {
        "name": "endpoint",
        "in": "path",
        "required": true,
        "type": "string",
        "enum": [
          "https://atlas.microsoft.com"
        ],
        "x-ms-enum": {
          "modelAsString": false
        }
      }
    ]
  },
  "produces": [
    "application/json"
  ],
  "consumes": [
    "application/json"
  ],
  "security": [
    {
      "AadOauth2Auth": [
        "https://atlas.microsoft.com/.default"
      ]
    },
    {
      "SharedKeyAuth": []
    },
    {
      "SasTokenAuth": []
    }
  ],
  "securityDefinitions": {
    "AadOauth2Auth": {
      "type": "oauth2",
      "description": "The Azure Active Directory OAuth2 Flow",
      "flow": "accessCode",
      "authorizationUrl": "https://login.microsoftonline.com/common/oauth2/authorize",
      "scopes": {
        "https://atlas.microsoft.com/.default": ""
      },
      "tokenUrl": "https://login.microsoftonline.com/common/oauth2/token"
    },
    "SasTokenAuth": {
      "type": "apiKey",
      "description": "SAS Token Authentication",
      "name": "SAS Token",
      "in": "header"
    },
    "SharedKeyAuth": {
      "type": "apiKey",
      "description": "Shared Key Authentication",
      "name": "subscription-key",
      "in": "header"
    }
  },
  "tags": [],
  "paths": {
    "/route/directions": {
      "post": {
        "operationId": "Route_PostRouteDirections",
        "summary": "Use to get the best route between an origin and destination for automobile,\ncommercial trucks and walking routes.",
        "description": "The `Route Directions` API is an HTTP `POST` request that returns the ideal\nroute between an origin and destination for automobile (driving), commercial\ntrucks and walking routes. The route passes through a series of waypoints if\nspecified. A waypoint is a geographical location defined by longitude and\nlatitude that is used for navigational purposes. The route considers factors\nsuch as current traffic and the typical road speeds on the requested day of the\nweek and time of day.\n\nThe API returns the distance, estimated travel time, and a representation of\nthe route geometry. More routing information such as an optimized waypoint\norder or turn by turn instructions is also available, depending on the\nparameters used.\n\nThe Route Directions considers local laws, vehicle dimensions, cargo type, max\nspeed, bridge and tunnel heights to calculate the truck specific routes and\navoid complex maneuvers and difficult roads. Not all trucks can travel the same\nroutes as other vehicles due to certain restrictions based on the vehicle\nprofile or cargo type. For example, highways often have separate speed limits\nfor trucks, some roads don't allow trucks with flammable or hazardous\nmaterials, and there can be height and weight restriction on bridges.\n\nUp to 150 waypoints and 10 viaWaypoints between any two waypoints is supported.\nEach set of waypoints creates a separate route Leg. ViaWaypoints define the\nroute path and can be used for route creation through specific locations, but\nthey don't create route Legs.\n\nFor information about routing availability in countries/regions, see [Azure\nMaps routing\ncoverage](https://learn.microsoft.com/azure/azure-maps/routing-coverage?pivots=latest).",
        "produces": [
          "application/geo+json",
          "application/json"
        ],
        "consumes": [
          "application/geo+json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "Accept-Language",
            "in": "header",
            "description": "Language in which routing results should be returned.\n\nFor more information, see [Localization support in Azure\nMaps](https://learn.microsoft.com/azure/azure-maps/supported-languages#routing-v2-services-preview-supported-languages).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "acceptLanguage"
          },
          {
            "name": "routeDirectionsRequest",
            "in": "body",
            "description": "Request body of RouteDirections API in GeoJSON format.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DirectionsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/RouteDirectionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "Successfully retrieve a route between an origin and a destination with additional parameters in the body": {
            "$ref": "./examples/PostRouteDirections.json"
          }
        }
      }
    },
    "/route/directions:batch": {
      "post": {
        "operationId": "Route_PostRouteDirectionsBatch",
        "summary": "Use to send a batch of queries to the [Route\nDirections](/rest/api/maps/route/post-route-directions?view=rest-maps-2025-01-01)\nAPI in a single synchronous request.",
        "description": "The `Route Directions Batch` API is an HTTP `POST` request that sends batches\nof up to **100** queries in a single call to the [Route\nDirections](/rest/api/maps/route/post-route-directions?view=rest-maps-2025-01-01)\nAPI.\n\n### Submit Synchronous Batch Request\nThe Synchronous API is recommended for lightweight batch requests. When the\nservice receives a request, it will respond as soon as the batch items are\ncalculated and there will be no possibility to retrieve the results later. The\nSynchronous API will return a timeout error (a 408 response) if the request\ntakes longer than 60 seconds. The number of batch items is limited to **100**\nfor this API.\n```\nPOST https://atlas.microsoft.com/route/directions:batch?api-version=2025-01-01\n```\n### POST Body for Batch Request\nTo send the _directions_ queries you will use a `POST` request where the\nrequest body will contain the `batchItems` array in `json` format and the\n`Content-Type` header will be set to `application/json`. Here's a sample\nrequest body containing 2 _directions_ queries:\n\n\n```\n{\n  \"batchItems\": [\n    {\n      \"optionalId\": \"bbc9c0f6-ab52-49d8-a788-a658fa654c94\",\n      \"type\": \"FeatureCollection\",\n      \"features\": [\n        {\n          \"type\": \"Feature\",\n          \"geometry\": {\n            \"coordinates\": [\n              -122.3368,\n              47.614988\n            ],\n            \"type\": \"Point\"\n          },\n          \"properties\": {\n            \"pointIndex\": 0,\n            \"pointType\": \"waypoint\"\n          }\n        },\n        {\n          \"type\": \"Feature\",\n          \"geometry\": {\n            \"coordinates\": [\n              -122.316067,\n              47.606356\n            ],\n            \"type\": \"Point\"\n          },\n          \"properties\": {\n            \"pointIndex\": 1,\n            \"pointType\": \"waypoint\"\n          }\n        }\n      ],\n      \"optimizeRoute\": \"fastestWithoutTraffic\",\n      \"routeOutputOptions\": [\n        \"routeSummary\"\n      ],\n      \"maxRouteCount\": 3,\n      \"travelMode\": \"driving\"\n    },\n    {\n      \"optionalId\": \"a191de3c-1268-4986-98f0-03f0a5d9302a\",\n      \"type\": \"FeatureCollection\",\n      \"features\": [\n        {\n          \"type\": \"Feature\",\n          \"geometry\": {\n            \"coordinates\": [\n              -122.3368,\n              47.614988\n            ],\n            \"type\": \"Point\"\n          },\n          \"properties\": {\n            \"pointIndex\": 0,\n            \"pointType\": \"waypoint\"\n          }\n        },\n        {\n          \"type\": \"Feature\",\n          \"geometry\": {\n            \"coordinates\": [\n              -122.316067,\n              47.606356\n            ],\n            \"type\": \"Point\"\n          },\n          \"properties\": {\n            \"pointIndex\": 1,\n            \"pointType\": \"waypoint\"\n          }\n        }\n      ],\n      \"optimizeRoute\": \"shortest\",\n      \"routeOutputOptions\": [\n        \"routeSummary\"\n      ],\n      \"maxRouteCount\": 2,\n      \"travelMode\": \"driving\"\n    }\n  ]\n}\n ```\n\nA _directions_ batchItem object can accept any of the supported _directions_\n[Request\nbody](/rest/api/maps/route/post-route-directions?view=rest-maps-2025-01-01#request-body)\n\n\n\nThe batch should contain at least **1** query.\n\n\n### Batch Response Model\nThe batch response contains a `summary` component that indicates the\n`totalRequests` that were part of the original batch request and\n`successfulRequests` i.e. queries which were executed successfully. The batch\nresponse also includes a `batchItems` array which contains a response for each\nand every query in the batch request. The `batchItems` will contain the results\nin the exact same order the original queries were sent in the batch request.\nEach item is of one of the following types:\n\n- [`DirectionsResponse`](/rest/api/maps/route/post-directions#response) - If\nthe query completed successfully.\n\n- `Error` - If the query failed. The response will contain a `code` and a\n`message` in this case.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "Accept-Language",
            "in": "header",
            "description": "Language in which routing results should be returned.\n\nFor more information, see [Localization support in Azure\nMaps](https://learn.microsoft.com/azure/azure-maps/supported-languages#routing-v2-services-preview-supported-languages).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "acceptLanguage"
          },
          {
            "name": "routeDirectionsBatchRequest",
            "in": "body",
            "description": "The list of route directions queries/requests to process. The list can contain\na max of 100 queries for sync version and must contain at least 1 query.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DirectionsBatchRequestBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/DirectionsBatchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "A Route Directions Batch request containing 2 queries": {
            "$ref": "./examples/PostRouteDirectionsBatch.json"
          }
        }
      }
    },
    "/route/matrix": {
      "post": {
        "operationId": "Route_PostRouteMatrix",
        "description": "The `Route Matrix` API is an HTTP `POST` request that allows calculation of a\nmatrix of route summaries for a set of routes defined by origin and destination\nlocations by using a sync request. For every given origin, the service\ncalculates the cost of routing from that origin to every given destination. The\nset of origins and the set of destinations can be thought of as the column and\nrow headers of a table and each cell in the table contains the costs of routing\nfrom the origin to the destination for that cell. Route Matrices can be\ncalculated for driving, walking and truck routes. For example, a food delivery\ncompany has 20 drivers and they need to find the closest driver to pick up the\ndelivery from the restaurant. To solve this use case, they can call the Route\nMatrix API and use the travel cost to sort the drivers by their actual travel\ndistance or time from the restaurant.\n\n\nRoute Matrices are used in several different types of applications, most\ncommonly to solve the Traveling Salesman Problem (TSP) and Vehicle Routing\nProblem (VRP). For each origin-destination pair in the matrix, the travel time\nand distance are returned. You can use the computed costs to determine which\ndetailed routes to calculate using the Route Directions API.\n\n\nThe maximum size of a matrix for sync request it's **2500** (the number of\norigins multiplied by the number of destinations).\n\n\n\n### Submit Synchronous Route Matrix Request\nIf your scenario requires synchronous requests and the maximum size of the\nmatrix is less than or equal to 2500, you might want to make synchronous\nrequest. The maximum size of a matrix for this API is **2500** (the number of\norigins multiplied by the number of destinations). With that constraint in\nmind, examples of possible matrix dimensions are: 50x50, 60x40, 90x20 (it does\nnot need to be square).\n\n\n\n### API Limitations\nThe synchronous processing of matrix is best suited for fast, small matrices\nof route calculation. To calculate larger matrices and heavy route calculation,\nuse the asynchronous endpoint. The following limitation is applicable to the\nsynchronous requests. If none of the rows in the following table match the\nrequest's parameters, the request does not meet the requirements and will not\nbe processed.\n\n| Max matrix size | Max number of origins  | Max number of destinations |\nAdditional limits\n\n|------------------|------------------------|----------------------------|------------|\n| 100              | 100         | 100              | N/A |\n| 200              | 200         | 200              | All origins and\ndestinations should be contained in an axis-aligned 400 km x 400 km bounding\nbox. Otherwise, some matrix cells will be resolved as OUT_OF_REGION.  |\n| 2500             | 1000        | 1000             | - `departAt` or\n`arriveAt` must be any.<br> - `traffic` must be historical.<br> - `travelMode`\nmust be either driving or truck<br> - No other parameters can be used\nexplicitly   |\n\n\nExamples:\n- Request of 10x20 matrix with `traffic=live`: This request will be processed\nwith a bounding box limit, as it matches a limit of up to 200, which includes\nbounding box restrictions.\n\n- Request of 10x20 matrix with default parameters (`traffic=historical`): This\nrequest will be processed without a bounding box limit, as it matches a limit\nof up to 2500, which does  not impose bounding box restrictions.",
        "produces": [
          "application/geo+json",
          "application/json"
        ],
        "consumes": [
          "application/geo+json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "routeMatrixRequest",
            "in": "body",
            "description": "Request body of RouteMatrix API in GeoJSON format.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/RouteMatrixRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/RouteMatrixResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "Successfully retrieve a route matrix with additional parameters in the body": {
            "$ref": "./examples/PostRouteMatrix.json"
          }
        }
      }
    },
    "/route/matrix:async": {
      "post": {
        "operationId": "Route_PostRouteMatrixAsync",
        "description": "The `Route Matrix Async` API is an HTTP `POST` request that allows calculation\nof a matrix of route summaries for a set of routes defined by origin and\ndestination locations by using an asynchronous (async) request. For every given\norigin, the service calculates the cost of routing from that origin to every\ngiven destination. The set of origins and the set of destinations can be\nthought of as the column and row headers of a table and each cell in the table\ncontains the costs of routing from the origin to the destination for that cell.\nRoute Matrices can be calculated for driving, walking and truck routes.\n\nRoute Matrices are used in several different types of applications, most\ncommonly to solve the Traveling Salesman Problem (TSP) and Vehicle Routing\nProblem (VRP). For each origin-destination pair in the matrix, the travel time\nand distance are returned. You can use the computed costs to determine which\ndetailed routes to calculate using the Route Directions API.\n\n\nThe maximum size of a matrix for async request is **50000** (the number of\norigins multiplied by the number of destinations).\n\n\n### Submit Asynchronous Route Matrix Request\nThe Asynchronous API is appropriate for processing big volumes of relatively\ncomplex routing requests. When you make a request by using async request, by\ndefault the service returns a 202 response code along a URL in the\n`operation-Location` field of the response header with the Azure Maps geography\nendpoint {geography}.atlas.microsoft.com. This URL should be checked\nperiodically until the status is Succeeded.\n\n\nThe maximum size of a matrix for this API is **50000** (the number of origins\nmultiplied by the number of destinations). With that constraint in mind,\nexamples of possible matrix dimensions are: 500x100, 100x100, 280x170. 100x50\n(it does not need to be square).\n\n\nThe asynchronous responses are stored for **24** hours. The redirect URL\nreturns a 404 response if used after the expiration period.\n\n\n\n\n```\nPOST\nhttps://atlas.microsoft.com/route/matrix:async?api-version=2025-01-01&subscription-key={subscription-key}\n```\n\nHere's a typical sequence of asynchronous operations:\n1. Client sends a Route Matrix POST request to Azure Maps\n\n2. The server will respond with one of the following:\n\n> HTTP `202 Accepted` -  Route Matrix request has been accepted.\n\n> HTTP `Error` - There was an error processing your Route Matrix request.\nThis could either be a 400 Bad Request or any other Error status code.\n\n\n3. If the Matrix Route request was accepted successfully, the\n`operation-location` header in the response contains the URL to get the status\nof the request. This status URI looks like the following:\n\n```\n    GET\nhttps://atlas.microsoft.com/route/operations/{id}?api-version=2025-01-01?subscription-key={subscription-key}\n  ```\n\n\n4. Client issues a GET request on the resultUrl obtained in Step 3 to get the\nresults\n\n\n\n```\n    GET\nhttps://atlas.microsoft.com/route/operations/{id}/result?api-version=2025-01-01?subscription-key={subscription-key}\n   ```\n\n\n\n### API Limitations\nThe asynchronous processing of matrix is best suited for larger matrices that\nrequire heavy route calculation. The following limitation is applicable to the\nasynchronous requests. If none of the rows in the following table match the\nrequest's parameters, the request does not meet the requirements and will not\nbe processed.\n\n| Max matrix size  | Max number of origins | Max number of destinations  |\nAdditional limits |\n\n|------------------|-----------------------|-----------------------------|-------------------|\n| 2500             | 1000                  | 1000                        | All\norigins and destinations should be contained in an axis-aligned 400 km x 400 km\nbounding box. Otherwise some matrix cells will be resolved as OUT_OF_REGION.  |\n| 50,000           | 10,000                | 10,000                      | -\n`departAt` or `arriveAt` must be any.<br>- `traffic` must be historical.<br/>-\n`optimizeRoute` must be fastest.<br/>- `travelMode` must be\neither driving or truck. <br/>- No other parameters can be used explicitly.  |",
        "consumes": [
          "application/geo+json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "routeMatrixAsyncRequest",
            "in": "body",
            "description": "Request body of RouteMatrix API in GeoJSON format.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/RouteMatrixAsyncRequest"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "The request has been accepted for processing, but processing has not yet completed.",
            "headers": {
              "Operation-Location": {
                "type": "string",
                "format": "uri",
                "description": "The location for monitoring the operation state."
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "Submit an asynchronous request for matrix": {
            "$ref": "./examples/PostRouteMatrixAsync.json"
          }
        },
        "x-ms-long-running-operation-options": {
          "final-state-via": "operation-location"
        },
        "x-ms-long-running-operation": true
      }
    },
    "/route/operations/{id}": {
      "get": {
        "operationId": "Route_GetRouteOperationsStatus",
        "description": "Get the status of an asynchronous operation by its operation ID.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "id",
            "in": "path",
            "description": "System generated unique identifier for the asynchronous operation after it has\nbeen submitted.",
            "required": true,
            "type": "string",
            "minLength": 36,
            "maxLength": 36,
            "pattern": "^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/RouteOperation"
            }
          },
          "404": {
            "description": "The server cannot find the requested resource.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "Retrieve the async matrix operation status": {
            "$ref": "./examples/GetRouteOperationStatusCompleted.json"
          }
        }
      }
    },
    "/route/operations/{id}/result": {
      "get": {
        "operationId": "Route_GetRouteOperationsResult",
        "description": "Get the result of an asynchronous operation by its operation ID.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "Accept-Language",
            "in": "header",
            "description": "Language in which routing results should be returned.\n\nFor more information, see [Localization support in Azure\nMaps](https://learn.microsoft.com/azure/azure-maps/supported-languages#routing-v2-services-preview-supported-languages).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "acceptLanguage"
          },
          {
            "name": "id",
            "in": "path",
            "description": "System generated unique identifier for the asynchronous operation after it has\nbeen submitted.",
            "required": true,
            "type": "string",
            "minLength": 36,
            "maxLength": 36,
            "pattern": "^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$"
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/RouteOperationResponse"
            }
          },
          "404": {
            "description": "The server cannot find the requested resource.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "Retrieve the async matrix result": {
            "$ref": "./examples/GetRouteMatrixAsyncResult.json"
          }
        }
      }
    },
    "/route/range": {
      "post": {
        "operationId": "Route_PostRouteRange",
        "description": "The Route Range API creates a polygon that depicts the area reachable from a\ngiven location within a certain threshold based on the specified time or\ndistance budget. A polygon boundary (or Isochrone) is returned in a\ncounterclockwise orientation as well as the precise polygon center which was\nthe result of the origin point.\n\nThe returned polygon can be used for spatial filtering to search for features\nof interest within the provided Isochrone.\n\n\n\nFor information about routing availability in countries/regions, see [Azure\nMaps routing\ncoverage](https://learn.microsoft.com/azure/azure-maps/routing-coverage?pivots=latest).",
        "produces": [
          "application/geo+json",
          "application/json"
        ],
        "consumes": [
          "application/geo+json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "routeRangeRequest",
            "in": "body",
            "description": "Request body of RouteRange API in GeoJSON format.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/RouteRangeRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/RouteRangeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "Successfully retrieve a set of locations that can be reached from the origin point based on the specified conditions": {
            "$ref": "./examples/PostRouteRange.json"
          }
        }
      }
    },
    "/route/range:batch": {
      "post": {
        "operationId": "Route_PostRouteRangeBatch",
        "description": "The Route Range Batch API sends batches of up to **100** queries as a single\ncall to the [Route Range\nAPI](https://learn.microsoft.com/rest/api/maps/route/post-route-range?view=rest-maps-2025-01-01).\nThis API enables efficient processing of multiple queries in one request,\nreducing the need for individual calls.\n\n### Submit Synchronous Batch Request\nThe Synchronous API is recommended for lightweight batch requests. When the\nservice receives a request, it will respond as soon as the batch items are\ncalculated and there will be no possibility to retrieve the results later. The\nSynchronous API will return a timeout error (a 408 response) if the request\ntakes longer than 60 seconds. The number of batch items is limited to **100**\nfor this API.\n```\nPOST https://atlas.microsoft.com/route/range:batch?api-version=2025-01-01\n```\n### POST Body for Batch Request\nTo send the _route range_ queries you will use a `POST` request where the\nrequest body will contain the `batchItems` array in `json` format and the\n`Content-Type` header will be set to `application/json`. Here's a sample\nrequest body containing 2 _route_range_ queries:\n\n\n```\n{\n  \"batchItems\": [\n    {\n      \"optionalId\": \"bbc9c0f6-ab52-49d8-a788-a658fa654c94\",\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          5.86605,\n          50.9745\n        ]\n      },\n      \"properties\": {\n        \"timeBudgetInSec\": 6000\n      }\n    },\n    {\n      \"optionalId\": \"300af787-589b-4088-accd-56828542e293\",\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          -122.201669,\n          47.615076\n        ]\n      },\n      \"properties\": {\n        \"timeBudgetInSec\": 2000\n      }\n    }\n  ]\n}\n```\n\nA _route range_ batchItem object can accept any of the supported _snap to\nroads_ [Request\nbody](/rest/api/maps/route/post-snap-to-roads?view=rest-maps-2025-01-01#request-body)\n\n\n\nThe batch should contain at least **1** query.\n\n\n### Batch Response Model\nThe batch response contains a `summary` component that indicates the\n`totalRequests` that were part of the original batch request and\n`successfulRequests` i.e. queries which were executed successfully. The batch\nresponse also includes a `batchItems` array which contains a response for each\nand every query in the batch request. The `batchItems` will contain the results\nin the exact same order the original queries were sent in the batch request.\nEach item is of one of the following types:\n\n- [`RouteRangeResponse`](/rest/api/maps/route/post-route-range#response) - If\nthe query completed successfully.\n\n- `Error` - If the query failed. The response will contain a `code` and a\n`message` in this case.",
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "routeRangeBatchRequest",
            "in": "body",
            "description": "The list of route directions queries/requests to process. The list can contain\na max of 100 queries for sync version and must contain at least 1 query.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/RouteRangeBatchRequestBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/RouteRangeBatchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "A Route Range Batch request containing 1 query": {
            "$ref": "./examples/PostRouteRangeBatch.json"
          }
        }
      }
    },
    "/route/snapToRoads": {
      "post": {
        "operationId": "Route_PostSnapToRoads",
        "description": "The Snap to Roads API accepts GPS point data, represented as longitude and\nlatitude coordinates, and generates points that aligns with existing roadways\non a map. This process, known as \"snapping to roads\", produces a series of\nobjects that trace a path closely following the road network. The resulting\ndata includes road names and their respective speed limits, pertinent to the\ntraversed segments.\n\nMoreover, the Snap to Roads API offers an interpolation feature, which refines\nthe GPS points to create a smoother route that adheres to the road's geometry.\nThis functionality is especially beneficial for asset tracking and enhancing\ndata visualization in mapping applications.\n\n>[!Important]\n> The GPS points must be within 6 kilometer of each other.\n\n\n\nFor information about routing availability in countries/regions, see [Azure\nMaps routing\ncoverage](https://learn.microsoft.com/azure/azure-maps/routing-coverage?pivots=latest).",
        "produces": [
          "application/geo+json",
          "application/json"
        ],
        "consumes": [
          "application/geo+json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "Accept-Language",
            "in": "header",
            "description": "Language in which routing results should be returned.\n\nFor more information, see [Localization support in Azure\nMaps](https://learn.microsoft.com/azure/azure-maps/supported-languages#routing-v2-services-preview-supported-languages).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "acceptLanguage"
          },
          {
            "name": "snapToRoadsRequest",
            "in": "body",
            "description": "Request body of SnapToRoads API in GeoJSON format.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SnapToRoadsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SnapToRoadsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "Successfully retrieve snap to roads points with additional parameters in the body": {
            "$ref": "./examples/PostSnapToRoads.json"
          }
        }
      }
    },
    "/route/snapToRoads:batch": {
      "post": {
        "operationId": "Route_PostSnapToRoadsBatch",
        "description": "The Snap To Roads Batch API sends batches of up to **100** queries as a single\ncall to the [Snap To Roads\nAPI](/rest/api/maps/route/post-snap-to-roads?view=rest-maps-2025-01-01). This\nAPI enables efficient processing of multiple queries in one request, reducing\nthe need for individual calls.\n\n### Submit Synchronous Batch Request\nThe Synchronous API is recommended for lightweight batch requests. When the\nservice receives a request, it will respond as soon as the batch items are\ncalculated and there will be no possibility to retrieve the results later. The\nSynchronous API will return a timeout error (a 408 response) if the request\ntakes longer than 60 seconds. The number of batch items is limited to **100**\nfor this API.\n```\nPOST https://atlas.microsoft.com/route/snapToRoads:batch?api-version=2025-01-01\n```\n### POST Body for Batch Request\nTo send the _snap to roads_ queries you will use a `POST` request where the\nrequest body will contain the `batchItems` array in `json` format and the\n`Content-Type` header will be set to `application/json`. Here's a sample\nrequest body containing 1 _snap to roads_ queries:\n\n\n```\n{\n  \"batchItems\": [\n    {\n      \"optionalId\": \"bbc9c0f6-ab52-49d8-a788-a658fa654c94\",\n      \"type\": \"FeatureCollection\",\n      \"features\": [\n        {\n          \"type\": \"Feature\",\n          \"geometry\": {\n            \"type\": \"Point\",\n            \"coordinates\": [\n              -122.336691,\n              47.59085\n            ]\n          },\n          \"properties\": {\n          }\n        },\n        {\n          \"type\": \"Feature\",\n          \"geometry\": {\n            \"type\": \"Point\",\n            \"coordinates\": [\n              -122.336023,\n              47.601616\n            ]\n          },\n          \"properties\": {\n          }\n        }\n      ],\n      \"includeSpeedLimit\": true,\n      \"travelMode\": \"driving\"\n    }\n  ]\n}\n```\n\nA _snap to roads_ batchItem object can accept any of the supported _snap to\nroads_ [Request\nbody](/rest/api/maps/route/post-snap-to-roads?view=rest-maps-2025-01-01#request-body)\n\n\n\nThe batch should contain at least **1** query.\n\n\n### Batch Response Model\nThe batch response contains a `summary` component that indicates the\n`totalRequests` that were part of the original batch request and\n`successfulRequests` i.e. queries which were executed successfully. The batch\nresponse also includes a `batchItems` array which contains a response for each\nand every query in the batch request. The `batchItems` will contain the results\nin the exact same order the original queries were sent in the batch request.\nEach item is of one of the following types:\n\n- [`SnapToRoadsResponse`](/rest/api/maps/route/post-snap-to-roads#response) -\nIf the query completed successfully.\n\n- `Error` - If the query failed. The response will contain a `code` and a\n`message` in this case.",
        "consumes": [
          "application/geo+json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/Azure.Core.Foundations.ApiVersionParameter"
          },
          {
            "name": "x-ms-client-id",
            "in": "header",
            "description": "Indicates the account intended for use with the Microsoft Entra ID security\nmodel. This unique ID for the Azure Maps account can be obtained from the\n[Azure Maps management plane Account API](/rest/api/maps-management/accounts).\nFor more information on using Microsoft Entra ID security in Azure Maps, see\n[Manage authentication in Azure\nMaps](/azure/azure-maps/how-to-manage-authentication).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "clientId"
          },
          {
            "name": "Accept-Language",
            "in": "header",
            "description": "Language in which routing results should be returned.\n\nFor more information, see [Localization support in Azure\nMaps](https://learn.microsoft.com/azure/azure-maps/supported-languages#routing-v2-services-preview-supported-languages).",
            "required": false,
            "type": "string",
            "x-ms-client-name": "acceptLanguage"
          },
          {
            "name": "snapToRoadsBatchRequest",
            "in": "body",
            "description": "The list of Snap To Roads queries/requests to process. The list can contain a\nmax of 100 queries for sync version and must contain at least 1 query.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SnapToRoadsBatchRequestBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has succeeded.",
            "schema": {
              "$ref": "#/definitions/SnapToRoadsBatchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/MapsErrorResponse"
            }
          }
        },
        "x-ms-examples": {
          "A Snap To Roads Batch request containing 1 query": {
            "$ref": "./examples/PostSnapToRoadsBatch.json"
          }
        }
      }
    }
  },
  "definitions": {
    "AdminDistrict": {
      "type": "object",
      "description": "The subdivision name in the country or region for an address. This element is\ntypically treated as the first order administrative subdivision, but in some\ncases it also contains the second, third, or fourth order subdivision in a\ncountry, dependency, or region.",
      "properties": {
        "shortName": {
          "type": "string",
          "description": "The short name for the corresponding adminDistrict field,\nFor adminDistrict[0], this could be short name of state such as WA. This is\nonly available for the US, Canada, and Mexico."
        }
      }
    },
    "AdrTunnelRestrictionCodeEnum": {
      "type": "string",
      "description": "The ADR tunnel restriction code. ADR is a European agreement concerning the\ninternational carriage of dangerous goods by road. The ADR tunnel restriction\ncode is used to determine whether a vehicle is allowed to pass through a tunnel\nwith restrictions on the carriage of dangerous goods.",
      "enum": [
        "B",
        "C",
        "D",
        "E"
      ],
      "x-ms-enum": {
        "name": "AdrTunnelRestrictionCodeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "B",
            "value": "B",
            "description": "Vehicles with code B are restricted from roads with ADR tunnel categories B, C,\nD, and E."
          },
          {
            "name": "C",
            "value": "C",
            "description": "Vehicles with code C are restricted from roads with ADR tunnel categories C, D,\nand E"
          },
          {
            "name": "D",
            "value": "D",
            "description": "Vehicles with code D are restricted from roads with ADR tunnel categories D and\nE."
          },
          {
            "name": "E",
            "value": "E",
            "description": "Vehicles with code E are restricted from roads with ADR tunnel category E."
          }
        ]
      }
    },
    "AvoidEnum": {
      "type": "string",
      "description": "Specifies restrictions that the route calculation should honor when determining the route.\nAvoid supports multiple values in a request and is only supported for the driving and truck\ntravelMode.\\n\\nExample: \\\"avoid\\\": [\\\"limitedAccessHighways\\\", \\\"tollRoads\\\"]",
      "enum": [
        "limitedAccessHighways",
        "tollRoads",
        "ferries",
        "tunnels",
        "borderCrossings",
        "lowEmissionZones",
        "unpavedRoads"
      ],
      "x-ms-enum": {
        "name": "AvoidEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "limitedAccessHighways",
            "value": "limitedAccessHighways",
            "description": "Avoids the use of limited access highways in the route."
          },
          {
            "name": "tollRoads",
            "value": "tollRoads",
            "description": "Avoids the use of toll roads in the route."
          },
          {
            "name": "ferries",
            "value": "ferries",
            "description": "Avoids the use of ferries in the route."
          },
          {
            "name": "tunnels",
            "value": "tunnels",
            "description": "Avoids the use of tunnels in the route."
          },
          {
            "name": "borderCrossings",
            "value": "borderCrossings",
            "description": "Avoids crossing country borders in the route."
          },
          {
            "name": "lowEmissionZones",
            "value": "lowEmissionZones",
            "description": "Avoids low-emission zones in the route."
          },
          {
            "name": "unpavedRoads",
            "value": "unpavedRoads",
            "description": "Avoids unpaved roads in the route."
          }
        ]
      }
    },
    "CountryRegion": {
      "type": "object",
      "description": "Represents a country or region, containing related details.",
      "properties": {
        "name": {
          "type": "string",
          "description": "name of country/region"
        },
        "ISO": {
          "type": "string",
          "description": "ISO of country/region represents an [ISO 3166-1 Alpha-2 region/country\ncode](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)"
        }
      }
    },
    "DirectionsBatchRequestBody": {
      "type": "object",
      "description": "The list of directions queries/requests to process. The list can contain a max\nof 100 queries and must contain at least 1 query.",
      "properties": {
        "batchItems": {
          "type": "array",
          "description": "The list of queries to process.",
          "items": {
            "$ref": "#/definitions/DirectionsBatchRequestItem"
          }
        }
      }
    },
    "DirectionsBatchRequestItem": {
      "type": "object",
      "description": "Batch Query object",
      "properties": {
        "optionalId": {
          "type": "string",
          "description": "Id of the request which would show in corresponding batchItem."
        },
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "Driving, walking, and truck routes are defined by a set of waypoints(stops) and\nviaWaypoints (intermediate locations that the route must pass through). You can\nhave a maximum of 150 waypoints, and a maximum of 10 viaWaypoints between each\nset of waypoints.\n\nA route must have a minimum of 2 waypoints and the start and end points of the\nroute cannot be viaWaypoints.\n\nBoth waypoint and viaWaypoint locations must be specified as a valid GeoJSON\nPoint feature object along with pointIndex that specifies the order of the\nlocations. For more information on the GeoJSON format, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946).",
          "minItems": 2,
          "items": {
            "$ref": "#/definitions/InputWaypointFeaturesItem"
          }
        },
        "travelMode": {
          "type": "string",
          "description": "The mode of travel for the requested route. If not defined, the default value\nis \"driving\" that returns the route optimized for cars.\n\n`Note`: For truck travelMode, the requested truck route may not be available\nfor the entire route. Where the truck route is not available for a particular\nsection, the travelMode element of the response for that section will be\n\"other\".\n\nExample: \"travelMode\":\"driving\"",
          "default": "driving",
          "enum": [
            "driving",
            "truck",
            "walking"
          ],
          "x-ms-enum": {
            "name": "TravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "The returned routes are optimized for cars."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "The returned routes are optimized for large size trucks based on the vehicle\nspecification."
              },
              {
                "name": "walking",
                "value": "walking",
                "description": "The returned routes are optimized for pedestrians, including the use of\nsidewalks."
              }
            ]
          }
        },
        "departAt": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time of departure from the origin point formatted as a `dateTime`\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nIf the `departAt` is not set, the default value is the current time.\n\nExample:\n\n\"departAt\": \"2023-06-01T09:30:00.000-07:00\""
        },
        "arriveAt": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time of arrival at the destination point formatted as a `dateTime`\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nThe `arriveAt` parameter cannot be used in conjunction with `departAt`.\n\nExample: \"arriveAt\": \"2023-06-01T09:30:00.000-07:00\""
        },
        "optimizeRoute": {
          "type": "string",
          "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastestWithoutTraffic\" which returns the route to minimize the\ntravel time without using current traffic information.\n\nExample: \"optimizeRoute\":\"shortest\"",
          "default": "fastestWithoutTraffic",
          "enum": [
            "short",
            "shortest",
            "fastestWithoutTraffic",
            "fastestWithTraffic"
          ],
          "x-ms-enum": {
            "name": "RouteDirectionOptimizeRouteEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "Short",
                "value": "short",
                "description": "The route is calculated to balance fast travel time and short distance, rather\nthan prioritizing just one. It's optimized for both speed and efficiency.\nTraffic information is not used."
              },
              {
                "name": "Shortest",
                "value": "shortest",
                "description": "The route is calculated to minimize the distance. Traffic information is not\nused."
              },
              {
                "name": "FastestWithoutTraffic",
                "value": "fastestWithoutTraffic",
                "description": "Finds the fastest route, without factoring in traffic information."
              },
              {
                "name": "FastestWithTraffic",
                "value": "fastestWithTraffic",
                "description": "The route is calculated to minimize the time using current traffic information.\n`Note`: Only supported for driving and truck travelMode."
              }
            ]
          }
        },
        "optimizeWaypointOrder": {
          "type": "boolean",
          "description": "Re-order the route waypoints using a fast heuristic algorithm to reduce the\nroute cost specified with the optimize parameter. The origin and destination\nare excluded from the optimized waypoint and their position is considered\nfixed. Acceptable values are true or false.",
          "default": false
        },
        "avoid": {
          "type": "array",
          "description": "Specifies restrictions that the route calculation should honor when determining\nthe route. Avoid supports multiple values in a request and is only supported\nfor the driving and truck travelMode.\n\nExample: \"avoid\": [\"limitedAccessHighways\", \"tollRoads\"]",
          "items": {
            "$ref": "#/definitions/AvoidEnum"
          }
        },
        "routeOutputOptions": {
          "type": "array",
          "description": "Include the desired route information from the response. By default, the\nitinerary is included in the response.\n\nSupports multiple values such as \"routeOutputOptions\": [\"routePath\",\n\"itinerary\"]",
          "default": [
            "itinerary"
          ],
          "items": {
            "$ref": "#/definitions/RouteOutputOptionEnum"
          }
        },
        "maxRouteCount": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of routes to return. Available for the driving and truck\ntravel modes.\n\nDefault: \"maxRouteCount\":1",
          "minimum": 1,
          "maximum": 6
        },
        "heading": {
          "type": "integer",
          "format": "int64",
          "description": "The initial directional heading of the vehicle in degrees starting at true\nNorth and continuing in clockwise direction. North is 0 degrees, east is 90\ndegrees, south is 180 degrees, west is 270 degrees.",
          "minimum": 0,
          "maximum": 359
        },
        "vehicleSpec": {
          "$ref": "#/definitions/RouteDirectionVehicleSpec",
          "description": "Specifies the vehicle attributes such as size, weight, max speed, type of\ncargo, etc. for truck routing only. This helps avoid low bridge clearances,\nroad restrictions, difficult right turns to provide the optimized truck route\nbased on the vehicle specifications.\n\n`Note`: Only supported for truck travelMode"
        }
      },
      "required": [
        "type",
        "features"
      ]
    },
    "DirectionsBatchResponse": {
      "type": "object",
      "description": "This object is returned from a successful Directions Batch service call.",
      "properties": {
        "summary": {
          "$ref": "#/definitions/DirectionsBatchResponseSummary",
          "description": "Summary for the batch request"
        },
        "batchItems": {
          "type": "array",
          "description": "Array containing the batch results.",
          "items": {
            "$ref": "#/definitions/DirectionsBatchResponseItem"
          }
        }
      }
    },
    "DirectionsBatchResponseItem": {
      "type": "object",
      "description": "error details",
      "properties": {
        "optionalId": {
          "type": "string",
          "description": "Id of the request which would show in corresponding batchItem."
        },
        "alternativeRoutes": {
          "type": "array",
          "description": "Alternative route.",
          "items": {
            "$ref": "#/definitions/FeatureCollection"
          }
        },
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "`GeoJSON` feature object that contains Geometry object and additional\nproperties. For more information, see [RFC 7946, Section\n3.2](https://www.rfc-editor.org/rfc/rfc7946#section-3.2).",
          "items": {
            "$ref": "#/definitions/FeaturesItem"
          }
        },
        "error": {
          "$ref": "#/definitions/ErrorDetail",
          "description": "The error detail."
        }
      }
    },
    "DirectionsBatchResponseSummary": {
      "type": "object",
      "description": "Summary for the batch request",
      "properties": {
        "successfulRequests": {
          "type": "integer",
          "format": "int32",
          "description": "Number of successful requests in the batch"
        },
        "totalRequests": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of requests in the batch"
        }
      }
    },
    "DirectionsRequest": {
      "type": "object",
      "description": "This object is the request body.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "Driving, walking, and truck routes are defined by a set of waypoints(stops) and\nviaWaypoints (intermediate locations that the route must pass through). You can\nhave a maximum of 150 waypoints, and a maximum of 10 viaWaypoints between each\nset of waypoints.\n\nA route must have a minimum of 2 waypoints and the start and end points of the\nroute cannot be viaWaypoints.\n\nBoth waypoint and viaWaypoint locations must be specified as a valid GeoJSON\nPoint feature object along with pointIndex that specifies the order of the\nlocations. For more information on the GeoJSON format, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946).",
          "minItems": 2,
          "items": {
            "$ref": "#/definitions/InputWaypointFeaturesItem"
          }
        },
        "travelMode": {
          "type": "string",
          "description": "The mode of travel for the requested route. If not defined, the default value\nis \"driving\" that returns the route optimized for cars.\n\n`Note`: For truck travelMode, the requested truck route may not be available\nfor the entire route. Where the truck route is not available for a particular\nsection, the travelMode element of the response for that section will be\n\"other\".\n\nExample: \"travelMode\":\"driving\"",
          "default": "driving",
          "enum": [
            "driving",
            "truck",
            "walking"
          ],
          "x-ms-enum": {
            "name": "TravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "The returned routes are optimized for cars."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "The returned routes are optimized for large size trucks based on the vehicle\nspecification."
              },
              {
                "name": "walking",
                "value": "walking",
                "description": "The returned routes are optimized for pedestrians, including the use of\nsidewalks."
              }
            ]
          }
        },
        "departAt": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time of departure from the origin point formatted as a `dateTime`\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nIf the `departAt` is not set, the default value is the current time.\n\nExample:\n\n\"departAt\": \"2023-06-01T09:30:00.000-07:00\""
        },
        "arriveAt": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time of arrival at the destination point formatted as a `dateTime`\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nThe `arriveAt` parameter cannot be used in conjunction with `departAt`.\n\nExample: \"arriveAt\": \"2023-06-01T09:30:00.000-07:00\""
        },
        "optimizeRoute": {
          "type": "string",
          "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastestWithoutTraffic\" which returns the route to minimize the\ntravel time without using current traffic information.\n\nExample: \"optimizeRoute\":\"shortest\"",
          "default": "fastestWithoutTraffic",
          "enum": [
            "short",
            "shortest",
            "fastestWithoutTraffic",
            "fastestWithTraffic"
          ],
          "x-ms-enum": {
            "name": "RouteDirectionOptimizeRouteEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "Short",
                "value": "short",
                "description": "The route is calculated to balance fast travel time and short distance, rather\nthan prioritizing just one. It's optimized for both speed and efficiency.\nTraffic information is not used."
              },
              {
                "name": "Shortest",
                "value": "shortest",
                "description": "The route is calculated to minimize the distance. Traffic information is not\nused."
              },
              {
                "name": "FastestWithoutTraffic",
                "value": "fastestWithoutTraffic",
                "description": "Finds the fastest route, without factoring in traffic information."
              },
              {
                "name": "FastestWithTraffic",
                "value": "fastestWithTraffic",
                "description": "The route is calculated to minimize the time using current traffic information.\n`Note`: Only supported for driving and truck travelMode."
              }
            ]
          }
        },
        "optimizeWaypointOrder": {
          "type": "boolean",
          "description": "Re-order the route waypoints using a fast heuristic algorithm to reduce the\nroute cost specified with the optimize parameter. The origin and destination\nare excluded from the optimized waypoint and their position is considered\nfixed. Acceptable values are true or false.",
          "default": false
        },
        "avoid": {
          "type": "array",
          "description": "Specifies restrictions that the route calculation should honor when determining\nthe route. Avoid supports multiple values in a request and is only supported\nfor the driving and truck travelMode.\n\nExample: \"avoid\": [\"limitedAccessHighways\", \"tollRoads\"]",
          "items": {
            "$ref": "#/definitions/AvoidEnum"
          }
        },
        "routeOutputOptions": {
          "type": "array",
          "description": "Include the desired route information from the response. By default, the\nitinerary is included in the response.\n\nSupports multiple values such as \"routeOutputOptions\": [\"routePath\",\n\"itinerary\"]",
          "default": [
            "itinerary"
          ],
          "items": {
            "$ref": "#/definitions/RouteOutputOptionEnum"
          }
        },
        "maxRouteCount": {
          "type": "integer",
          "format": "int64",
          "description": "The maximum number of routes to return. Available for the driving and truck\ntravel modes.\n\nDefault: \"maxRouteCount\":1",
          "minimum": 1,
          "maximum": 6
        },
        "heading": {
          "type": "integer",
          "format": "int64",
          "description": "The initial directional heading of the vehicle in degrees starting at true\nNorth and continuing in clockwise direction. North is 0 degrees, east is 90\ndegrees, south is 180 degrees, west is 270 degrees.",
          "minimum": 0,
          "maximum": 359
        },
        "vehicleSpec": {
          "$ref": "#/definitions/RouteDirectionVehicleSpec",
          "description": "Specifies the vehicle attributes such as size, weight, max speed, type of\ncargo, etc. for truck routing only. This helps avoid low bridge clearances,\nroad restrictions, difficult right turns to provide the optimized truck route\nbased on the vehicle specifications.\n\n`Note`: Only supported for truck travelMode"
        }
      },
      "required": [
        "type",
        "features"
      ]
    },
    "DrivingSideEnum": {
      "type": "string",
      "description": "Indicates left-hand vs. right-hand side driving at the point of the maneuver.",
      "enum": [
        "Left",
        "Right"
      ],
      "x-ms-enum": {
        "name": "DrivingSideEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Left",
            "value": "Left",
            "description": "Left-hand side driving."
          },
          {
            "name": "Right",
            "value": "Right",
            "description": "Right-hand side driving."
          }
        ]
      }
    },
    "ErrorAdditionalInfo": {
      "type": "object",
      "description": "The resource management error additional info.",
      "properties": {
        "type": {
          "type": "string",
          "description": "The additional info type.",
          "readOnly": true
        },
        "info": {
          "type": "object",
          "description": "The additional info.",
          "additionalProperties": {},
          "readOnly": true
        }
      }
    },
    "ErrorDetail": {
      "type": "object",
      "description": "The error detail.",
      "properties": {
        "code": {
          "type": "string",
          "description": "The error code.",
          "readOnly": true
        },
        "message": {
          "type": "string",
          "description": "The error message.",
          "readOnly": true
        },
        "target": {
          "type": "string",
          "description": "The error target.",
          "readOnly": true
        },
        "details": {
          "type": "array",
          "description": "The error details.",
          "items": {
            "$ref": "#/definitions/ErrorDetail"
          },
          "readOnly": true
        },
        "additionalInfo": {
          "type": "array",
          "description": "The error additional info.",
          "items": {
            "$ref": "#/definitions/ErrorAdditionalInfo"
          },
          "readOnly": true
        }
      }
    },
    "ErrorResponse": {
      "type": "object",
      "description": "Common error response for all Azure Resource Manager APIs to return error\ndetails for failed operations. (This also follows the OData error response\nformat.).",
      "properties": {
        "error": {
          "$ref": "#/definitions/ErrorDetail",
          "description": "The error object."
        }
      }
    },
    "FeatureCollection": {
      "type": "object",
      "description": "`GeoJSON` `FeatureCollection` object that contains a list of Features. For more\ninformation, see [RFC 7946, section\n3.3](https://www.rfc-editor.org/rfc/rfc7946#section-3.3).",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "`GeoJSON` feature object that contains Geometry object and additional\nproperties. For more information, see [RFC 7946, Section\n3.2](https://www.rfc-editor.org/rfc/rfc7946#section-3.2).",
          "items": {
            "$ref": "#/definitions/FeaturesItem"
          }
        }
      }
    },
    "FeatureProperties": {
      "type": "object",
      "description": "Specifies the feature properties of the route like itinerary, route Legs and\ngeometry, travel summary.",
      "properties": {
        "type": {
          "$ref": "#/definitions/PropertiesTypeEnum",
          "description": "Output type."
        }
      },
      "discriminator": "type",
      "required": [
        "type"
      ]
    },
    "FeatureTypeEnum": {
      "type": "string",
      "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946).",
      "enum": [
        "FeatureCollection"
      ],
      "x-ms-enum": {
        "name": "FeatureTypeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "FeatureCollection",
            "value": "FeatureCollection",
            "description": "Specifies the `GeoJSON` `FeatureCollection` object type."
          }
        ]
      }
    },
    "FeaturesItem": {
      "type": "object",
      "description": "GeoJSON feature object that contains Geometry object and additional properties\nof the route.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/RouteDirectionsGeometry",
          "description": "A valid `GeoJSON` Geometry object. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "properties": {
          "$ref": "#/definitions/FeatureProperties",
          "description": "Specifies the feature properties of the route like itinerary, route Legs and\ngeometry, travel summary."
        },
        "bbox": {
          "type": "array",
          "description": "A rectangular area on the earth defined as a bounding box object. The sides of\nthe rectangles are defined by latitude and longitude values. For more\ninformation, see [RFC 7946, Section\n5](https://www.rfc-editor.org/rfc/rfc7946#section-5).\n\nExample: \"bbox\": [-10.0, -10.0, 10.0, 10.0]",
          "items": {
            "type": "number",
            "format": "double"
          }
        }
      }
    },
    "FeaturesItemTypeEnum": {
      "type": "string",
      "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946).",
      "enum": [
        "Feature"
      ],
      "x-ms-enum": {
        "name": "FeaturesItemTypeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Feature",
            "value": "Feature",
            "description": "Specifies the `GeoJSON` Feature object type."
          }
        ]
      }
    },
    "GeoJsonFeature": {
      "type": "object",
      "description": "A valid `GeoJSON Feature` object type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.2) for details.",
      "properties": {
        "geometry": {
          "$ref": "#/definitions/GeoJsonGeometry",
          "description": "A valid `GeoJSON` geometry object. The type must be one of the seven valid\nGeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString,\nPolygon, MultiPolygon and GeometryCollection. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details."
        },
        "properties": {
          "type": "object",
          "description": "Properties can contain any additional metadata about the `Feature`. Value can\nbe any JSON object or a JSON null value",
          "x-nullable": true,
          "additionalProperties": {}
        },
        "id": {
          "type": "string",
          "description": "Identifier for the feature."
        },
        "featureType": {
          "type": "string",
          "description": "The type of the feature. The value depends on the data model the current\nfeature is part of. Some data models may have an empty value."
        }
      },
      "required": [
        "geometry"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonObject"
        }
      ],
      "x-ms-discriminator-value": "Feature"
    },
    "GeoJsonFeatureCollection": {
      "type": "object",
      "description": "A valid `GeoJSON FeatureCollection` object type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details.",
      "properties": {
        "features": {
          "type": "array",
          "description": "Contains a list of valid `GeoJSON Feature` objects.",
          "items": {
            "$ref": "#/definitions/GeoJsonFeature"
          }
        }
      },
      "required": [
        "features"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonObject"
        }
      ],
      "x-ms-discriminator-value": "FeatureCollection"
    },
    "GeoJsonFeatureCollectionData": {
      "type": "object",
      "description": "GeoJson FeatureCollection data.",
      "properties": {
        "features": {
          "type": "array",
          "description": "Contains a list of valid `GeoJSON Feature` objects.",
          "items": {
            "$ref": "#/definitions/GeoJsonFeature"
          }
        }
      },
      "required": [
        "features"
      ]
    },
    "GeoJsonFeatureData": {
      "type": "object",
      "description": "GeoJson Feature data.",
      "properties": {
        "geometry": {
          "$ref": "#/definitions/GeoJsonGeometry",
          "description": "A valid `GeoJSON` geometry object. The type must be one of the seven valid\nGeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString,\nPolygon, MultiPolygon and GeometryCollection. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details."
        },
        "properties": {
          "type": "object",
          "description": "Properties can contain any additional metadata about the `Feature`. Value can\nbe any JSON object or a JSON null value",
          "x-nullable": true,
          "additionalProperties": {}
        },
        "id": {
          "type": "string",
          "description": "Identifier for the feature."
        },
        "featureType": {
          "type": "string",
          "description": "The type of the feature. The value depends on the data model the current\nfeature is part of. Some data models may have an empty value."
        }
      },
      "required": [
        "geometry"
      ]
    },
    "GeoJsonGeometry": {
      "type": "object",
      "description": "A valid `GeoJSON` geometry object. The type must be one of the seven valid\nGeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString,\nPolygon, MultiPolygon and GeometryCollection. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/GeoJsonObjectType",
          "description": "Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object\ntypes - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,\nGeometryCollection, Feature and FeatureCollection."
        }
      },
      "discriminator": "type",
      "required": [
        "type"
      ]
    },
    "GeoJsonGeometryCollection": {
      "type": "object",
      "description": "A valid `GeoJSON GeometryCollection` object type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.8) for details.",
      "properties": {
        "geometries": {
          "type": "array",
          "description": "Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates\nin GeoJSON are in x, y order (longitude, latitude).",
          "items": {
            "$ref": "#/definitions/GeoJsonGeometry"
          }
        }
      },
      "required": [
        "geometries"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonGeometry"
        }
      ],
      "x-ms-discriminator-value": "GeometryCollection"
    },
    "GeoJsonGeometryCollectionData": {
      "type": "object",
      "description": "GeoJson GeometryCollection data.",
      "properties": {
        "geometries": {
          "type": "array",
          "description": "Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates\nin GeoJSON are in x, y order (longitude, latitude).",
          "items": {
            "$ref": "#/definitions/GeoJsonGeometry"
          }
        }
      },
      "required": [
        "geometries"
      ]
    },
    "GeoJsonGeometryObjectType": {
      "type": "string",
      "description": "Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object\ntypes - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,\nGeometryCollection, Feature and FeatureCollection.",
      "enum": [
        "Point",
        "MultiPoint",
        "LineString",
        "MultiLineString",
        "Polygon",
        "MultiPolygon",
        "GeometryCollection"
      ],
      "x-ms-enum": {
        "name": "GeoJsonGeometryObjectType",
        "modelAsString": false,
        "values": [
          {
            "name": "GeoJsonPoint",
            "value": "Point",
            "description": "`GeoJSON Point` geometry."
          },
          {
            "name": "GeoJsonMultiPoint",
            "value": "MultiPoint",
            "description": "`GeoJSON MultiPoint` geometry."
          },
          {
            "name": "GeoJsonLineString",
            "value": "LineString",
            "description": "`GeoJSON LineString` geometry."
          },
          {
            "name": "GeoJsonMultiLineString",
            "value": "MultiLineString",
            "description": "`GeoJSON MultiLineString` geometry."
          },
          {
            "name": "GeoJsonPolygon",
            "value": "Polygon",
            "description": "`GeoJSON Polygon` geometry."
          },
          {
            "name": "GeoJsonMultiPolygon",
            "value": "MultiPolygon",
            "description": "`GeoJSON MultiPolygon` geometry."
          },
          {
            "name": "GeoJsonGeometryCollection",
            "value": "GeometryCollection",
            "description": "`GeoJSON GeometryCollection` geometry."
          }
        ]
      }
    },
    "GeoJsonLineString": {
      "type": "object",
      "description": "A valid `GeoJSON LineString` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson LineString` geometry.",
          "items": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonGeometry"
        }
      ],
      "x-ms-discriminator-value": "LineString"
    },
    "GeoJsonLineStringData": {
      "type": "object",
      "description": "GeoJson LineString data",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson LineString` geometry.",
          "items": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "GeoJsonMultiLineString": {
      "type": "object",
      "description": "A valid `GeoJSON MultiLineString` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.5) for details.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson MultiLineString` geometry.",
          "items": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonGeometry"
        }
      ],
      "x-ms-discriminator-value": "MultiLineString"
    },
    "GeoJsonMultiLineStringData": {
      "type": "object",
      "description": "GeoJson MultiLineString data",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson MultiLineString` geometry.",
          "items": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          }
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "GeoJsonMultiPoint": {
      "type": "object",
      "description": "A valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson MultiPoint` geometry.",
          "items": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonGeometry"
        }
      ],
      "x-ms-discriminator-value": "MultiPoint"
    },
    "GeoJsonMultiPointData": {
      "type": "object",
      "description": "Data contained by a `GeoJson MultiPoint`.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson MultiPoint` geometry.",
          "items": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "GeoJsonMultiPolygon": {
      "type": "object",
      "description": "A valid `GeoJSON MultiPolygon` object type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.7) for details.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Contains a list of valid `GeoJSON Polygon` objects. **Note** that coordinates\nin GeoJSON are in x, y order (longitude, latitude).",
          "items": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "type": "number",
                  "format": "double"
                }
              }
            }
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonGeometry"
        }
      ],
      "x-ms-discriminator-value": "MultiPolygon"
    },
    "GeoJsonMultiPolygonData": {
      "type": "object",
      "description": "GeoJson MultiPolygon data",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Contains a list of valid `GeoJSON Polygon` objects. **Note** that coordinates\nin GeoJSON are in x, y order (longitude, latitude).",
          "items": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "type": "number",
                  "format": "double"
                }
              }
            }
          }
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "GeoJsonObject": {
      "type": "object",
      "description": "A valid `GeoJSON` object. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/GeoJsonObjectType",
          "description": "Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object\ntypes - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,\nGeometryCollection, Feature and FeatureCollection."
        }
      },
      "discriminator": "type",
      "required": [
        "type"
      ]
    },
    "GeoJsonObjectType": {
      "type": "string",
      "description": "Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object\ntypes - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,\nGeometryCollection, Feature and FeatureCollection.",
      "enum": [
        "Point",
        "MultiPoint",
        "LineString",
        "MultiLineString",
        "Polygon",
        "MultiPolygon",
        "GeometryCollection",
        "Feature",
        "FeatureCollection"
      ],
      "x-ms-enum": {
        "name": "GeoJsonObjectType",
        "modelAsString": false,
        "values": [
          {
            "name": "GeoJsonPoint",
            "value": "Point",
            "description": "`GeoJSON Point` geometry."
          },
          {
            "name": "GeoJsonMultiPoint",
            "value": "MultiPoint",
            "description": "`GeoJSON MultiPoint` geometry."
          },
          {
            "name": "GeoJsonLineString",
            "value": "LineString",
            "description": "`GeoJSON LineString` geometry."
          },
          {
            "name": "GeoJsonMultiLineString",
            "value": "MultiLineString",
            "description": "`GeoJSON MultiLineString` geometry."
          },
          {
            "name": "GeoJsonPolygon",
            "value": "Polygon",
            "description": "`GeoJSON Polygon` geometry."
          },
          {
            "name": "GeoJsonMultiPolygon",
            "value": "MultiPolygon",
            "description": "`GeoJSON MultiPolygon` geometry."
          },
          {
            "name": "GeoJsonGeometryCollection",
            "value": "GeometryCollection",
            "description": "`GeoJSON GeometryCollection` geometry."
          },
          {
            "name": "GeoJsonFeature",
            "value": "Feature",
            "description": "`GeoJSON Feature` object."
          },
          {
            "name": "GeoJsonFeatureCollection",
            "value": "FeatureCollection",
            "description": "`GeoJSON FeatureCollection` object."
          }
        ]
      }
    },
    "GeoJsonPoint": {
      "type": "object",
      "description": "A valid `GeoJSON Point` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "A `Position` is an array of numbers with two or more elements. The first two\nelements are _longitude_ and _latitude_, precisely in that order.\n_Altitude/Elevation_ is an optional third element. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.1) for details.",
          "items": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonGeometry"
        }
      ],
      "x-ms-discriminator-value": "Point"
    },
    "GeoJsonPointData": {
      "type": "object",
      "description": "Data contained by a `GeoJson Point`.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "A `Position` is an array of numbers with two or more elements. The first two\nelements are _longitude_ and _latitude_, precisely in that order.\n_Altitude/Elevation_ is an optional third element. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.1) for details.",
          "items": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "GeoJsonPolygon": {
      "type": "object",
      "description": "A valid `GeoJSON Polygon` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.6) for details.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson Polygon` geometry type.",
          "items": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/GeoJsonGeometry"
        }
      ],
      "x-ms-discriminator-value": "Polygon"
    },
    "GeoJsonPolygonData": {
      "type": "object",
      "description": "GeoJson Polygon data",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson Polygon` geometry type.",
          "items": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          }
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "InputRouteMatrixFeaturesItem": {
      "type": "object",
      "description": "Specifies the input origin and destination points and additional properties for\nthe `GeoJSON` MultiPoint feature object. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/GeoJsonMultiPoint",
          "description": "A valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details."
        },
        "properties": {
          "$ref": "#/definitions/InputRouteMatrixProperties",
          "description": "MultiPoint feature properties object which specifies the origin features and\ndestination features for the input matrix."
        }
      },
      "required": [
        "type",
        "geometry",
        "properties"
      ]
    },
    "InputRouteMatrixProperties": {
      "type": "object",
      "description": "Specifies the properties object for the input matrix.",
      "properties": {
        "pointType": {
          "$ref": "#/definitions/RouteMatrixTypeEnum",
          "description": "Specifies the origin MultiPoint type and destination MultiPoint type for the\ninput matrix."
        }
      }
    },
    "InputRouteRangeFeaturesItem": {
      "type": "object",
      "description": "Specifies the starting point for range calculation. `GeoJSON` feature object\nand additional properties. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/GeoJsonPoint",
          "description": "A valid `GeoJSON Point` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details."
        },
        "properties": {
          "type": "object",
          "description": "Route Ranges properties.",
          "additionalProperties": {}
        }
      },
      "required": [
        "type",
        "geometry",
        "properties"
      ]
    },
    "InputRouteRangeProperties": {
      "type": "object",
      "description": "Specifies the parameters to use for the calculation of isochrone polygon.",
      "properties": {
        "departAt": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time of departure from the origin point formatted as a dateTime\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nIf the `departAt` is not set, the default value is the current time.\n\nExample:\n\n\"departAt\": \"2023-06-01T09:30:00.000-07:00\""
        },
        "isSimplifiedPolygon": {
          "type": "boolean",
          "description": "Use this to specify if you need simplified polygons that reduces the number of\npolygon vertices while preserving the shape. The API returns low definition\npolygon by default.",
          "default": true
        },
        "optimizeRoute": {
          "type": "string",
          "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastestWithoutTraffic\" which returns the route to minimize the\ntravel time without using current traffic information.\n\nExample: \"optimizeRoute\":\"shortest\"",
          "default": "fastestWithoutTraffic",
          "enum": [
            "shortest",
            "fastestWithoutTraffic",
            "fastestWithTraffic"
          ],
          "x-ms-enum": {
            "name": "RouteRangeOptimizeRouteEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "Shortest",
                "value": "shortest",
                "description": "The route is calculated to minimize the distance. Traffic information is not\nused."
              },
              {
                "name": "FastestWithoutTraffic",
                "value": "fastestWithoutTraffic",
                "description": "Finds the fastest route, without factoring in traffic information."
              },
              {
                "name": "FastestWithTraffic",
                "value": "fastestWithTraffic",
                "description": "The route is calculated to minimize the time using current traffic information.\n`Note`: Only supported for driving and truck travelMode."
              }
            ]
          }
        },
        "avoid": {
          "type": "array",
          "description": "Specifies restrictions that the route calculation should honor when determining\nthe reachable locations. Avoid supports multiple values in a request.\n\nExample: \"avoid\": [\"limitedAccessHighways\", \"tollRoads\"]",
          "items": {
            "$ref": "#/definitions/RouteRangeAvoidEnum"
          }
        },
        "vehicleSpec": {
          "$ref": "#/definitions/RouteRangeVehicleSpec",
          "description": "Specifies the vehicle attributes such as vehicle height, weight, max speed,\ntype of cargo, etc. to consider when calculating the reachable locations. This\nhelps avoid low bridge clearances, road restrictions, difficult right turns to\nprovide the optimized truck route based on the vehicle specifications. Vehicle\nattributes are specified within the vehicleSpec property."
        },
        "distanceBudgetInMeters": {
          "type": "number",
          "format": "float",
          "description": "The distance budget specifies the maximum range in meters which can be traveled\nfrom the origin waypoint. It cannot be set when `timeBudgetInSec` is specified.\n\nWhen `isSimplifiedPolygon` is false, the maximum distance supported is 90000\nmeters; otherwise, it is 500,000 meters.\n\nExample: \"distanceBudgetInMeters\":5000",
          "maximum": 500000
        },
        "timeBudgetInSec": {
          "type": "number",
          "format": "float",
          "description": "The time budget specifies the maximum time in seconds available for travel,\ndefining how far one can go within this time constraint from the origin\nwaypoint. It cannot be set when `distanceBudgetInMeters` is specified.\n\nWhen `isSimplifiedPolygon` is false, the maximum time supported is 3600\nseconds; otherwise, it is 21,600 seconds.\n\nExample: \"timeBudgetInSec\":3600",
          "maximum": 21600
        },
        "travelMode": {
          "type": "string",
          "description": "Specifies the travel profile to consider when calculating the range polygon. If\nnot specified, the default value is \"driving\".\n\nExample: \"travelMode\":\"driving\"",
          "default": "driving",
          "enum": [
            "driving",
            "truck"
          ],
          "x-ms-enum": {
            "name": "RouteRangeTravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "Routing profile suitable for cars are used for range polygon calculation."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "Routing profile suitable for commercial vehicles like trucks are used for range\npolygon calculation."
              }
            ]
          }
        }
      }
    },
    "InputSnapToRoadsFeaturesItem": {
      "type": "object",
      "description": "Specifies the input snap to roads points. `GeoJSON` feature object and\nadditional properties. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/GeoJsonPoint",
          "description": "A valid `GeoJSON Point` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details."
        },
        "properties": {
          "type": "object",
          "description": "The properties object is required in a valid GeoJSON but it can be empty since\nthe metadata is not used for snapping to road.",
          "additionalProperties": {}
        }
      },
      "required": [
        "type",
        "geometry",
        "properties"
      ]
    },
    "InputWaypointFeaturesItem": {
      "type": "object",
      "description": "Specifies the input waypoint and viaWaypoint `GeoJSON` feature object and\nadditional properties. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946).",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/GeoJsonPoint",
          "description": "A valid `GeoJSON Point` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details."
        },
        "properties": {
          "$ref": "#/definitions/InputWaypointProperties",
          "description": "Specifies the properties of a waypoint which is a specific location or point\nalong a route or trip that serves as a reference or stopping point."
        }
      },
      "required": [
        "type",
        "geometry",
        "properties"
      ]
    },
    "InputWaypointProperties": {
      "type": "object",
      "description": "Specifies the properties of a waypoint which is a specific location or point\nalong a route or trip that serves as a reference or stopping point.",
      "properties": {
        "pointIndex": {
          "type": "integer",
          "format": "int64",
          "description": "Identify and order the sequence of waypoints in the route. The default value is\nthe `index value` of a features array."
        },
        "pointType": {
          "type": "string",
          "description": "Waypoint type on the route. It can be a stop or an intermediate location that\nthe route must pass through.",
          "default": "waypoint",
          "enum": [
            "waypoint",
            "viaWaypoint"
          ],
          "x-ms-enum": {
            "name": "InputWaypointTypeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "waypoint",
                "value": "waypoint",
                "description": "A waypoint is a specific location or point along a route or trip that serves as\na reference or stopping point."
              },
              {
                "name": "viaWaypoint",
                "value": "viaWaypoint",
                "description": "A viaWaypoint is a specific waypoint that must be passed through or visited\nalong a route or trip."
              }
            ]
          }
        }
      }
    },
    "InputWaypointTypeEnum": {
      "type": "string",
      "description": "Waypoint type on the route. It can be a stop or an intermediate location that\nthe route must pass through.",
      "enum": [
        "waypoint",
        "viaWaypoint"
      ],
      "x-ms-enum": {
        "name": "InputWaypointTypeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "waypoint",
            "value": "waypoint",
            "description": "A waypoint is a specific location or point along a route or trip that serves as\na reference or stopping point."
          },
          {
            "name": "viaWaypoint",
            "value": "viaWaypoint",
            "description": "A viaWaypoint is a specific waypoint that must be passed through or visited\nalong a route or trip."
          }
        ]
      }
    },
    "Instruction": {
      "type": "object",
      "description": "A description of a maneuver in a set of directions.",
      "properties": {
        "maneuverType": {
          "$ref": "#/definitions/ManeuverTypeEnum",
          "description": "The type of maneuver described in this detailed collection. The ManeuverType\nprovides information for a portion of the maneuver specified by the\ncorresponding instruction. For example, the maneuverType of an instruction may\nspecify TurnLeftThenTurnRight, while the associated detail items may provide\nspecifics about the TurnLeft and TurnRight maneuvers"
        },
        "text": {
          "type": "string",
          "description": "The plain text description of the instruction."
        },
        "formattedText": {
          "type": "string",
          "description": "The formatted text description of the instruction."
        },
        "drivingSide": {
          "$ref": "#/definitions/DrivingSideEnum",
          "description": "Indicates left-hand vs. right-hand side driving at the point of the maneuver."
        }
      }
    },
    "ManeuverPointProperties": {
      "type": "object",
      "description": "Specifies the driving instructions and additional properties for each maneuver\npoint in the route Leg.",
      "properties": {
        "routePathPoint": {
          "$ref": "#/definitions/RoutePathPoint",
          "description": "Refers to the index of a point within a specific Leg of a route."
        },
        "order": {
          "$ref": "#/definitions/Order",
          "description": "Sequence for visiting waypoints."
        },
        "steps": {
          "type": "array",
          "description": "Steps between two consecutive maneuver points.",
          "items": {
            "$ref": "#/definitions/RouteStep"
          }
        },
        "instruction": {
          "$ref": "#/definitions/Instruction",
          "description": "A description of a maneuver in a set of directions."
        },
        "address": {
          "$ref": "#/definitions/NavigationPointPropertiesAddress",
          "description": "The administrative district and country region for the waypoints and maneuver\npoints on the route."
        },
        "sideOfStreet": {
          "$ref": "#/definitions/SideOfStreetEnum",
          "description": "The side of the street where the destination is found based on the arrival\ndirection. This field applies to the last maneuverPoint only."
        },
        "signs": {
          "type": "array",
          "description": "Signage text for the route. There may be more than one sign value.",
          "items": {
            "type": "string"
          }
        },
        "towardsRoadName": {
          "type": "string",
          "description": "The name of the street that the route goes towards in the first `ManeuverPoint`."
        },
        "exitIdentifier": {
          "type": "string",
          "description": "The name or number of the exit associated with this route step."
        },
        "distanceInMeters": {
          "type": "number",
          "format": "float",
          "description": "The physical distance in meters covered by this route step."
        },
        "durationInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "The time that it takes, in seconds, to travel a corresponding `TravelDistance`."
        },
        "travelMode": {
          "type": "string",
          "description": "The mode of travel for the route path in the response.",
          "default": "driving",
          "enum": [
            "driving",
            "truck",
            "walking",
            "other"
          ],
          "x-ms-enum": {
            "name": "RoutePathTravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "Routes optimized for cars."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "Routes optimized for large size trucks based on the vehicle specification."
              },
              {
                "name": "walking",
                "value": "walking",
                "description": "Routes optimized for pedestrians."
              },
              {
                "name": "other",
                "value": "other",
                "description": "RouteTravelMode is returned as \"other\" for the truck travelMode when the truck\nroute is not available for a particular section of a route."
              }
            ]
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/FeatureProperties"
        }
      ],
      "x-ms-discriminator-value": "ManeuverPoint"
    },
    "ManeuverTypeEnum": {
      "type": "string",
      "description": "The type of maneuver described in this detailed collection. The ManeuverType\nprovides information for a portion of the maneuver specified by the\ncorresponding instruction. For example, the maneuverType of an instruction may\nspecify TurnLeftThenTurnRight, while the associated detail items may provide\nspecifics about the TurnLeft and TurnRight maneuvers",
      "enum": [
        "ArriveFinish",
        "ArriveIntermediate",
        "BearLeft",
        "BearLeftThenBearLeft",
        "BearLeftThenBearRight",
        "BearLeftThenTurnLeft",
        "BearLeftThenTurnRight",
        "BearRight",
        "BearRightThenBearLeft",
        "BearRightThenBearRight",
        "BearRightThenTurnLeft",
        "BearRightThenTurnRight",
        "BearThenKeep",
        "DepartStart",
        "BearThenMerge",
        "Continue",
        "DepartIntermediateStop",
        "DepartIntermediateStopReturning",
        "EnterRoundabout",
        "ExitRoundabout",
        "EnterThenExitRoundabout",
        "ExitRoundaboutRight",
        "ExitRoundaboutLeft",
        "Follow",
        "GoAroundRoundabout",
        "KeepLeft",
        "KeepOnRampLeft",
        "KeepOnRampRight",
        "KeepOnRampStraight",
        "KeepRight",
        "KeepStraight",
        "KeepToStayLeft",
        "KeepToStayRight",
        "KeepToStayStraight",
        "MergeFreeway",
        "MergeHighway",
        "MergeMotorway",
        "MotorwayExitLeft",
        "MotorwayExitRight",
        "None",
        "RampThenHighwayLeft",
        "RampThenHighwayRight",
        "RampThenHighwayStraight",
        "RoadNameChange",
        "SwitchToParallelRoad",
        "SwitchToMainRoad",
        "Take",
        "TakeFerry",
        "TakeExit",
        "TakeRamp",
        "TakeRampLeft",
        "TakeRampRight",
        "TakeRampStraight",
        "TurnBack",
        "TurnLeft",
        "TurnLeftSharp",
        "TurnLeftThenBearLeft",
        "TurnLeftThenBearRight",
        "TurnLeftThenTurnLeft",
        "TurnLeftThenTurnRight",
        "TurnRight",
        "TurnRightSharp",
        "TurnRightThenBearLeft",
        "TurnRightThenBearRight",
        "TurnRightThenTurnLeft",
        "TurnRightThenTurnRight",
        "TurnThenMerge",
        "TurnToStayLeft",
        "TurnToStayRight",
        "Unknown",
        "UTurn",
        "Wait",
        "Walk"
      ],
      "x-ms-enum": {
        "name": "ManeuverTypeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "ArriveFinish",
            "value": "ArriveFinish",
            "description": "Arrive at the final destination."
          },
          {
            "name": "ArriveIntermediate",
            "value": "ArriveIntermediate",
            "description": "Arrive at an intermediate waypoint."
          },
          {
            "name": "BearLeft",
            "value": "BearLeft",
            "description": "Bear left."
          },
          {
            "name": "BearLeftThenBearLeft",
            "value": "BearLeftThenBearLeft",
            "description": "Bear left and then bear left again."
          },
          {
            "name": "BearLeftThenBearRight",
            "value": "BearLeftThenBearRight",
            "description": "Bear left and then bear right."
          },
          {
            "name": "BearLeftThenTurnLeft",
            "value": "BearLeftThenTurnLeft",
            "description": "Bear left and then turn left."
          },
          {
            "name": "BearLeftThenTurnRight",
            "value": "BearLeftThenTurnRight",
            "description": "Bear left and then turn right."
          },
          {
            "name": "BearRight",
            "value": "BearRight",
            "description": "Bear right."
          },
          {
            "name": "BearRightThenBearLeft",
            "value": "BearRightThenBearLeft",
            "description": "Bear right and then bear left."
          },
          {
            "name": "BearRightThenBearRight",
            "value": "BearRightThenBearRight",
            "description": "Bear right and then bear right again."
          },
          {
            "name": "BearRightThenTurnLeft",
            "value": "BearRightThenTurnLeft",
            "description": "Bear right and then turn left."
          },
          {
            "name": "BearRightThenTurnRight",
            "value": "BearRightThenTurnRight",
            "description": "Bear right and then turn right."
          },
          {
            "name": "BearThenKeep",
            "value": "BearThenKeep",
            "description": "Bear instruction and then a keep instruction"
          },
          {
            "name": "DepartStart",
            "value": "DepartStart",
            "description": "Leave the starting point."
          },
          {
            "name": "BearThenMerge",
            "value": "BearThenMerge",
            "description": "Bear instruction and then a merge instruction."
          },
          {
            "name": "Continue",
            "value": "Continue",
            "description": "Continue on the current road."
          },
          {
            "name": "DepartIntermediateStop",
            "value": "DepartIntermediateStop",
            "description": "Leave an intermediate waypoint in a different direction and road than you\narrived on."
          },
          {
            "name": "DepartIntermediateStopReturning",
            "value": "DepartIntermediateStopReturning",
            "description": "Leave an intermediate waypoint in the same direction and on the same road that\nyou arrived on."
          },
          {
            "name": "EnterRoundabout",
            "value": "EnterRoundabout",
            "description": "Enter a roundabout."
          },
          {
            "name": "ExitRoundabout",
            "value": "ExitRoundabout",
            "description": "Exit a roundabout."
          },
          {
            "name": "EnterThenExitRoundabout",
            "value": "EnterThenExitRoundabout",
            "description": "Enter and exit a roundabout."
          },
          {
            "name": "ExitRoundaboutRight",
            "value": "ExitRoundaboutRight",
            "description": "At the roundabout take the exit on the right."
          },
          {
            "name": "ExitRoundaboutLeft",
            "value": "ExitRoundaboutLeft",
            "description": "At the roundabout take the exit on the left."
          },
          {
            "name": "Follow",
            "value": "Follow",
            "description": "Follow."
          },
          {
            "name": "GoAroundRoundabout",
            "value": "GoAroundRoundabout",
            "description": "Go around the roundabout."
          },
          {
            "name": "KeepLeft",
            "value": "KeepLeft",
            "description": "Keep left onto a different road."
          },
          {
            "name": "KeepOnRampLeft",
            "value": "KeepOnRampLeft",
            "description": "Keep left and continue onto ramp."
          },
          {
            "name": "KeepOnRampRight",
            "value": "KeepOnRampRight",
            "description": "Keep right and continue onto ramp."
          },
          {
            "name": "KeepOnRampStraight",
            "value": "KeepOnRampStraight",
            "description": "Keep straight and continue onto ramp."
          },
          {
            "name": "KeepRight",
            "value": "KeepRight",
            "description": "Keep right onto a different road."
          },
          {
            "name": "KeepStraight",
            "value": "KeepStraight",
            "description": "Keep straight onto a different road."
          },
          {
            "name": "KeepToStayLeft",
            "value": "KeepToStayLeft",
            "description": "Keep left to stay on the same road."
          },
          {
            "name": "KeepToStayRight",
            "value": "KeepToStayRight",
            "description": "Keep right to stay on the same road."
          },
          {
            "name": "KeepToStayStraight",
            "value": "KeepToStayStraight",
            "description": "Keep straight to stay on the same road."
          },
          {
            "name": "MergeFreeway",
            "value": "MergeFreeway",
            "description": "Merge onto a freeway."
          },
          {
            "name": "MergeHighway",
            "value": "MergeHighway",
            "description": "Merge onto a highway."
          },
          {
            "name": "MergeMotorway",
            "value": "MergeMotorway",
            "description": "Merge onto a motorway."
          },
          {
            "name": "MotorwayExitLeft",
            "value": "MotorwayExitLeft",
            "description": "Take the left exit."
          },
          {
            "name": "MotorwayExitRight",
            "value": "MotorwayExitRight",
            "description": "Take the right exit."
          },
          {
            "name": "None",
            "value": "None",
            "description": "No instruction."
          },
          {
            "name": "RampThenHighwayLeft",
            "value": "RampThenHighwayLeft",
            "description": "Take left ramp onto highway. This is part of a combined instruction."
          },
          {
            "name": "RampThenHighwayRight",
            "value": "RampThenHighwayRight",
            "description": "Take right ramp onto highway. This is part of a combined instruction."
          },
          {
            "name": "RampThenHighwayStraight",
            "value": "RampThenHighwayStraight",
            "description": "Stay straight to take ramp onto highway. This is part of a combined instruction."
          },
          {
            "name": "RoadNameChange",
            "value": "RoadNameChange",
            "description": "Road name changes."
          },
          {
            "name": "SwitchToParallelRoad",
            "value": "SwitchToParallelRoad",
            "description": "Switch to the parallel road."
          },
          {
            "name": "SwitchToMainRoad",
            "value": "SwitchToMainRoad",
            "description": "Switch to the main road."
          },
          {
            "name": "Take",
            "value": "Take",
            "description": "Take the road. This instruction is used when you are entering or exiting a\nferry."
          },
          {
            "name": "TakeFerry",
            "value": "TakeFerry",
            "description": "Take the ferry."
          },
          {
            "name": "TakeExit",
            "value": "TakeExit",
            "description": "Take the exit."
          },
          {
            "name": "TakeRamp",
            "value": "TakeRamp",
            "description": "Take ramp."
          },
          {
            "name": "TakeRampLeft",
            "value": "TakeRampLeft",
            "description": "Take ramp to the left."
          },
          {
            "name": "TakeRampRight",
            "value": "TakeRampRight",
            "description": "Take ramp to the right."
          },
          {
            "name": "TakeRampStraight",
            "value": "TakeRampStraight",
            "description": "Stay straight to take ramp."
          },
          {
            "name": "TurnBack",
            "value": "TurnBack",
            "description": "Turn back sharply."
          },
          {
            "name": "TurnLeft",
            "value": "TurnLeft",
            "description": "Turn left."
          },
          {
            "name": "TurnLeftSharp",
            "value": "TurnLeftSharp",
            "description": "Take a sharp left turn."
          },
          {
            "name": "TurnLeftThenBearLeft",
            "value": "TurnLeftThenBearLeft",
            "description": "Turn left and then bear left."
          },
          {
            "name": "TurnLeftThenBearRight",
            "value": "TurnLeftThenBearRight",
            "description": "Turn left and then bear right."
          },
          {
            "name": "TurnLeftThenTurnLeft",
            "value": "TurnLeftThenTurnLeft",
            "description": "Turn left and then turn left again."
          },
          {
            "name": "TurnLeftThenTurnRight",
            "value": "TurnLeftThenTurnRight",
            "description": "Turn left and then turn right."
          },
          {
            "name": "TurnRight",
            "value": "TurnRight",
            "description": "Turn right."
          },
          {
            "name": "TurnRightSharp",
            "value": "TurnRightSharp",
            "description": "Take a sharp right turn."
          },
          {
            "name": "TurnRightThenBearLeft",
            "value": "TurnRightThenBearLeft",
            "description": "Turn right and then bear left."
          },
          {
            "name": "TurnRightThenBearRight",
            "value": "TurnRightThenBearRight",
            "description": "Turn right and then bear right."
          },
          {
            "name": "TurnRightThenTurnLeft",
            "value": "TurnRightThenTurnLeft",
            "description": "Turn right and then turn left."
          },
          {
            "name": "TurnRightThenTurnRight",
            "value": "TurnRightThenTurnRight",
            "description": "Turn right and then turn right again"
          },
          {
            "name": "TurnThenMerge",
            "value": "TurnThenMerge",
            "description": "Turn instruction followed by a merge instruction."
          },
          {
            "name": "TurnToStayLeft",
            "value": "TurnToStayLeft",
            "description": "Turn left to stay on the same road."
          },
          {
            "name": "TurnToStayRight",
            "value": "TurnToStayRight",
            "description": "Turn right to stay on the same road."
          },
          {
            "name": "Unknown",
            "value": "Unknown",
            "description": "The instruction is unknown."
          },
          {
            "name": "UTurn",
            "value": "UTurn",
            "description": "Make a u-turn to go in the opposite direction."
          },
          {
            "name": "Wait",
            "value": "Wait",
            "description": "Wait"
          },
          {
            "name": "Walk",
            "value": "Walk",
            "description": "Walk"
          }
        ]
      }
    },
    "MapsErrorDetail": {
      "type": "object",
      "description": "The error detail.",
      "properties": {
        "code": {
          "type": "string",
          "description": "One of a server-defined set of error codes.",
          "readOnly": true
        },
        "message": {
          "type": "string",
          "description": "A human-readable representation of the error.",
          "readOnly": true
        },
        "target": {
          "type": "string",
          "description": "The target of the error.",
          "readOnly": true
        },
        "details": {
          "type": "array",
          "description": "An array of details about specific errors that led to this reported error.",
          "items": {
            "$ref": "#/definitions/MapsErrorDetail"
          },
          "readOnly": true
        },
        "innererror": {
          "$ref": "#/definitions/MapsInnerError",
          "description": "An object containing more specific information than the current object about\nthe error.",
          "readOnly": true
        }
      }
    },
    "MapsErrorResponse": {
      "type": "object",
      "description": "Common error response for Azure Maps APIs to return error details for failed\noperations.",
      "properties": {
        "error": {
          "$ref": "#/definitions/MapsErrorDetail",
          "description": "The error detail.",
          "readOnly": true
        }
      },
      "required": [
        "error"
      ]
    },
    "MapsInnerError": {
      "type": "object",
      "description": "An object containing more specific information than the current object about\nthe error.",
      "properties": {
        "code": {
          "type": "string",
          "description": "The error code.",
          "readOnly": true
        },
        "innererror": {
          "$ref": "#/definitions/MapsInnerError",
          "description": "An object containing more specific information than the current object about\nthe error.",
          "readOnly": true
        }
      }
    },
    "MultiLineStringGeometry": {
      "type": "object",
      "description": "Specifies the `GeoJSON` MultiLineString Geometry object. For more information,\nsee [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946).",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson MultiLineString` geometry.",
          "items": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/RouteDirectionsGeometry"
        }
      ],
      "x-ms-discriminator-value": "MultiLineString"
    },
    "NavigationPointProperties": {
      "type": "object",
      "description": "Waypoint and ManeuverPoint properties.",
      "properties": {
        "routePathPoint": {
          "$ref": "#/definitions/RoutePathPoint",
          "description": "Refers to the index of a point within a specific Leg of a route."
        },
        "order": {
          "$ref": "#/definitions/Order",
          "description": "Sequence for visiting waypoints."
        },
        "steps": {
          "type": "array",
          "description": "Steps between two consecutive maneuver points.",
          "items": {
            "$ref": "#/definitions/RouteStep"
          }
        },
        "instruction": {
          "$ref": "#/definitions/Instruction",
          "description": "A description of a maneuver in a set of directions."
        },
        "address": {
          "$ref": "#/definitions/NavigationPointPropertiesAddress",
          "description": "The administrative district and country region for the waypoints and maneuver\npoints on the route."
        },
        "sideOfStreet": {
          "$ref": "#/definitions/SideOfStreetEnum",
          "description": "The side of the street where the destination is found based on the arrival\ndirection. This field applies to the last maneuverPoint only."
        },
        "signs": {
          "type": "array",
          "description": "Signage text for the route. There may be more than one sign value.",
          "items": {
            "type": "string"
          }
        },
        "towardsRoadName": {
          "type": "string",
          "description": "The name of the street that the route goes towards in the first `ManeuverPoint`."
        },
        "exitIdentifier": {
          "type": "string",
          "description": "The name or number of the exit associated with this route step."
        },
        "distanceInMeters": {
          "type": "number",
          "format": "float",
          "description": "The physical distance in meters covered by this route step."
        },
        "durationInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "The time that it takes, in seconds, to travel a corresponding `TravelDistance`."
        },
        "travelMode": {
          "type": "string",
          "description": "The mode of travel for the route path in the response.",
          "default": "driving",
          "enum": [
            "driving",
            "truck",
            "walking",
            "other"
          ],
          "x-ms-enum": {
            "name": "RoutePathTravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "Routes optimized for cars."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "Routes optimized for large size trucks based on the vehicle specification."
              },
              {
                "name": "walking",
                "value": "walking",
                "description": "Routes optimized for pedestrians."
              },
              {
                "name": "other",
                "value": "other",
                "description": "RouteTravelMode is returned as \"other\" for the truck travelMode when the truck\nroute is not available for a particular section of a route."
              }
            ]
          }
        }
      }
    },
    "NavigationPointPropertiesAddress": {
      "type": "object",
      "description": "The administrative district and country region for the waypoints and maneuver\npoints on the route.",
      "properties": {
        "countryRegion": {
          "$ref": "#/definitions/CountryRegion",
          "description": "Represents a country or region, containing related details."
        },
        "adminDistricts": {
          "type": "array",
          "description": "The subdivision name in the country or region for an address. This element is\ntypically treated as the first order administrative subdivision, but in some\ncases it also contains the second, third, or fourth order subdivision in a\ncountry, dependency, or region.",
          "items": {
            "$ref": "#/definitions/AdminDistrict"
          }
        }
      }
    },
    "OptimizedWaypoint": {
      "type": "object",
      "description": "Optimized way point object.",
      "properties": {
        "inputIndex": {
          "type": "integer",
          "format": "int64",
          "description": "Way point index provided by the user."
        },
        "optimizedIndex": {
          "type": "integer",
          "format": "int64",
          "description": "Optimized way point index from the system."
        }
      }
    },
    "Order": {
      "type": "object",
      "description": "Sequence for visiting waypoints.",
      "properties": {
        "inputIndex": {
          "type": "integer",
          "format": "int64",
          "description": "User-provided index for waypoint"
        },
        "optimizedIndex": {
          "type": "integer",
          "format": "int64",
          "description": "System-optimized waypoint"
        }
      }
    },
    "PointGeometry": {
      "type": "object",
      "description": "The origin point passed as a valid `GeoJSON` Geometry object, from which the\nrange polygon should be calculated. Please refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.\n\n`Note`: The API will snap the requested origin point to the nearest road\nnetwork and will use that for range calculation. It will be returned as a\n`center` point in the response.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "A `Position` is an array of numbers with two or more elements. The first two\nelements are _longitude_ and _latitude_, precisely in that order.\n_Altitude/Elevation_ is an optional third element. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.1) for details.",
          "items": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/RouteDirectionsGeometry"
        }
      ],
      "x-ms-discriminator-value": "Point"
    },
    "PropertiesTypeEnum": {
      "type": "string",
      "description": "Output type.",
      "enum": [
        "ManeuverPoint",
        "Waypoint",
        "RoutePath"
      ],
      "x-ms-enum": {
        "name": "PropertiesTypeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "ManeuverPoint",
            "value": "ManeuverPoint",
            "description": "A maneuverPoint is a specific point on a route or trip where a change in\ndirection or mode of transportation is required or recommended."
          },
          {
            "name": "Waypoint",
            "value": "Waypoint",
            "description": "A waypoint is a specific location or point along a route or trip that serves as\na reference or stopping point."
          },
          {
            "name": "RoutePath",
            "value": "RoutePath",
            "description": "A routePath is a line that represents the path of a route or trip."
          }
        ]
      }
    },
    "RouteDirectionOptimizeRouteEnum": {
      "type": "string",
      "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastestWithoutTraffic\" which returns the route to minimize the\ntravel time without using current traffic information.\n\nExample: \"optimizeRoute\":\"shortest\"",
      "enum": [
        "short",
        "shortest",
        "fastestWithoutTraffic",
        "fastestWithTraffic"
      ],
      "x-ms-enum": {
        "name": "RouteDirectionOptimizeRouteEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Short",
            "value": "short",
            "description": "The route is calculated to balance fast travel time and short distance, rather\nthan prioritizing just one. It's optimized for both speed and efficiency.\nTraffic information is not used."
          },
          {
            "name": "Shortest",
            "value": "shortest",
            "description": "The route is calculated to minimize the distance. Traffic information is not\nused."
          },
          {
            "name": "FastestWithoutTraffic",
            "value": "fastestWithoutTraffic",
            "description": "Finds the fastest route, without factoring in traffic information."
          },
          {
            "name": "FastestWithTraffic",
            "value": "fastestWithTraffic",
            "description": "The route is calculated to minimize the time using current traffic information.\n`Note`: Only supported for driving and truck travelMode."
          }
        ]
      }
    },
    "RouteDirectionVehicleSpec": {
      "type": "object",
      "description": "Specifies the vehicle attributes such as size, weight, max speed, type of\ncargo, etc. for truck routing only. This helps avoid low bridge clearances,\nroad restrictions, difficult right turns to provide the optimized truck route\nbased on the vehicle specifications.\n\nIS`Note`: Only supported for truck travelMode.",
      "properties": {
        "isVehicleCommercial": {
          "type": "boolean",
          "description": "Whether the vehicle is used for commercial purposes. Commercial vehicles may\nnot be allowed to drive on some roads.",
          "default": false
        },
        "length": {
          "type": "number",
          "format": "double",
          "description": "Length of the vehicle in meters. A value of 0 means that length restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "width": {
          "type": "number",
          "format": "double",
          "description": "Width of the vehicle in meters. A value of 0 means that width restrictions are\nnot considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "height": {
          "type": "number",
          "format": "double",
          "description": "Height of the vehicle in meters. A value of 0 means that height restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "weight": {
          "type": "integer",
          "format": "int64",
          "description": "Weight of the vehicle in kilograms. A value of 0 means that weight restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "maxSpeed": {
          "type": "integer",
          "format": "int64",
          "description": "Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile\nis used to check whether a vehicle is allowed on motorways.\n\nA value of 0 means that an appropriate value for the vehicle will be determined\nand applied during route planning.\n\nA non-zero value may be overridden during route planning. For example, the\ncurrent traffic flow is 60 km/hour. If the vehicle maximum speed is set to 50\nkm/hour, the routing engine will consider 60 km/hour as this is the current\nsituation. If the maximum speed of the vehicle is provided as 80 km/hour but\nthe current traffic flow is 60 km/hour, then routing engine will again use 60\nkm/hour.",
          "default": 0,
          "minimum": 0,
          "maximum": 250
        },
        "axleWeight": {
          "type": "integer",
          "format": "int64",
          "description": "Weight per axle of the vehicle in kg. A value of 0 means that weight\nrestrictions per axle are not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "loadType": {
          "type": "array",
          "description": "Types of cargo that may be classified as hazardous materials and restricted\nfrom some roads. Available vehicleLoadType values are US Hazmat classes 1\nthrough 9, plus generic classifications for use in other countries. Values\nbeginning with USHazmat are for US routing while otherHazmat should be used for\nall other countries. vehicleLoadType supports multiple values in a request.",
          "items": {
            "$ref": "#/definitions/VehicleLoadTypeEnum"
          }
        },
        "adrTunnelRestrictionCode": {
          "$ref": "#/definitions/AdrTunnelRestrictionCodeEnum",
          "description": "The ADR tunnel restriction code. ADR is a European agreement concerning the\ninternational carriage of dangerous goods by road. The ADR tunnel restriction\ncode is used to determine whether a vehicle is allowed to pass through a tunnel\nwith restrictions on the carriage of dangerous goods."
        },
        "axleCount": {
          "type": "integer",
          "format": "int64",
          "description": "The number of axles on the vehicle."
        }
      }
    },
    "RouteDirectionsGeometry": {
      "type": "object",
      "description": "A valid `GeoJSON` Geometry object. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946).",
      "properties": {
        "type": {
          "$ref": "#/definitions/GeoJsonObjectType",
          "description": "Specifies the geometry type for the `GeoJSON` Geometry object. For more\ninformation, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        }
      },
      "discriminator": "type",
      "required": [
        "type"
      ]
    },
    "RouteDirectionsResponse": {
      "type": "object",
      "description": "Alternative route.",
      "properties": {
        "alternativeRoutes": {
          "type": "array",
          "description": "Alternative route.",
          "items": {
            "$ref": "#/definitions/FeatureCollection"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/FeatureCollection"
        }
      ]
    },
    "RouteLeg": {
      "type": "object",
      "description": "Information about a section of a route between two waypoints. More information\nabout the fields contained in a route Leg:",
      "properties": {
        "routePathRange": {
          "$ref": "#/definitions/RoutePathRange",
          "description": "Refers to the range covered by a specific Leg of a route or path."
        },
        "distanceInMeters": {
          "type": "number",
          "format": "float",
          "description": "The physical distance in meters covered by a route Leg."
        },
        "durationInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "Estimated travel time in seconds that does not include delays on the route due\nto traffic conditions."
        },
        "durationTrafficInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "The time that it takes, in seconds, to travel a corresponding `TravelDistance`\nwith current traffic conditions. This value is provided if `optimizeRoute`\nincludes traffic considerations."
        },
        "departureAt": {
          "type": "string",
          "format": "date-time",
          "description": "The estimated departure time for the leg, which takes into account the traffic\nconditions, is formatted as a dateTime value defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). It will reference the\ntimezone offset by either `departAt` or `arrivalAt`. If not, then the UTC time\nwill be used."
        },
        "arrivalAt": {
          "type": "string",
          "format": "date-time",
          "description": "The estimated arrival time for the leg, which takes into account the traffic\nconditions, is formatted as a dateTime value defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). It will reference the\ntimezone offset by either `departAt` or `arrivalAt`. If not, then the UTC time\nwill be used."
        }
      }
    },
    "RouteMatrixAsyncOptimizeRouteEnum": {
      "type": "string",
      "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastest\" which returns the route to minimize the travel time.\n\nExample: \"optimizeRoute\":\"shortest\"",
      "enum": [
        "shortest",
        "fastest"
      ],
      "x-ms-enum": {
        "name": "RouteMatrixAsyncOptimizeRouteEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Shortest",
            "value": "shortest",
            "description": "Finds the shortest route to optimize route by travel distance."
          },
          {
            "name": "Fastest",
            "value": "fastest",
            "description": "Finds the fastest route to optimize route by travel time."
          }
        ]
      }
    },
    "RouteMatrixAsyncRequest": {
      "type": "object",
      "description": "Use to get a route matrix showing the travel time and distance for all possible\npairs in a list of origins and destination. `GeoJSON` feature object and\nadditional properties. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "A set of origin and destination points passed as GeoJSON MultiPoint features\nfor the input matrix. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details on the GeoJSON\nformat.",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "$ref": "#/definitions/InputRouteMatrixFeaturesItem"
          }
        },
        "departAt": {
          "type": "string",
          "description": "The date and time of departure from the origin point formatted as a `dateTime`\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nThe `departAt` parameter cannot be used in conjunction with `arriveAt`.\n\nThe `departAt` also supports:\n\n`any` value tailored to the use case where the time context is irrelevant. The\n`traffic=live` parameter value cannot be used together with `any`.\n\n`now` value to set the departure time to the processing time of each individual\ncell. Processing time may be any time between submission and its completion.\nThis mode is best used together with traffic=live.\n\nDefault value: `any` if `departAt` is not specified.\n\nExample:\n\n\"departAt\": \"2024-12-01T09:30:00.000-07:00\""
        },
        "arriveAt": {
          "type": "string",
          "description": "The date and time of arrival at the destination point formatted as a `dateTime`\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nThe `arriveAt` parameter cannot be used in conjunction with `departAt`.\n\nThe `arriveAt` also supports `any` value which is tailored to the use case\nwhere the time context is irrelevant. The `traffic=live` parameter value cannot\nbe used together with `any`.\n\nDefault value: `any` if `arriveAt` is not specified.\n\nExample: \"arriveAt\": \"2024-12-01T09:30:00.000-07:00\""
        },
        "travelMode": {
          "type": "string",
          "description": "Specifies the travel profile to consider when calculating the matrix. If not\nspecified, the default value is \"driving\".\n\nExample: \"travelMode\":\"driving\"",
          "default": "driving",
          "enum": [
            "driving",
            "truck",
            "walking"
          ],
          "x-ms-enum": {
            "name": "RouteMatrixTravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "Routing profile suitable for cars are used for route matrix calculation."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "Routing profile suitable for commercial vehicles like trucks are used for route\nmatrix calculation."
              },
              {
                "name": "walking",
                "value": "walking",
                "description": "The returned routes are optimized for pedestrians, including the use of\nsidewalks."
              }
            ]
          }
        },
        "optimizeRoute": {
          "type": "string",
          "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastest\" which returns the route to minimize the travel time.\n\nExample: \"optimizeRoute\":\"shortest\"",
          "default": "fastest",
          "enum": [
            "shortest",
            "fastest"
          ],
          "x-ms-enum": {
            "name": "RouteMatrixAsyncOptimizeRouteEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "Shortest",
                "value": "shortest",
                "description": "Finds the shortest route to optimize route by travel distance."
              },
              {
                "name": "Fastest",
                "value": "fastest",
                "description": "Finds the fastest route to optimize route by travel time."
              }
            ]
          }
        },
        "traffic": {
          "type": "string",
          "description": "Specifies how traffic is considered for computing routes.\n\nDefault value: `historical`",
          "default": "historical",
          "enum": [
            "historical",
            "live"
          ],
          "x-ms-enum": {
            "name": "RouteMatrixTrafficEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "Historical",
                "value": "historical",
                "description": "Route calculation considers historical travel times and long term closures.\nTraffic jams and short-term closures during the travel time window do not\ninfluence routing or travel time."
              },
              {
                "name": "Live",
                "value": "live",
                "description": "In addition to historical travel times, route calculation considers traffic\njams and short- and long-term closures during the travel time window.\n\n`Note`: `traffic=live` may not be used in conjunction with `arriveAt=any` and\n`departAt=any`"
              }
            ]
          }
        },
        "avoid": {
          "type": "array",
          "description": "Specifies restrictions that the route calculation should honor when determining\nthe route. Avoid supports multiple values in a request and is only supported\nfor the driving and truck travelMode.",
          "items": {
            "$ref": "#/definitions/RouteMatrixAvoidEnum"
          }
        },
        "vehicleSpec": {
          "$ref": "#/definitions/RouteMatrixVehicleSpec",
          "description": "Specifies the vehicle attributes such as vehicle height, weight, max speed,\ntype of cargo, etc. to consider when calculating the route matrix. This helps\navoid low bridge clearances, road restrictions, difficult right turns to\nprovide the optimized route based on the vehicle specifications. Vehicle\nattributes are specified within the vehicleSpec property."
        }
      },
      "required": [
        "type",
        "features"
      ]
    },
    "RouteMatrixAsyncResponse": {
      "type": "object",
      "description": "Specifies the driving instructions and additional properties for each maneuver\npoint in the route Leg.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "type": "object",
          "description": "The geometry object is null",
          "x-nullable": true,
          "additionalProperties": {}
        },
        "properties": {
          "$ref": "#/definitions/RouteMatrixFeatureProperties",
          "description": "Route Matrix properties."
        }
      },
      "required": [
        "type",
        "geometry",
        "properties"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/RouteOperationResponse"
        }
      ],
      "x-ms-discriminator-value": "RouteMatrix"
    },
    "RouteMatrixAvoidEnum": {
      "type": "string",
      "description": "Specifies restrictions that the route calculation should honor when determining\nthe route. Avoid supports multiple values in a request and is only supported\nfor the driving and truck travelMode.",
      "enum": [
        "tollRoads",
        "unpavedRoads"
      ],
      "x-ms-enum": {
        "name": "RouteMatrixAvoidEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "TollRoads",
            "value": "tollRoads",
            "description": "Avoids the use of toll roads in the route."
          },
          {
            "name": "UnpavedRoads",
            "value": "unpavedRoads",
            "description": "Avoids unpaved roads in the route."
          }
        ]
      }
    },
    "RouteMatrixFeatureProperties": {
      "type": "object",
      "description": "Route Matrix properties.",
      "properties": {
        "summary": {
          "$ref": "#/definitions/RouteMatrixSummary",
          "description": "Summary for the route matrix request"
        },
        "matrix": {
          "type": "array",
          "description": "The matrix of route results.",
          "items": {
            "$ref": "#/definitions/RouteMatrixItemResult"
          }
        }
      }
    },
    "RouteMatrixItemResult": {
      "type": "object",
      "description": "Route Matrix item result",
      "properties": {
        "statusCode": {
          "type": "integer",
          "format": "int32",
          "description": "The HTTP status code of the current cell."
        },
        "originIndex": {
          "type": "integer",
          "format": "int32",
          "description": "Index of the origin point"
        },
        "destinationIndex": {
          "type": "integer",
          "format": "int32",
          "description": "Index of the destination point"
        },
        "departureAt": {
          "type": "string",
          "format": "date-time",
          "description": "The estimated departure time, which takes into account the traffic conditions,\nis formatted as a `dateTime` value defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). It will reference the\ntimezone offset by either `departAt` or `arrivalAt`. If not, then the UTC time\nwill be used. If departAt or arriveAt is `any`, then departureAt is absent."
        },
        "arrivalAt": {
          "type": "string",
          "format": "date-time",
          "description": "The estimated arrival time, which takes into account the traffic conditions, is\nformatted as a `dateTime` value defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). It will reference the\ntimezone offset by either `departAt` or `arrivalAt`. If not, then the UTC time\nwill be used. If departAt or arriveAt is any, then departureAt is absent."
        },
        "distanceInMeters": {
          "type": "number",
          "format": "double",
          "description": "Length In Meters property"
        },
        "durationInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "Estimated travel time in seconds that does not include delays on the route due\nto traffic conditions."
        },
        "durationTrafficInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "The time that it takes, in seconds, to travel a corresponding `TravelDistance`\nwith current traffic conditions. This value is provided if `optimizeRoute`\nincludes traffic considerations."
        },
        "error": {
          "$ref": "#/definitions/ErrorDetail",
          "description": "The error detail."
        }
      }
    },
    "RouteMatrixOptimizeRouteEnum": {
      "type": "string",
      "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastest\" which returns the route to minimize the travel time.\n\nExample: \"optimizeRoute\":\"fastest \"",
      "enum": [
        "fastest"
      ],
      "x-ms-enum": {
        "name": "RouteMatrixOptimizeRouteEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Fastest",
            "value": "fastest",
            "description": "Finds the fastest route to optimize route by travel time.\n\nOnly `fastest` is supported for the Route Matrix sync API. To use the other\ntypes, check the Route Matrix async API."
          }
        ]
      }
    },
    "RouteMatrixRequest": {
      "type": "object",
      "description": "Use to get a route matrix showing the travel time and distance for all possible\npairs in a list of origins and destination. `GeoJSON` feature object and\nadditional properties. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "A set of origin and destination points passed as GeoJSON MultiPoint features\nfor the input matrix. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details on the GeoJSON\nformat.",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "$ref": "#/definitions/InputRouteMatrixFeaturesItem"
          }
        },
        "departAt": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time of departure from the origin point formatted as a `dateTime`\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nThe `departAt` parameter cannot be used in conjunction with `arriveAt`.\n\nThe `departAt` also supports:\n\n`any` value tailored to the use case where the time context is irrelevant. The\n`traffic=live` parameter value cannot be used together with `any`.\n\n`now` value to set the departure time to the processing time of each individual\ncell. Processing time may be any time between submission and its completion.\nThis mode is best used together with traffic=live.\n\nDefault value: `any` if `departAt` is not specified.\n\nExample:\n\n\"departAt\": \"2024-12-01T09:30:00.000-07:00\""
        },
        "arriveAt": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time of arrival at the destination point formatted as a `dateTime`\nvalue defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). When a time zone\noffset is not specified, UTC will be assumed.\n\nThe `arriveAt` parameter cannot be used in conjunction with `departAt`.\n\nThe `arriveAt` also supports `any` value which is tailored to the use case\nwhere the time context is irrelevant. The `traffic=live` parameter value cannot\nbe used together with `any`.\n\nDefault value: `any` if `arriveAt` is not specified.\n\nExample: \"arriveAt\": \"2024-12-01T09:30:00.000-07:00\""
        },
        "travelMode": {
          "type": "string",
          "description": "Specifies the travel profile to consider when calculating the matrix. If not\nspecified, the default value is \"driving\".\n\nExample: \"travelMode\":\"driving\"",
          "default": "driving",
          "enum": [
            "driving",
            "truck",
            "walking"
          ],
          "x-ms-enum": {
            "name": "RouteMatrixTravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "Routing profile suitable for cars are used for route matrix calculation."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "Routing profile suitable for commercial vehicles like trucks are used for route\nmatrix calculation."
              },
              {
                "name": "walking",
                "value": "walking",
                "description": "The returned routes are optimized for pedestrians, including the use of\nsidewalks."
              }
            ]
          }
        },
        "optimizeRoute": {
          "type": "string",
          "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastest\" which returns the route to minimize the travel time.\n\nExample: \"optimizeRoute\":\"fastest \"",
          "default": "fastest",
          "enum": [
            "fastest"
          ],
          "x-ms-enum": {
            "name": "RouteMatrixOptimizeRouteEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "Fastest",
                "value": "fastest",
                "description": "Finds the fastest route to optimize route by travel time.\n\nOnly `fastest` is supported for the Route Matrix sync API. To use the other\ntypes, check the Route Matrix async API."
              }
            ]
          }
        },
        "traffic": {
          "type": "string",
          "description": "Specifies how traffic is considered for computing routes.\n\nDefault value: `historical`",
          "default": "historical",
          "enum": [
            "historical",
            "live"
          ],
          "x-ms-enum": {
            "name": "RouteMatrixTrafficEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "Historical",
                "value": "historical",
                "description": "Route calculation considers historical travel times and long term closures.\nTraffic jams and short-term closures during the travel time window do not\ninfluence routing or travel time."
              },
              {
                "name": "Live",
                "value": "live",
                "description": "In addition to historical travel times, route calculation considers traffic\njams and short- and long-term closures during the travel time window.\n\n`Note`: `traffic=live` may not be used in conjunction with `arriveAt=any` and\n`departAt=any`"
              }
            ]
          }
        },
        "avoid": {
          "type": "array",
          "description": "Specifies restrictions that the route calculation should honor when determining\nthe route. Avoid supports multiple values in a request and is only supported\nfor the driving and truck travelMode.",
          "items": {
            "$ref": "#/definitions/RouteMatrixAvoidEnum"
          }
        },
        "vehicleSpec": {
          "$ref": "#/definitions/RouteMatrixVehicleSpec",
          "description": "Specifies the vehicle attributes such as vehicle height, weight, max speed,\ntype of cargo, etc. to consider when calculating the route matrix. This helps\navoid low bridge clearances, road restrictions, difficult right turns to\nprovide the optimized route based on the vehicle specifications. Vehicle\nattributes are specified within the vehicleSpec property."
        }
      },
      "required": [
        "type",
        "features"
      ]
    },
    "RouteMatrixResponse": {
      "type": "object",
      "description": "This object is returned from a successful call.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "type": "object",
          "description": "The geometry object is null",
          "x-nullable": true,
          "additionalProperties": {}
        },
        "properties": {
          "$ref": "#/definitions/RouteMatrixFeatureProperties",
          "description": "Route Matrix properties."
        }
      },
      "required": [
        "type",
        "geometry",
        "properties"
      ]
    },
    "RouteMatrixSummary": {
      "type": "object",
      "description": "Summary for the route matrix request",
      "properties": {
        "successfulCount": {
          "type": "integer",
          "format": "int32",
          "description": "Number of successful routes within this matrix."
        },
        "totalCount": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of routes within this matrix."
        }
      }
    },
    "RouteMatrixTrafficEnum": {
      "type": "string",
      "description": "Specifies how traffic is considered for computing routes.\n\nDefault value: `historical`",
      "enum": [
        "historical",
        "live"
      ],
      "x-ms-enum": {
        "name": "RouteMatrixTrafficEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Historical",
            "value": "historical",
            "description": "Route calculation considers historical travel times and long term closures.\nTraffic jams and short-term closures during the travel time window do not\ninfluence routing or travel time."
          },
          {
            "name": "Live",
            "value": "live",
            "description": "In addition to historical travel times, route calculation considers traffic\njams and short- and long-term closures during the travel time window.\n\n`Note`: `traffic=live` may not be used in conjunction with `arriveAt=any` and\n`departAt=any`"
          }
        ]
      }
    },
    "RouteMatrixTravelModeEnum": {
      "type": "string",
      "description": "Specifies the travel profile to consider when calculating the matrix. If not\nspecified, the default value is \"driving\".\n\nExample: \"travelMode\":\"driving\"",
      "enum": [
        "driving",
        "truck",
        "walking"
      ],
      "x-ms-enum": {
        "name": "RouteMatrixTravelModeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "driving",
            "value": "driving",
            "description": "Routing profile suitable for cars are used for route matrix calculation."
          },
          {
            "name": "truck",
            "value": "truck",
            "description": "Routing profile suitable for commercial vehicles like trucks are used for route\nmatrix calculation."
          },
          {
            "name": "walking",
            "value": "walking",
            "description": "The returned routes are optimized for pedestrians, including the use of\nsidewalks."
          }
        ]
      }
    },
    "RouteMatrixTypeEnum": {
      "type": "string",
      "description": "Specifies the origin MultiPoint type and destination MultiPoint type for the\ninput matrix.",
      "enum": [
        "origins",
        "destinations"
      ],
      "x-ms-enum": {
        "name": "RouteMatrixTypeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "origins",
            "value": "origins",
            "description": "MultiPoint features that define the origin locations in the input matrix."
          },
          {
            "name": "destinations",
            "value": "destinations",
            "description": "MultiPoint features that define the destination locations in the input matrix."
          }
        ]
      }
    },
    "RouteMatrixVehicleSpec": {
      "type": "object",
      "description": "Specifies the vehicle attributes such as vehicle height, weight, max speed,\ntype of cargo, etc. to consider when calculating the route matrix. This helps\navoid low bridge clearances, road restrictions, difficult right turns to\nprovide the optimized route based on the vehicle specifications. Vehicle\nattributes are specified within the vehicleSpec property.",
      "allOf": [
        {
          "$ref": "#/definitions/VehicleSpec"
        }
      ]
    },
    "RouteOperation": {
      "type": "object",
      "description": "This object is returned from a successful Get Operation request.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the asynchronous operation."
        },
        "status": {
          "$ref": "#/definitions/StatusEnum",
          "description": "Current status of the async operation."
        },
        "kind": {
          "$ref": "#/definitions/RouteOperationKindEnum",
          "description": "Type of asynchronous operation"
        },
        "result": {
          "$ref": "#/definitions/RouteOperationResult",
          "description": "The result of async operation"
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the operation was created."
        },
        "lastActionAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the operation status was updated."
        },
        "error": {
          "$ref": "#/definitions/ErrorDetail",
          "description": "The error detail."
        }
      }
    },
    "RouteOperationKindEnum": {
      "type": "string",
      "description": "Type of asynchronous operation",
      "enum": [
        "RouteMatrix"
      ],
      "x-ms-enum": {
        "name": "RouteOperationKindEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "RouteMatrix",
            "value": "RouteMatrix",
            "description": "Route matrix asynchronous job."
          }
        ]
      }
    },
    "RouteOperationResponse": {
      "type": "object",
      "description": "This object represents the result of a successful route operation.",
      "properties": {
        "kind": {
          "$ref": "#/definitions/RouteOperationKindEnum",
          "description": "Type of asynchronous operation"
        }
      },
      "discriminator": "kind",
      "required": [
        "kind"
      ]
    },
    "RouteOperationResult": {
      "type": "object",
      "description": "The result of async operation",
      "properties": {
        "resultUrl": {
          "type": "string",
          "format": "uri",
          "description": "URL to the get the result of async operation"
        }
      }
    },
    "RouteOutputOptionEnum": {
      "type": "string",
      "description": "The desired route information from the response.",
      "enum": [
        "routeSummary",
        "routePath",
        "itinerary"
      ],
      "x-ms-enum": {
        "name": "RouteOutputOptionEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "routeSummary",
            "value": "routeSummary",
            "description": "Include only travel time and distance for the route, and do not provide other\ninformation."
          },
          {
            "name": "routePath",
            "value": "routePath",
            "description": "Include a GeoJSON MultiLineString [RFC 7946, section\n3.1.5](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.5) that describe the\nroute's path in the response."
          },
          {
            "name": "itinerary",
            "value": "itinerary",
            "description": "Include detailed directions in the response. Detailed directions are provided\nas \"ManeuverPoints\" and contain details such as turn-by-turn instructions."
          }
        ]
      }
    },
    "RoutePathPoint": {
      "type": "object",
      "description": "Refers to the index of a point within a specific Leg of a route.",
      "properties": {
        "legIndex": {
          "type": "integer",
          "format": "int64",
          "description": "The route Leg index is a sequential number assigned to each Leg of the route to\nhelp identify and distinguish between different segments of the route."
        },
        "pointIndex": {
          "type": "integer",
          "format": "int64",
          "description": "Index of a point within a specific Leg."
        }
      }
    },
    "RoutePathProperties": {
      "type": "object",
      "description": "Specifies the properties that describe the route's path in the response.",
      "properties": {
        "distanceInMeters": {
          "type": "number",
          "format": "float",
          "description": "The physical distance in meters covered by the entire route."
        },
        "durationInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "Estimated travel time in seconds that does not include delays on the route due\nto traffic conditions."
        },
        "durationTrafficInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "The time that it takes, in seconds, to travel a corresponding `TravelDistance`\nwith current traffic conditions. This value is provided if `optimizeRoute`\nincludes traffic considerations."
        },
        "departureAt": {
          "type": "string",
          "format": "date-time",
          "description": "The estimated departure time for the leg, which takes into account the traffic\nconditions, is formatted as a `dateTime` value defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). It will reference the\ntimezone offset by either `departAt` or `arrivalAt`. If not, then the UTC time\nwill be used."
        },
        "arrivalAt": {
          "type": "string",
          "format": "date-time",
          "description": "The estimated arrival time for the leg, which takes into account the traffic\nconditions, is formatted as a `dateTime` value defined by [RFC 3339, section\n5.6](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). It will reference the\ntimezone offset by either `departAt` or `arrivalAt`. If not, then the UTC time\nwill be used."
        },
        "trafficCongestion": {
          "$ref": "#/definitions/TrafficCongestionEnum",
          "description": "The level of traffic congestion along the route. `Note`: Only supported for\ndriving travelMode"
        },
        "legs": {
          "type": "array",
          "description": "An array of route Legs. Check route Leg object description for more information.",
          "items": {
            "$ref": "#/definitions/RouteLeg"
          }
        },
        "optimizedWaypoints": {
          "type": "array",
          "description": "Optimized sequence of waypoints. It shows the index from the user provided\nwaypoint sequence for the original and optimized lists.",
          "items": {
            "$ref": "#/definitions/OptimizedWaypoint"
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/FeatureProperties"
        }
      ],
      "x-ms-discriminator-value": "RoutePath"
    },
    "RoutePathRange": {
      "type": "object",
      "description": "Refers to the range covered by a specific Leg of a route or path.",
      "properties": {
        "range": {
          "type": "array",
          "description": "Refers to the range covered by a specific Leg of a route or path.",
          "items": {
            "type": "integer",
            "format": "int64"
          }
        },
        "legIndex": {
          "type": "integer",
          "format": "int64",
          "description": "The route Leg index is a sequential number assigned to each Leg of the route to\nhelp identify and distinguish between different segments of the route."
        }
      }
    },
    "RoutePathTravelModeEnum": {
      "type": "string",
      "description": "The mode of travel for the route path in the response.",
      "enum": [
        "driving",
        "truck",
        "walking",
        "other"
      ],
      "x-ms-enum": {
        "name": "RoutePathTravelModeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "driving",
            "value": "driving",
            "description": "Routes optimized for cars."
          },
          {
            "name": "truck",
            "value": "truck",
            "description": "Routes optimized for large size trucks based on the vehicle specification."
          },
          {
            "name": "walking",
            "value": "walking",
            "description": "Routes optimized for pedestrians."
          },
          {
            "name": "other",
            "value": "other",
            "description": "RouteTravelMode is returned as \"other\" for the truck travelMode when the truck\nroute is not available for a particular section of a route."
          }
        ]
      }
    },
    "RouteRangeAvoidEnum": {
      "type": "string",
      "description": "Specifies restrictions that the route calculation should honor when determining the\nreachable locations. Avoid supports multiple values in a request.\n\\n\\nExample: \\\"avoid\\\": [\\\"limitedAccessHighways\\\", \\\"tollRoads\\\"]",
      "enum": [
        "limitedAccessHighways",
        "tollRoads",
        "ferries",
        "tunnels",
        "borderCrossings",
        "lowEmissionZones",
        "unpavedRoads",
        "carpools",
        "carTrains"
      ],
      "x-ms-enum": {
        "name": "RouteRangeAvoidEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "limitedAccessHighways",
            "value": "limitedAccessHighways",
            "description": "Avoids the use of limited access highways in the route."
          },
          {
            "name": "tollRoads",
            "value": "tollRoads",
            "description": "Avoids the use of toll roads in the route."
          },
          {
            "name": "ferries",
            "value": "ferries",
            "description": "Avoids the use of ferries in the route."
          },
          {
            "name": "tunnels",
            "value": "tunnels",
            "description": "Avoids the use of tunnels in the route."
          },
          {
            "name": "borderCrossings",
            "value": "borderCrossings",
            "description": "Avoids crossing country borders in the route."
          },
          {
            "name": "lowEmissionZones",
            "value": "lowEmissionZones",
            "description": "Avoids low-emission zones in the route."
          },
          {
            "name": "unpavedRoads",
            "value": "unpavedRoads",
            "description": "Avoids unpaved roads in the route."
          },
          {
            "name": "carpools",
            "value": "carpools",
            "description": "Avoids routes that require use of carpool."
          },
          {
            "name": "carTrains",
            "value": "carTrains",
            "description": "Avoids car trains."
          }
        ]
      }
    },
    "RouteRangeBatchRequestBody": {
      "type": "object",
      "description": "The list of route range queries/requests to process. The list can contain a max\nof 100 queries and must contain at least 1 query.",
      "properties": {
        "batchItems": {
          "type": "array",
          "description": "The list of queries to process.",
          "items": {
            "$ref": "#/definitions/RouteRangeBatchRequestItem"
          }
        }
      }
    },
    "RouteRangeBatchRequestItem": {
      "type": "object",
      "description": "Batch Query object",
      "properties": {
        "optionalId": {
          "type": "string",
          "description": "Id of the request which would show in corresponding batchItem."
        },
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/RouteRangePointGeometry",
          "description": "Specifies the `GeoJSON` Point Geometry object. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details."
        },
        "properties": {
          "$ref": "#/definitions/InputRouteRangeProperties",
          "description": "Specifies the parameters to use for the calculation of isochrone polygon."
        }
      },
      "required": [
        "type",
        "geometry",
        "properties"
      ]
    },
    "RouteRangeBatchResponse": {
      "type": "object",
      "description": "This object is returned from a successful Route Range Batch service call.",
      "properties": {
        "summary": {
          "$ref": "#/definitions/RouteRangeBatchResponseSummary",
          "description": "Summary for the batch request"
        },
        "batchItems": {
          "type": "array",
          "description": "Array containing the batch results.",
          "items": {
            "$ref": "#/definitions/RouteRangeBatchResponseItem"
          }
        }
      }
    },
    "RouteRangeBatchResponseItem": {
      "type": "object",
      "description": "error details",
      "properties": {
        "optionalId": {
          "type": "string",
          "description": "Id of the request which would show in corresponding batchItem."
        },
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "`GeoJSON` feature object that contains Geometry object and additional\nproperties. Refer to [RFC 7946, Section\n3.2](https://www.rfc-editor.org/rfc/rfc7946#section-3.2) for details.",
          "items": {
            "$ref": "#/definitions/RouteRangeFeaturesItem"
          }
        },
        "error": {
          "$ref": "#/definitions/ErrorDetail",
          "description": "The error detail."
        }
      }
    },
    "RouteRangeBatchResponseSummary": {
      "type": "object",
      "description": "Summary for the batch request",
      "properties": {
        "successfulRequests": {
          "type": "integer",
          "format": "int32",
          "description": "Number of successful requests in the batch"
        },
        "totalRequests": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of requests in the batch"
        }
      }
    },
    "RouteRangeFeatureProperties": {
      "type": "object",
      "description": "Route Ranges properties.",
      "properties": {
        "type": {
          "$ref": "#/definitions/RouteRangeTypeEnum",
          "description": "The feature types for the feature objects returned in the response."
        }
      }
    },
    "RouteRangeFeaturesItem": {
      "type": "object",
      "description": "GeoJSON feature object that contains Geometry object and additional properties\nof the route.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/RouteRangeGeometry",
          "description": "A valid `GeoJSON` Geometry object. Please refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details."
        },
        "bbox": {
          "type": "array",
          "description": "A rectangular area on the earth defined as a bounding box object. The sides of\nthe rectangles are defined by latitude and longitude values. For more\ninformation, see [RFC 7946, Section\n5](https://www.rfc-editor.org/rfc/rfc7946#section-5).\n\nExample: \"bbox\": [-10.0, -10.0, 10.0, 10.0]",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "properties": {
          "$ref": "#/definitions/RouteRangeFeatureProperties",
          "description": "Route Ranges properties."
        }
      }
    },
    "RouteRangeGeometry": {
      "type": "object",
      "description": "A valid `GeoJSON` Geometry object. Please refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/GeoJsonObjectType",
          "description": "Specifies the geometry type for the `GeoJSON` Geometry object. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details."
        }
      },
      "discriminator": "type",
      "required": [
        "type"
      ]
    },
    "RouteRangeOptimizeRouteEnum": {
      "type": "string",
      "description": "Specifies the parameter to use to optimize the route. If not defined, the\ndefault is \"fastestWithoutTraffic\" which returns the route to minimize the\ntravel time without using current traffic information.\n\nExample: \"optimizeRoute\":\"shortest\"",
      "enum": [
        "shortest",
        "fastestWithoutTraffic",
        "fastestWithTraffic"
      ],
      "x-ms-enum": {
        "name": "RouteRangeOptimizeRouteEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Shortest",
            "value": "shortest",
            "description": "The route is calculated to minimize the distance. Traffic information is not\nused."
          },
          {
            "name": "FastestWithoutTraffic",
            "value": "fastestWithoutTraffic",
            "description": "Finds the fastest route, without factoring in traffic information."
          },
          {
            "name": "FastestWithTraffic",
            "value": "fastestWithTraffic",
            "description": "The route is calculated to minimize the time using current traffic information.\n`Note`: Only supported for driving and truck travelMode."
          }
        ]
      }
    },
    "RouteRangePointGeometry": {
      "type": "object",
      "description": "Specifies the `GeoJSON` Point Geometry object. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "A `Position` is an array of numbers with two or more elements. The first two\nelements are _longitude_ and _latitude_, precisely in that order.\n_Altitude/Elevation_ is an optional third element. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.1) for details.",
          "items": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/RouteRangeGeometry"
        }
      ],
      "x-ms-discriminator-value": "Point"
    },
    "RouteRangePolygonGeometry": {
      "type": "object",
      "description": "Specifies the `GeoJSON` Polygon Geometry object. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "coordinates": {
          "type": "array",
          "description": "Coordinates for the `GeoJson Polygon` geometry type.",
          "items": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          }
        }
      },
      "required": [
        "coordinates"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/RouteRangeGeometry"
        }
      ],
      "x-ms-discriminator-value": "Polygon"
    },
    "RouteRangeRequest": {
      "type": "object",
      "description": "Specifies the starting point for range calculation. `GeoJSON` feature object\nand additional properties. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/RouteRangePointGeometry",
          "description": "Specifies the `GeoJSON` Point Geometry object. Refer to [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946) for details."
        },
        "properties": {
          "$ref": "#/definitions/InputRouteRangeProperties",
          "description": "Specifies the parameters to use for the calculation of isochrone polygon."
        }
      },
      "required": [
        "type",
        "geometry",
        "properties"
      ]
    },
    "RouteRangeResponse": {
      "type": "object",
      "description": "This object is returned from a successful call.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "`GeoJSON` feature object that contains Geometry object and additional\nproperties. Refer to [RFC 7946, Section\n3.2](https://www.rfc-editor.org/rfc/rfc7946#section-3.2) for details.",
          "items": {
            "$ref": "#/definitions/RouteRangeFeaturesItem"
          }
        }
      }
    },
    "RouteRangeTravelModeEnum": {
      "type": "string",
      "description": "Specifies the travel profile to consider when calculating the range polygon. If\nnot specified, the default value is \"driving\".\n\nExample: \"travelMode\":\"driving\"",
      "enum": [
        "driving",
        "truck"
      ],
      "x-ms-enum": {
        "name": "RouteRangeTravelModeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "driving",
            "value": "driving",
            "description": "Routing profile suitable for cars are used for range polygon calculation."
          },
          {
            "name": "truck",
            "value": "truck",
            "description": "Routing profile suitable for commercial vehicles like trucks are used for range\npolygon calculation."
          }
        ]
      }
    },
    "RouteRangeTypeEnum": {
      "type": "string",
      "description": "The feature types for the feature objects returned in the response.",
      "enum": [
        "center",
        "boundary"
      ],
      "x-ms-enum": {
        "name": "RouteRangeTypeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "center",
            "value": "center",
            "description": "The center point feature type represents the point used for the range polygon\ncalculation."
          },
          {
            "name": "boundary",
            "value": "boundary",
            "description": "The boundary feature type represents the range polygon."
          }
        ]
      }
    },
    "RouteRangeVehicleSpec": {
      "type": "object",
      "description": "Specifies the vehicle attributes such as vehicle height, weight, max speed,\ntype of cargo, etc. to consider when calculating the reachable locations. This\nhelps avoid low bridge clearances, road restrictions, difficult right turns to\nprovide the optimized truck route based on the vehicle specifications. Vehicle\nattributes are specified within the vehicleSpec property.",
      "properties": {
        "isVehicleCommercial": {
          "type": "boolean",
          "description": "Whether the vehicle is used for commercial purposes. Commercial vehicles may\nnot be allowed to drive on some roads.",
          "default": false
        },
        "length": {
          "type": "number",
          "format": "double",
          "description": "Length of the vehicle in meters. A value of 0 means that length restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "width": {
          "type": "number",
          "format": "double",
          "description": "Width of the vehicle in meters. A value of 0 means that width restrictions are\nnot considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "height": {
          "type": "number",
          "format": "double",
          "description": "Height of the vehicle in meters. A value of 0 means that height restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "weight": {
          "type": "integer",
          "format": "int64",
          "description": "Weight of the vehicle in kilograms. A value of 0 means that weight restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "maxSpeed": {
          "type": "integer",
          "format": "int64",
          "description": "Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile\nis used to check whether a vehicle is allowed on motorways.\n\nA value of 0 means that an appropriate value for the vehicle will be determined\nand applied during route planning.\n\nA non-zero value may be overridden during route planning. For example, the\ncurrent traffic flow is 60 km/hour. If the vehicle maximum speed is set to 50\nkm/hour, the routing engine will consider 60 km/hour as this is the current\nsituation. If the maximum speed of the vehicle is provided as 80 km/hour but\nthe current traffic flow is 60 km/hour, then routing engine will again use 60\nkm/hour.",
          "default": 0,
          "minimum": 0,
          "maximum": 250
        },
        "axleWeight": {
          "type": "integer",
          "format": "int64",
          "description": "Weight per axle of the vehicle in kg. A value of 0 means that weight\nrestrictions per axle are not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "loadType": {
          "type": "array",
          "description": "Types of cargo that may be classified as hazardous materials and restricted\nfrom some roads. Available vehicleLoadType values are US Hazmat classes 1\nthrough 9, plus generic classifications for use in other countries. Values\nbeginning with USHazmat are for US routing while otherHazmat should be used for\nall other countries. vehicleLoadType supports multiple values in a request.",
          "items": {
            "$ref": "#/definitions/VehicleLoadTypeEnum"
          }
        },
        "adrTunnelRestrictionCode": {
          "$ref": "#/definitions/AdrTunnelRestrictionCodeEnum",
          "description": "The ADR tunnel restriction code. ADR is a European agreement concerning the\ninternational carriage of dangerous goods by road. The ADR tunnel restriction\ncode is used to determine whether a vehicle is allowed to pass through a tunnel\nwith restrictions on the carriage of dangerous goods."
        },
        "axleCount": {
          "type": "integer",
          "format": "int64",
          "description": "The number of axles on the vehicle."
        }
      }
    },
    "RouteStep": {
      "type": "object",
      "description": "A route Leg contain turn-by-turn instructions. A step refers to a range of a\nroute between two consecutive maneuverPoint.",
      "properties": {
        "maneuverType": {
          "$ref": "#/definitions/ManeuverTypeEnum",
          "description": "The type of maneuver described in this detailed collection. The ManeuverType\nprovides information for a portion of the maneuver specified by the\ncorresponding instruction. For example, the maneuverType of an instruction may\nspecify TurnLeftThenTurnRight, while the associated detail items may provide\nspecifics about the TurnLeft and TurnRight maneuvers"
        },
        "names": {
          "type": "array",
          "description": "A street, highway or intersection where the maneuver occurs. If the maneuver is\ncomplex, there may be more than one name field in the details collection. The\nname field may also have no value. This can occur if the name is not known or\nif a street, highway or intersection does not have a name.",
          "items": {
            "type": "string"
          }
        },
        "routePathRange": {
          "$ref": "#/definitions/RoutePathRange",
          "description": "Refers to the range covered by a specific Leg of a route or path."
        }
      }
    },
    "SideOfStreetEnum": {
      "type": "string",
      "description": "The side of the street where the destination is found based on the arrival\ndirection. This field applies to the last maneuverPoint only.",
      "enum": [
        "Left",
        "Right",
        "Unknown"
      ],
      "x-ms-enum": {
        "name": "SideOfStreetEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Left",
            "value": "Left",
            "description": "Left."
          },
          {
            "name": "Right",
            "value": "Right",
            "description": "Right."
          },
          {
            "name": "Unknown",
            "value": "Unknown",
            "description": "Unknown."
          }
        ]
      }
    },
    "SnapToRoadFeaturesItem": {
      "type": "object",
      "description": "GeoJSON feature object that contains Geometry object and additional properties\nof the route.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeaturesItemTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is Feature. For\nmore information, see [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "geometry": {
          "$ref": "#/definitions/GeoJsonPoint",
          "description": "A valid `GeoJSON Point` geometry type. Please refer to [RFC\n7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details."
        },
        "bbox": {
          "type": "array",
          "description": "A rectangular area on the earth defined as a bounding box object. The sides of\nthe rectangles are defined by latitude and longitude values. For more\ninformation, see [RFC 7946, Section\n5](https://www.rfc-editor.org/rfc/rfc7946#section-5).\n\nExample: \"bbox\": [-10.0, -10.0, 10.0, 10.0]",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "properties": {
          "$ref": "#/definitions/SnapToRoadsFeatureProperties",
          "description": "Snap to Roads properties."
        }
      }
    },
    "SnapToRoadsBatchRequestBody": {
      "type": "object",
      "description": "The list of snap to roads queries/requests to process. The list can contain a\nmax of 100 queries and must contain at least 1 query.",
      "properties": {
        "batchItems": {
          "type": "array",
          "description": "The list of queries to process.",
          "items": {
            "$ref": "#/definitions/SnapToRoadsBatchRequestItem"
          }
        }
      }
    },
    "SnapToRoadsBatchRequestItem": {
      "type": "object",
      "description": "Batch Query object",
      "properties": {
        "optionalId": {
          "type": "string",
          "description": "Id of the request which would show in corresponding batchItem."
        },
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "A set of points to snap to road network. You can have a minimum of 2 points and\nmaximum of 5000 points and the two consecutive points must be within 6\nkilometer of each other and a total road distance of up to 100 kilometers.\nRefer to [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946) for details on the\nGeoJSON format.\n\n`Note`: The API will not return a point object in the response for the GPS\npoint that cannot be snapped to a road network.",
          "minItems": 2,
          "maxItems": 100,
          "items": {
            "$ref": "#/definitions/InputSnapToRoadsFeaturesItem"
          }
        },
        "interpolate": {
          "type": "boolean",
          "description": "Specifies whether to return additional points between the snapped points to\ncomplete the full route path that smoothly follows the road geometry.\n\nThe interpolated points will have `isInterpolate:true` in the response which\ncan be used to identify the snapped points from interpolated points.",
          "default": false
        },
        "includeSpeedLimit": {
          "type": "boolean",
          "description": "Specifies whether to include speed limit information for the snapped points in\nthe response. The unit is in kilometers per hour.",
          "default": false
        },
        "travelMode": {
          "type": "string",
          "description": "Specifies the routing profile for snapping the points. If unspecified, the\ndefault mode is \"driving\", which optimizes the snapped points for driving\nroutes.",
          "default": "driving",
          "enum": [
            "driving",
            "truck"
          ],
          "x-ms-enum": {
            "name": "SnapToRoadsTravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "The points are snapped to the road suitable for cars."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "The points are snapped to the road suitable for truck."
              }
            ]
          }
        }
      },
      "required": [
        "type",
        "features"
      ]
    },
    "SnapToRoadsBatchResponse": {
      "type": "object",
      "description": "This object is returned from a successful Snap To Roads Batch service call.",
      "properties": {
        "summary": {
          "$ref": "#/definitions/SnapToRoadsBatchResponseSummary",
          "description": "Summary for the batch request"
        },
        "batchItems": {
          "type": "array",
          "description": "Array containing the batch results.",
          "items": {
            "$ref": "#/definitions/SnapToRoadsBatchResponseItem"
          }
        }
      }
    },
    "SnapToRoadsBatchResponseItem": {
      "type": "object",
      "description": "error details",
      "properties": {
        "optionalId": {
          "type": "string",
          "description": "Id of the request which would show in corresponding batchItem."
        },
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "`GeoJSON` feature object that contains Geometry object and additional\nproperties. Refer to [RFC 7946, Section\n3.2](https://www.rfc-editor.org/rfc/rfc7946#section-3.2) for details.",
          "items": {
            "$ref": "#/definitions/SnapToRoadFeaturesItem"
          }
        },
        "error": {
          "$ref": "#/definitions/ErrorDetail",
          "description": "The error detail."
        }
      }
    },
    "SnapToRoadsBatchResponseSummary": {
      "type": "object",
      "description": "Summary for the batch request",
      "properties": {
        "successfulRequests": {
          "type": "integer",
          "format": "int32",
          "description": "Number of successful requests in the batch"
        },
        "totalRequests": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of requests in the batch"
        }
      }
    },
    "SnapToRoadsFeatureProperties": {
      "type": "object",
      "description": "Snap to Roads properties.",
      "properties": {
        "inputIndex": {
          "type": "integer",
          "format": "int64",
          "description": "Identify the corresponding index in the original list of points for each\nsnapped point. Only the snapped points will return indices and can be used to\ndistinguish them from the interpolated points."
        },
        "isInterpolated": {
          "type": "boolean",
          "description": "Identify whether this is the interpolated point."
        },
        "name": {
          "type": "string",
          "description": "Name of the road the point is snapped to."
        },
        "speedLimitInKilometersPerHour": {
          "type": "number",
          "format": "double",
          "description": "Speed limit in kilometers per hour."
        }
      }
    },
    "SnapToRoadsRequest": {
      "type": "object",
      "description": "This object is the request body.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "A set of points to snap to road network. You can have a minimum of 2 points and\nmaximum of 5000 points and the two consecutive points must be within 6\nkilometer of each other and a total road distance of up to 100 kilometers.\nRefer to [RFC 7946](https://www.rfc-editor.org/rfc/rfc7946) for details on the\nGeoJSON format.\n\n`Note`: The API will not return a point object in the response for the GPS\npoint that cannot be snapped to a road network.",
          "minItems": 2,
          "maxItems": 100,
          "items": {
            "$ref": "#/definitions/InputSnapToRoadsFeaturesItem"
          }
        },
        "interpolate": {
          "type": "boolean",
          "description": "Specifies whether to return additional points between the snapped points to\ncomplete the full route path that smoothly follows the road geometry.\n\nThe interpolated points will have `isInterpolate:true` in the response which\ncan be used to identify the snapped points from interpolated points.",
          "default": false
        },
        "includeSpeedLimit": {
          "type": "boolean",
          "description": "Specifies whether to include speed limit information for the snapped points in\nthe response. The unit is in kilometers per hour.",
          "default": false
        },
        "travelMode": {
          "type": "string",
          "description": "Specifies the routing profile for snapping the points. If unspecified, the\ndefault mode is \"driving\", which optimizes the snapped points for driving\nroutes.",
          "default": "driving",
          "enum": [
            "driving",
            "truck"
          ],
          "x-ms-enum": {
            "name": "SnapToRoadsTravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "The points are snapped to the road suitable for cars."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "The points are snapped to the road suitable for truck."
              }
            ]
          }
        }
      },
      "required": [
        "type",
        "features"
      ]
    },
    "SnapToRoadsResponse": {
      "type": "object",
      "description": "This object is returned from a successful call.",
      "properties": {
        "type": {
          "$ref": "#/definitions/FeatureTypeEnum",
          "description": "Specifies the `GeoJSON` type. The only supported object type is\n`FeatureCollection`. For more information, see [RFC\n7946](https://www.rfc-editor.org/rfc/rfc7946)."
        },
        "features": {
          "type": "array",
          "description": "`GeoJSON` feature object that contains Geometry object and additional\nproperties. Refer to [RFC 7946, Section\n3.2](https://www.rfc-editor.org/rfc/rfc7946#section-3.2) for details.",
          "items": {
            "$ref": "#/definitions/SnapToRoadFeaturesItem"
          }
        }
      }
    },
    "SnapToRoadsTravelModeEnum": {
      "type": "string",
      "description": "Specifies the routing profile for snapping the points. If unspecified, the\ndefault mode is \"driving\", which optimizes the snapped points for driving\nroutes.",
      "enum": [
        "driving",
        "truck"
      ],
      "x-ms-enum": {
        "name": "SnapToRoadsTravelModeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "driving",
            "value": "driving",
            "description": "The points are snapped to the road suitable for cars."
          },
          {
            "name": "truck",
            "value": "truck",
            "description": "The points are snapped to the road suitable for truck."
          }
        ]
      }
    },
    "StatusEnum": {
      "type": "string",
      "description": "Current status of the async operation.",
      "enum": [
        "NotStarted",
        "Running",
        "Completed",
        "Failed"
      ],
      "x-ms-enum": {
        "name": "StatusEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "NotStarted",
            "value": "NotStarted",
            "description": "The operation has not started yet."
          },
          {
            "name": "Running",
            "value": "Running",
            "description": "The operation is running."
          },
          {
            "name": "Completed",
            "value": "Completed",
            "description": "The operation has completed successfully."
          },
          {
            "name": "Failed",
            "value": "Failed",
            "description": "The operation has failed."
          }
        ]
      }
    },
    "TrafficCongestionEnum": {
      "type": "string",
      "description": "The level of traffic congestion along the route. `Note`: Only supported for\ndriving travelMode",
      "enum": [
        "Unknown",
        "None",
        "Mild",
        "Medium",
        "Heavy"
      ],
      "x-ms-enum": {
        "name": "TrafficCongestionEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "Unknown",
            "value": "Unknown",
            "description": "Unknown."
          },
          {
            "name": "None",
            "value": "None",
            "description": "None."
          },
          {
            "name": "Mild",
            "value": "Mild",
            "description": "Mild."
          },
          {
            "name": "Medium",
            "value": "Medium",
            "description": "Medium."
          },
          {
            "name": "Heavy",
            "value": "Heavy",
            "description": "Heavy."
          }
        ]
      }
    },
    "TravelModeEnum": {
      "type": "string",
      "description": "The mode of travel for the requested route. If not defined, the default value\nis \"driving\" that returns the route optimized for cars.\n\n`Note`: For truck travelMode, the requested truck route may not be available\nfor the entire route. Where the truck route is not available for a particular\nsection, the travelMode element of the response for that section will be\n\"other\".\n\nExample: \"travelMode\":\"driving\"",
      "enum": [
        "driving",
        "truck",
        "walking"
      ],
      "x-ms-enum": {
        "name": "TravelModeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "driving",
            "value": "driving",
            "description": "The returned routes are optimized for cars."
          },
          {
            "name": "truck",
            "value": "truck",
            "description": "The returned routes are optimized for large size trucks based on the vehicle\nspecification."
          },
          {
            "name": "walking",
            "value": "walking",
            "description": "The returned routes are optimized for pedestrians, including the use of\nsidewalks."
          }
        ]
      }
    },
    "VehicleLoadTypeEnum": {
      "type": "string",
      "description": "Types of cargo that may be classified as hazardous materials and restricted from some roads.",
      "enum": [
        "USHazmatClass1",
        "USHazmatClass2",
        "USHazmatClass3",
        "USHazmatClass4",
        "USHazmatClass5",
        "USHazmatClass6",
        "USHazmatClass7",
        "USHazmatClass8",
        "USHazmatClass9",
        "otherHazmatExplosive",
        "otherHazmatGeneral",
        "otherHazmatHarmfulToWater"
      ],
      "x-ms-enum": {
        "name": "VehicleLoadTypeEnum",
        "modelAsString": true,
        "values": [
          {
            "name": "USHazmatClass1",
            "value": "USHazmatClass1",
            "description": "Explosives"
          },
          {
            "name": "USHazmatClass2",
            "value": "USHazmatClass2",
            "description": "Compressed gas"
          },
          {
            "name": "USHazmatClass3",
            "value": "USHazmatClass3",
            "description": "Flammable liquids"
          },
          {
            "name": "USHazmatClass4",
            "value": "USHazmatClass4",
            "description": "Flammable solids"
          },
          {
            "name": "USHazmatClass5",
            "value": "USHazmatClass5",
            "description": "Oxidizers"
          },
          {
            "name": "USHazmatClass6",
            "value": "USHazmatClass6",
            "description": "Poisons"
          },
          {
            "name": "USHazmatClass7",
            "value": "USHazmatClass7",
            "description": "Radioactive"
          },
          {
            "name": "USHazmatClass8",
            "value": "USHazmatClass8",
            "description": "Corrosives"
          },
          {
            "name": "USHazmatClass9",
            "value": "USHazmatClass9",
            "description": "Miscellaneous"
          },
          {
            "name": "otherHazmatExplosive",
            "value": "otherHazmatExplosive",
            "description": "Explosives"
          },
          {
            "name": "otherHazmatGeneral",
            "value": "otherHazmatGeneral",
            "description": "Miscellaneous"
          },
          {
            "name": "otherHazmatHarmfulToWater",
            "value": "otherHazmatHarmfulToWater",
            "description": "Harmful to water"
          }
        ]
      }
    },
    "VehicleSpec": {
      "type": "object",
      "description": "Specifies the vehicle attributes such as size, weight, max speed, type of\ncargo, etc. for truck routing only. This helps avoid low bridge clearances,\nroad restrictions, difficult right turns to provide the optimized truck route\nbased on the vehicle specifications.\n\n`Note`: Only supported for truck travelMode.",
      "properties": {
        "isVehicleCommercial": {
          "type": "boolean",
          "description": "Whether the vehicle is used for commercial purposes. Commercial vehicles may\nnot be allowed to drive on some roads.",
          "default": false
        },
        "length": {
          "type": "number",
          "format": "double",
          "description": "Length of the vehicle in meters. A value of 0 means that length restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "width": {
          "type": "number",
          "format": "double",
          "description": "Width of the vehicle in meters. A value of 0 means that width restrictions are\nnot considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "height": {
          "type": "number",
          "format": "double",
          "description": "Height of the vehicle in meters. A value of 0 means that height restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "weight": {
          "type": "integer",
          "format": "int64",
          "description": "Weight of the vehicle in kilograms. A value of 0 means that weight restrictions\nare not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "maxSpeed": {
          "type": "integer",
          "format": "int64",
          "description": "Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile\nis used to check whether a vehicle is allowed on motorways.\n\nA value of 0 means that an appropriate value for the vehicle will be determined\nand applied during route planning.\n\nA non-zero value may be overridden during route planning. For example, the\ncurrent traffic flow is 60 km/hour. If the vehicle maximum speed is set to 50\nkm/hour, the routing engine will consider 60 km/hour as this is the current\nsituation. If the maximum speed of the vehicle is provided as 80 km/hour but\nthe current traffic flow is 60 km/hour, then routing engine will again use 60\nkm/hour.",
          "default": 0,
          "minimum": 0,
          "maximum": 250
        },
        "axleWeight": {
          "type": "integer",
          "format": "int64",
          "description": "Weight per axle of the vehicle in kg. A value of 0 means that weight\nrestrictions per axle are not considered.",
          "default": 0,
          "minimum": 0,
          "maximum": 1000000
        },
        "loadType": {
          "type": "array",
          "description": "Types of cargo that may be classified as hazardous materials and restricted\nfrom some roads. Available vehicleLoadType values are US Hazmat classes 1\nthrough 9, plus generic classifications for use in other countries. Values\nbeginning with USHazmat are for US routing while otherHazmat should be used for\nall other countries. vehicleLoadType supports multiple values in a request.",
          "items": {
            "$ref": "#/definitions/VehicleLoadTypeEnum"
          }
        },
        "adrTunnelRestrictionCode": {
          "$ref": "#/definitions/AdrTunnelRestrictionCodeEnum",
          "description": "The ADR tunnel restriction code. ADR is a European agreement concerning the\ninternational carriage of dangerous goods by road. The ADR tunnel restriction\ncode is used to determine whether a vehicle is allowed to pass through a tunnel\nwith restrictions on the carriage of dangerous goods."
        }
      }
    },
    "WaypointProperties": {
      "type": "object",
      "description": "Specifies the properties of a waypoint which is a specific location or point\nalong a route or trip that serves as a reference or stopping point.",
      "properties": {
        "routePathPoint": {
          "$ref": "#/definitions/RoutePathPoint",
          "description": "Refers to the index of a point within a specific Leg of a route."
        },
        "order": {
          "$ref": "#/definitions/Order",
          "description": "Sequence for visiting waypoints."
        },
        "steps": {
          "type": "array",
          "description": "Steps between two consecutive maneuver points.",
          "items": {
            "$ref": "#/definitions/RouteStep"
          }
        },
        "instruction": {
          "$ref": "#/definitions/Instruction",
          "description": "A description of a maneuver in a set of directions."
        },
        "address": {
          "$ref": "#/definitions/NavigationPointPropertiesAddress",
          "description": "The administrative district and country region for the waypoints and maneuver\npoints on the route."
        },
        "sideOfStreet": {
          "$ref": "#/definitions/SideOfStreetEnum",
          "description": "The side of the street where the destination is found based on the arrival\ndirection. This field applies to the last maneuverPoint only."
        },
        "signs": {
          "type": "array",
          "description": "Signage text for the route. There may be more than one sign value.",
          "items": {
            "type": "string"
          }
        },
        "towardsRoadName": {
          "type": "string",
          "description": "The name of the street that the route goes towards in the first `ManeuverPoint`."
        },
        "exitIdentifier": {
          "type": "string",
          "description": "The name or number of the exit associated with this route step."
        },
        "distanceInMeters": {
          "type": "number",
          "format": "float",
          "description": "The physical distance in meters covered by this route step."
        },
        "durationInSeconds": {
          "type": "integer",
          "format": "int64",
          "description": "The time that it takes, in seconds, to travel a corresponding `TravelDistance`."
        },
        "travelMode": {
          "type": "string",
          "description": "The mode of travel for the route path in the response.",
          "default": "driving",
          "enum": [
            "driving",
            "truck",
            "walking",
            "other"
          ],
          "x-ms-enum": {
            "name": "RoutePathTravelModeEnum",
            "modelAsString": true,
            "values": [
              {
                "name": "driving",
                "value": "driving",
                "description": "Routes optimized for cars."
              },
              {
                "name": "truck",
                "value": "truck",
                "description": "Routes optimized for large size trucks based on the vehicle specification."
              },
              {
                "name": "walking",
                "value": "walking",
                "description": "Routes optimized for pedestrians."
              },
              {
                "name": "other",
                "value": "other",
                "description": "RouteTravelMode is returned as \"other\" for the truck travelMode when the truck\nroute is not available for a particular section of a route."
              }
            ]
          }
        }
      },
      "allOf": [
        {
          "$ref": "#/definitions/FeatureProperties"
        }
      ],
      "x-ms-discriminator-value": "Waypoint"
    }
  },
  "parameters": {
    "Azure.Core.Foundations.ApiVersionParameter": {
      "name": "api-version",
      "in": "query",
      "description": "The API version to use for this operation.",
      "required": true,
      "type": "string",
      "minLength": 1,
      "x-ms-parameter-location": "method",
      "x-ms-client-name": "apiVersion"
    }
  }
}
