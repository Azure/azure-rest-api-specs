import "@typespec/rest";
import "@typespec/http";
import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-azure-resource-manager";

using TypeSpec.Rest;
using TypeSpec.Http;
using Azure.ResourceManager;

namespace Microsoft.Relay;

interface Operations extends Azure.ResourceManager.Operations {}

enum AccessRights {
  Manage,
  Send,
  Listen,
}

enum CreatedByType {
  User,
  Application,
  ManagedIdentity,
  Key,
}

enum KeyType {
  PrimaryKey,
  SecondaryKey,
}

enum UnavailableReason {
  None,
  InvalidName,
  SubscriptionIsDisabled,
  NameInUse,
  NameInLockdown,
  TooManyNamespaceInCurrentSubscription,
}

enum SkuName {
  Standard,
}

enum SkuTier {
  Standard,
}

enum PrivateLinkConnectionStatus {
  Pending,
  Approved,
  Rejected,
  Disconnected,
}

enum EndPointProvisioningState {
  Creating,
  Updating,
  Deleting,
  Succeeded,
  Canceled,
  Failed,
}

enum PublicNetworkAccess {
  Enabled,
  Disabled,
  SecuredByPerimeter,
}

enum DefaultAction {
  Allow,
  Deny,
}

enum NetworkRuleIPAction {
  Allow,
}
@Azure.Core.fixed
enum Relaytype {
  NetTcp,
  Http,
}

@doc("Properties supplied to create or update AuthorizationRule")
model AuthorizationRuleProperties {
  @doc("The rights associated with the rule.")
  rights: AccessRights[];
}

@doc("Namespace/Relay Connection String")
model AccessKeys {
  @doc("Primary connection string of the created namespace authorization rule.")
  primaryConnectionString?: string;

  @doc("Secondary connection string of the created namespace authorization rule.")
  secondaryConnectionString?: string;

  @doc("A base64-encoded 256-bit primary key for signing and validating the SAS token.")
  primaryKey?: string;

  @doc("A base64-encoded 256-bit secondary key for signing and validating the SAS token.")
  secondaryKey?: string;

  @doc("A string that describes the authorization rule.")
  keyName?: string;
}

@doc("Parameters supplied to the regenerate authorization rule operation, specifies which key needs to be reset.")
model RegenerateAccessKeyParameters {
  @doc("The access key to regenerate.")
  keyType: KeyType;

  @doc("Optional. If the key value is provided, this is set to key type, or autogenerated key value set for key type.")
  key?: string;
}

@doc("Properties of the HybridConnection.")
model HybridConnectionProperties {
  @doc("The time the hybrid connection was created.")
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  createdAt?: utcDateTime;

  @doc("The time the namespace was updated.")
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  updatedAt?: utcDateTime;

  @doc("The number of listeners for this hybrid connection. Note that min : 1 and max:25 are supported.")
  @visibility("read")
  listenerCount?: int32;

  @doc("Returns true if client authorization is needed for this hybrid connection; otherwise, false.")
  requiresClientAuthorization?: boolean;

  @doc("The usermetadata is a placeholder to store user-defined string data for the hybrid connection endpoint. For example, it can be used to store descriptive data, such as a list of teams and their contact information. Also, user-defined configuration settings can be stored.")
  userMetadata?: string;
}

@doc("Description of the check name availability request properties.")
model CheckNameAvailability {
  @doc("The namespace name to check for availability. The namespace name can contain only letters, numbers, and hyphens. The namespace must start with a letter, and it must end with a letter or number.")
  name: string;
}

@doc("Description of the check name availability request properties.")
model CheckNameAvailabilityResult {
  @doc("The detailed info regarding the reason associated with the namespace.")
  @visibility("read")
  message?: string;

  @doc("Value indicating namespace is available. Returns true if the namespace is available; otherwise, false.")
  nameAvailable?: boolean;

  @doc("The reason for unavailability of a namespace.")
  reason?: UnavailableReason;
}

@doc("SKU of the namespace.")
model Sku {
  @doc("Name of this SKU.")
  name: SkuName;

  @doc("The tier of this SKU.")
  tier?: SkuTier;
}

@doc("Properties of the namespace.")
model RelayNamespaceProperties {
  @doc("Provisioning state of the Namespace.")
  @visibility("read")
  provisioningState?: string;

  @doc("Status of the Namespace.")
  @visibility("read")
  status?: string;

  @doc("The time the namespace was created.")
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  createdAt?: utcDateTime;

  @doc("The time the namespace was updated.")
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  updatedAt?: utcDateTime;

  @doc("Endpoint you can use to perform Service Bus operations.")
  @visibility("read")
  serviceBusEndpoint?: string;

  @doc("Identifier for Azure Insights metrics.")
  @visibility("read")
  metricId?: string;

  @doc("List of private endpoint connections.")
  privateEndpointConnections?: PrivateEndpointConnection[];

  @doc("This determines if traffic is allowed over public network. By default it is enabled.")
  publicNetworkAccess?: PublicNetworkAccess;
}

@doc("Properties of the private endpoint connection resource.")
model PrivateEndpointConnectionProperties {
  @doc("The Private Endpoint resource for this Connection.")
  privateEndpoint?: PrivateEndpoint;

  @doc("Details about the state of the connection.")
  privateLinkServiceConnectionState?: ConnectionState;

  @doc("Provisioning state of the Private Endpoint Connection.")
  provisioningState?: EndPointProvisioningState;
}

@doc("PrivateEndpoint information.")
model PrivateEndpoint {
  @doc("The ARM identifier for Private Endpoint.")
  id?: string;
}

@doc("ConnectionState information.")
model ConnectionState {
  @doc("Status of the connection.")
  status?: PrivateLinkConnectionStatus;

  @doc("Description of the connection state.")
  description?: string;
}

@doc("Definition of resource.")
model ResourceNamespacePatch {
  ...Resource;

  @doc("Resource tags.")
  tags?: Record<string>;
}

@doc("Properties of PrivateLinkResource")
model PrivateLinkResourceProperties {
  @doc("The private link resource group id.")
  groupId?: string;

  @doc("The private link resource required member names.")
  requiredMembers?: string[];

  @doc("The private link resource Private link DNS zone name.")
  requiredZoneNames?: string[];
}

@doc("NetworkRuleSet properties")
model NetworkRuleSetProperties {
  @doc("Default Action for Network Rule Set")
  defaultAction?: DefaultAction;

  @doc("This determines if traffic is allowed over public network. By default it is enabled")
  publicNetworkAccess?: PublicNetworkAccess;

  @doc("List of IpRules")
  ipRules?: NWRuleSetIpRules[];
}

@doc("The response from the List namespace operation.")
model NWRuleSetIpRules {
  @doc("IP Mask")
  ipMask?: string;

  @doc("The IP Filter Action")
  action?: NetworkRuleIPAction;
}

@doc("Properties of the WCF relay.")
model WcfRelayProperties {
  @doc("Returns true if the relay is dynamic; otherwise, false.")
  @visibility("read")
  isDynamic?: boolean;

  @doc("The time the WCF relay was created.")
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  createdAt?: utcDateTime;

  @doc("The time the namespace was updated.")
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  updatedAt?: utcDateTime;

  @doc("The number of listeners for this relay. Note that min :1 and max:25 are supported.")
  @visibility("read")
  listenerCount?: int32;

  @doc("WCF relay type.")
  relayType?: Relaytype;

  @doc("Returns true if client authorization is needed for this relay; otherwise, false.")
  requiresClientAuthorization?: boolean;

  @doc("Returns true if transport security is needed for this relay; otherwise, false.")
  requiresTransportSecurity?: boolean;

  @doc("The usermetadata is a placeholder to store user-defined string data for the WCF Relay endpoint. For example, it can be used to store descriptive data, such as list of teams and their contact information. Also, user-defined configuration settings can be stored.")
  userMetadata?: string;
}
