import "@typespec/rest";
import "@typespec/http";
import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-azure-resource-manager";

using TypeSpec.Rest;
using TypeSpec.Http;
using Azure.Core;
using Azure.ResourceManager;
using Azure.ResourceManager.Foundations;

namespace Microsoft.Relay;

interface Operations extends Azure.ResourceManager.Operations {}

enum AccessRights {
  Manage,
  Send,
  Listen,
}

/**
 * The access key to regenerate.
 */
enum KeyType {
  PrimaryKey,
  SecondaryKey,
}

/**
 * Specifies the reason for the unavailability of the service.
 */
enum UnavailableReason {
  None,
  InvalidName,
  SubscriptionIsDisabled,
  NameInUse,
  NameInLockdown,
  TooManyNamespaceInCurrentSubscription,
}

/**
 * Name of this SKU.
 */
enum SkuName {
  Standard,
}

/**
 * Status of the connection.
 */
enum PrivateLinkConnectionStatus {
  Pending,
  Approved,
  Rejected,
  Disconnected,
}

/**
 * Provisioning state of the Private Endpoint Connection.
 */
enum EndPointProvisioningState {
  Creating,
  Updating,
  Deleting,
  Succeeded,
  Canceled,
  Failed,
}

/**
 * This determines if traffic is allowed over public network. By default it is enabled. DO NOT USE PublicNetworkAccess on Namespace API. Please use the NetworkRuleSet API to enable or disable PublicNetworkAccess.
 */
enum PublicNetworkAccess {
  Enabled,
  Disabled,
  SecuredByPerimeter,
}

/**
 * Default Action for Network Rule Set
 */
enum DefaultAction {
  Allow,
  Deny,
}

/**
 * The IP Filter Action
 */
enum NetworkRuleIPAction {
  Allow,
}

/**
 * WCF relay type.
 */
@fixed
enum Relaytype {
  NetTcp,
  Http,
}

/**
 * Properties supplied to create or update AuthorizationRule
 */
model AuthorizationRuleProperties {
  /**
   * The rights associated with the rule.
   */
  rights: AccessRights[];
}

/**
 * Namespace/Relay Connection String
 */
model AccessKeys {
  /**
   * Primary connection string of the created namespace authorization rule.
   */
  primaryConnectionString?: string;

  /**
   * Secondary connection string of the created namespace authorization rule.
   */
  secondaryConnectionString?: string;

  /**
   * A base64-encoded 256-bit primary key for signing and validating the SAS token.
   */
  primaryKey?: string;

  /**
   * A base64-encoded 256-bit secondary key for signing and validating the SAS token.
   */
  secondaryKey?: string;

  /**
   * A string that describes the authorization rule.
   */
  keyName?: string;
}

/**
 * Parameters supplied to the regenerate authorization rule operation, specifies which key needs to be reset.
 */
model RegenerateAccessKeyParameters {
  /**
   * The access key to regenerate.
   */
  keyType: KeyType;

  /**
   * Optional. If the key value is provided, this is set to key type, or autogenerated key value set for key type.
   */
  key?: string;
}

/**
 * Properties of the HybridConnection.
 */
model HybridConnectionProperties {
  /**
   * The time the hybrid connection was created.
   */
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  createdAt?: utcDateTime;

  /**
   * The time the namespace was updated.
   */
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  updatedAt?: utcDateTime;

  /**
   * The number of listeners for this hybrid connection. Note that min : 1 and max:25 are supported.
   */
  @visibility("read")
  @maxValue(25)
  listenerCount?: int32;

  /**
   * Returns true if client authorization is needed for this hybrid connection; otherwise, false.
   */
  requiresClientAuthorization?: boolean;

  /**
   * The usermetadata is a placeholder to store user-defined string data for the hybrid connection endpoint. For example, it can be used to store descriptive data, such as a list of teams and their contact information. Also, user-defined configuration settings can be stored.
   */
  userMetadata?: string;
}

/**
 * Description of the check name availability request properties.
 */
model CheckNameAvailability {
  /**
   * The namespace name to check for availability. The namespace name can contain only letters, numbers, and hyphens. The namespace must start with a letter, and it must end with a letter or number.
   */
  name: string;
}

/**
 * Description of the check name availability request properties.
 */
model CheckNameAvailabilityResult {
  /**
   * The detailed info regarding the reason associated with the namespace.
   */
  @visibility("read")
  message?: string;

  /**
   * Value indicating namespace is available. Returns true if the namespace is available; otherwise, false.
   */
  nameAvailable?: boolean;

  /**
   * The reason for unavailability of a namespace.
   */
  reason?: UnavailableReason;
}

/**
 * SKU of the namespace.
 */
model Sku {
  /**
   * Name of this SKU.
   */
  name: SkuName;

  /**
   * The tier of this SKU.
   */
  tier?: SkuTier;
}

/**
 * Properties of the namespace.
 */
model RelayNamespaceProperties {
  /**
   * Provisioning state of the Namespace.
   */
  @visibility("read")
  provisioningState?: string;

  /**
   * Status of the Namespace.
   */
  @visibility("read")
  status?: string;

  /**
   * The time the namespace was created.
   */
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  createdAt?: utcDateTime;

  /**
   * The time the namespace was updated.
   */
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  updatedAt?: utcDateTime;

  /**
   * Endpoint you can use to perform Service Bus operations.
   */
  @visibility("read")
  serviceBusEndpoint?: string;

  /**
   * Identifier for Azure Insights metrics.
   */
  @visibility("read")
  metricId?: string;

  /**
   * List of private endpoint connections.
   */
  privateEndpointConnections?: PrivateEndpointConnection[];

  /**
   * This determines if traffic is allowed over public network. By default it is enabled. DO NOT USE PublicNetworkAccess on Namespace API. Please use the NetworkRuleSet API to enable or disable PublicNetworkAccess.
   */
  publicNetworkAccess?: PublicNetworkAccess;
}

/**
 * Properties of the private endpoint connection resource.
 */
model PrivateEndpointConnectionProperties {
  /**
   * The Private Endpoint resource for this Connection.
   */
  privateEndpoint?: PrivateEndpoint;

  /**
   * Details about the state of the connection.
   */
  privateLinkServiceConnectionState?: ConnectionState;

  /**
   * Provisioning state of the Private Endpoint Connection.
   */
  provisioningState?: EndPointProvisioningState;
}

/**
 * PrivateEndpoint information.
 */
model PrivateEndpoint {
  /**
   * The ARM identifier for Private Endpoint.
   */
  id?: string;
}

/**
 * ConnectionState information.
 */
model ConnectionState {
  /**
   * Status of the connection.
   */
  status?: PrivateLinkConnectionStatus;

  /**
   * Description of the connection state.
   */
  description?: string;
}

/**
 * The resource definition.
 */
model Resource {
  /**
   * Resource ID.
   */
  @visibility("read")
  id?: string;

  /**
   * Resource name.
   */
  @visibility("read")
  name?: string;

  /**
   * Resource type.
   */
  @visibility("read")
  type?: string;
}

/**
 * Description of a namespace resource.
 */
model RelayUpdateParameters extends ResourceNamespacePatch {
  /**
   * SKU of the namespace.
   */
  sku?: Sku;

  /**
   * Description of Relay namespace.
   */
  properties?: RelayNamespaceProperties;
}

/**
 * Definition of resource.
 */
model ResourceNamespacePatch extends Resource {
  /**
   * Resource tags.
   */
  tags?: Record<string>;
}

/**
 * Properties of PrivateLinkResource
 */
model PrivateLinkResourceProperties {
  /**
   * The private link resource group id.
   */
  groupId?: string;

  /**
   * The private link resource required member names.
   */
  requiredMembers?: string[];

  /**
   * The private link resource Private link DNS zone name.
   */
  requiredZoneNames?: string[];
}

/**
 * NetworkRuleSet properties
 */
model NetworkRuleSetProperties {
  /**
   * Default Action for Network Rule Set
   */
  defaultAction?: DefaultAction;

  /**
   * This determines if traffic is allowed over public network. By default it is enabled
   */
  publicNetworkAccess?: PublicNetworkAccess;

  /**
   * List of IpRules
   */
  ipRules?: RelayNetworkRuleSetIPRule[];
}

/**
 * The response from the List namespace operation.
 */
model RelayNetworkRuleSetIPRule {
  /**
   * IP Mask
   */
  ipMask?: string;

  /**
   * The IP Filter Action
   */
  action?: NetworkRuleIPAction;
}

/**
 * Properties of the WCF relay.
 */
model WcfRelayProperties {
  /**
   * Returns true if the relay is dynamic; otherwise, false.
   */
  @visibility("read")
  isDynamic?: boolean;

  /**
   * The time the WCF relay was created.
   */
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  createdAt?: utcDateTime;

  /**
   * The time the namespace was updated.
   */
  @visibility("read")
  // FIXME: (utcDateTime) Please double check that this is the correct type for your scenario.
  updatedAt?: utcDateTime;

  /**
   * The number of listeners for this relay. Note that min :1 and max:25 are supported.
   */
  @visibility("read")
  @maxValue(25)
  listenerCount?: int32;

  /**
   * WCF relay type.
   */
  relayType?: Relaytype;

  /**
   * Returns true if client authorization is needed for this relay; otherwise, false.
   */
  requiresClientAuthorization?: boolean;

  /**
   * Returns true if transport security is needed for this relay; otherwise, false.
   */
  requiresTransportSecurity?: boolean;

  /**
   * The usermetadata is a placeholder to store user-defined string data for the WCF Relay endpoint. For example, it can be used to store descriptive data, such as list of teams and their contact information. Also, user-defined configuration settings can be stored.
   */
  userMetadata?: string;
}
