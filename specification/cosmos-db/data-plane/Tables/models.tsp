import "@typespec/rest";
import "@typespec/http";
import "@typespec/xml";
import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-client-generator-core";

using Azure.Core;
using TypeSpec.Http;
using Azure.ClientGenerator.Core;

namespace Data.Tables;

/** Specifies the level of metadata to be returned with the response. */
union OdataMetadataFormat {
  string,

  /** No metadata. */
  NoMetadata: "application/json;odata=nometadata",

  /** Minimal metadata. This is the default and the minimum required for full deserialization. */
  MinimalMetadata: "application/json;odata=minimalmetadata",

  /** Full metadata. */
  FullMetadata: "application/json;odata=fullmetadata",
}

/** Specifies whether the response should echo the created content. */
union ResponseFormat {
  string,

  /** Do not echo the created content. */
  NoEcho: "return-no-content",

  /** Echo the created content. */
  Echo: "return-content",
}

/** The properties for the table entity. */
alias TableEntityProperties = Record<unknown>;

/** The type for values of entity properties */
alias EntityValueType = string | numeric | boolean;

/** The table name parameter. */
alias TablePathParameter = {
  /** The name of the table. */
  @path
  table: string;
};

/** Specifies the version of the operation to use for this request. */
alias ApiVersionHeader = {
  /** The API version. */
  @apiVersion
  @header("x-ms-version")
  apiVersion: string;
};

/** The timeout parameter. */
alias TimeoutParameter = {
  @doc("The timeout parameter is expressed in seconds.")
  @query
  @minValue(0)
  timeout?: int32;
};

/** The format parameter */
alias FormatParameter = {
  @doc("Specifies the metadata format for the response.")
  @query
  $format?: OdataMetadataFormat;
};

/** The top parameter */
alias TopParameter = {
  @doc("Specifies the maximum number of records to return.")
  @query
  $top?: int32;
};

/** The select parameter */
alias SelectParameter = {
  @doc("Select expression using OData notation. Limits the columns on each record to just those requested.")
  @query
  $select?: string;
};

/** The filter parameter */
alias FilterParameter = {
  @doc("OData filter expression.")
  @query
  $filter?: string;
};

/** Client request ID header */
alias ClientRequestIdHeader = {
  @access(Access.internal)
  @header("x-ms-client-request-id")
  @doc("An opaque, globally-unique, client-generated string identifier for the request.")
  clientRequestId?: uuid;
};

/** Request ID response header */
alias RequestIdResponseHeader = {
  @access(Access.internal)
  @visibility(Lifecycle.Read)
  @header("x-ms-request-id")
  @doc("An opaque, globally-unique, server-generated string identifier for the request.")
  requestId?: uuid;
};

/** The Date response header */
alias DateResponseHeader = {
  /** UTC date/time value generated by the service that indicates the time at which the response was initiated */
  #suppress "@azure-tools/typespec-azure-core/known-encoding" "Existing API"
  @encode("rfc7231")
  @header("Date")
  date: utcDateTime;
};

/** The ETag response header */
alias EtagResponseHeader = {
  /** The ETag contains a value that you can use to perform operations conditionally. */
  @header("ETag") eTag: string;
};

/**
 * The properties for the table query response.
 */
model TablesPagedResult {
  /**
   * The metadata response of the table.
   */
  @visibility(Lifecycle.Read, Lifecycle.Query)
  @encodedName("application/json", "odata.metadata")
  @clientName("metadata")
  @access(Access.internal)
  odataMetadata?: string;

  @doc("The requested list of tables.")
  @pageItems
  value?: TableProperties[];
}

/**
 * The properties for the table response.
 */
model TableProperties {
  /**
   * The name of the table.
   */
  @encodedName("application/json", "TableName")
  tableName?: string;

  /**
   * The odata type of the table.
   */
  @visibility(Lifecycle.Read, Lifecycle.Query)
  @encodedName("application/json", "odata.type")
  @clientName("type")
  @access(Access.internal)
  odataType?: string;

  /**
   * The id of the table.
   */
  @visibility(Lifecycle.Read, Lifecycle.Query)
  @encodedName("application/json", "odata.id")
  @clientName("id")
  @access(Access.internal)
  odataId?: string;

  /**
   * The edit link of the table.
   */
  @visibility(Lifecycle.Read, Lifecycle.Query)
  @encodedName("application/json", "odata.editLink")
  @clientName("editLink")
  @access(Access.internal)
  odataEditLink?: string;
}

/**
 * The properties for the table entity query response.
 */
model TableEntitiesPagedResult {
  /**
   * The metadata response of the table.
   */
  @visibility(Lifecycle.Read, Lifecycle.Query)
  @encodedName("application/json", "odata.metadata")
  @clientName("metadata")
  @access(Access.internal)
  odataMetadata?: string;

  /**
   * List of table entities.
   */
  @pageItems
  value?: TableEntityProperties[];
}

/** The multipart body parameter. */
alias TransactionBodyParameter = {
  /** The body of the request. */
  @multipartBody body: {
    name: HttpPart<string>;
    body: HttpPart<bytes>;
  };
};

/// Table ACL

/** Represents an array of signed identifiers */
@Xml.name("SignedIdentifiers")
model SignedIdentifiers is Array<SignedIdentifier>;

/** The signed identifier. */
@Xml.name("SignedIdentifier")
model SignedIdentifier {
  /** The unique ID for the signed identifier. */
  @Xml.name("Id") id: string;

  /** The access policy for the signed identifier. */
  @Xml.name("AccessPolicy") accessPolicy: AccessPolicy;
}

/** An access policy. */
model AccessPolicy {
  /** The date-time the policy is active. */
  @Xml.name("Start")
  @encode("rfc7231")
  start: utcDateTime;

  /** The date-time the policy expires. */
  @Xml.name("Expiry")
  @encode("rfc7231")
  expiry: utcDateTime;

  /** The permissions for acl the policy. */
  @Xml.name("Permission") permission: string;
}

/// Service Properties

/** The service properties. */
model TableServiceProperties {
  /** The logging properties. */
  @Xml.name("Logging") logging?: Logging;

  /** The hour metrics properties. */
  @Xml.name("HourMetrics") hourMetrics?: Metrics;

  /** The minute metrics properties. */
  @Xml.name("MinuteMetrics") minuteMetrics?: Metrics;

  /** The CORS properties. */
  @Xml.name("Cors") cors?: CorsRule[];
}

/** Azure Analytics Logging settings. */
model Logging {
  /** The version of the logging properties. */
  @Xml.name("Version") version: string;

  /** Whether delete operation is logged. */
  @Xml.name("Delete") delete: boolean;

  /** Whether read operation is logged. */
  @Xml.name("Read") read: boolean;

  /** Whether write operation is logged. */
  @Xml.name("Write") write: boolean;

  /** The retention policy of the logs. */
  @Xml.name("RetentionPolicy") retentionPolicy: RetentionPolicy;
}

/** The retention policy. */
model RetentionPolicy {
  /** Whether to enable the retention policy. */
  @Xml.name("Enabled") enabled: boolean;

  /**
   * Indicates the number of days that metrics or logging or soft-deleted data
   * should be retained. All data older than this value will be deleted.
   */
  @Xml.name("Days")
  @minValue(1)
  days?: int32;
}

/** The metrics properties. */
model Metrics {
  /** The version of the metrics properties. */
  @Xml.name("Version") version?: string;

  /**
   * Indicates whether metrics are enabled for the Table service.
   */
  @Xml.name("Enabled") enabled: boolean;

  /**
   * Indicates whether metrics should generate summary statistics for called API
   * operations.
   */
  @Xml.name("IncludeAPIs") includeApis?: boolean;

  /** The retention policy of the metrics. */
  @Xml.name("RetentionPolicy") retentionPolicy?: RetentionPolicy;
}

/** CORS is an HTTP feature that enables a web application running under one domain to access resources in another domain. Web browsers implement a security restriction known as same-origin policy that prevents a web page from calling APIs in a different domain; CORS provides a secure way to allow one domain (the origin domain) to call APIs in another domain */
model CorsRule {
  /**
   * The origin domains that are permitted to make a request against the service via
   * CORS. The origin domain is the domain from which the request originates. Note
   * that the origin must be an exact case-sensitive match with the origin that the
   * user age sends to the service. You can also use the wildcard character '*' to
   * allow all origin domains to make requests via CORS.
   */
  @Xml.name("AllowedOrigins") allowedOrigins: string;

  /**
   * The methods (HTTP request verbs) that the origin domain may use for a CORS
   * request.
   */
  @Xml.name("AllowedMethods") allowedMethods: string;

  /**
   * The request headers that the origin domain may specify on the CORS request.
   */
  @Xml.name("AllowedHeaders") allowedHeaders: string;

  /**
   * The response headers that may be sent in the response to the CORS request and
   * exposed by the browser to the request issuer.
   */
  @Xml.name("ExposedHeaders") exposedHeaders: string;

  /**
   * The maximum amount time that a browser should cache the preflight OPTIONS
   * request.
   */
  @Xml.name("MaxAgeInSeconds")
  @minValue(0)
  maxAgeInSeconds: int32;
}

/** Stats for the table service. */
model TableServiceStats {
  /** Geo-Replication information for the Secondary Storage Service. */
  @Xml.name("GeoReplication") geoReplication?: GeoReplication;
}

/** Geo-Replication information for the Secondary Storage Service */
model GeoReplication {
  /** The status of the secondary location */
  @Xml.name("Status") status: GeoReplicationStatusType;

  /** A GMT date/time value, to the second. All primary writes preceding this value are guaranteed to be available for read operations at the secondary. Primary writes after this point in time may or may not be available for reads. */
  @encode("rfc7231")
  @Xml.name("LastSyncTime")
  lastSyncTime: utcDateTime;
}

/** The status of the secondary location. */
union GeoReplicationStatusType {
  /** The geo replication is live. */
  Live: "live",

  /** The geo replication is bootstrap. */
  Bootstrap: "bootstrap",

  /** The geo replication is unavailable. */
  Unavailable: "unavailable",

  /** Extensible */
  string,
}

/// Error responses

/** The Tables service XML error. */
@error
@mediaTypeHint("application/xml")
model TablesServiceError {
  /** The error code. */
  @header("x-ms-error-code")
  errorCode?: string;

  /** The error code. */
  @Xml.name("Code") code?: string;

  /** The error message. */
  @Xml.name("Message") message?: string;
}

/** Table JSON error. */
@error
model TablesError {
  /** The error code. */
  @header("x-ms-error-code")
  errorCode?: string;

  /** The error message. */
  @encodedName("application/json", "Message")
  @clientName("message")
  message?: string;
}

/// Conditional responses

/** The table properties as returned in an echo response. */
model TableResponse {
  ...TableProperties;

  /**
   * The metadata response of the table.
   */
  @visibility(Lifecycle.Read, Lifecycle.Query)
  @encodedName("application/json", "odata.metadata")
  @clientName("metadata")
  @access(Access.internal)
  odataMetadata?: string;
}

/** Create table successful response with content */
model CreateTableEchoResponse {
  /** 201 Created. Includes echo response */
  @statusCode statusCode: 201;

  /** Content-Type header */
  @header("Content-Type")
  contentType: string;

  /** Whether the content echo was requested and applied. */
  @header("Preference-Applied")
  contentEcho?: string;

  ...ApiVersionHeader;
  ...RequestIdResponseHeader;
  ...ClientRequestIdHeader;
  ...DateResponseHeader;

  /** The created table properties. */
  @body
  tableProperties: TableResponse;
}

/** Create table response with no content */
model CreateTableResponse {
  /** 204 No Content. Response with no echo. */
  @statusCode statusCode: 204;

  /** Whether the content echo was requested and applied. */
  @header("Preference-Applied")
  contentEcho?: string;

  ...ApiVersionHeader;
  ...RequestIdResponseHeader;
  ...ClientRequestIdHeader;
  ...DateResponseHeader;
}

/** Insert entity successful response with content */
model InsertEntityEchoResponse {
  /** 201 Created. Includes echo response */
  @statusCode statusCode: 201;

  /** Content-Type header */
  @header("Content-Type")
  contentType: string;

  /** Whether the content echo was requested and applied. */
  @header("Preference-Applied")
  contentEcho?: string;

  ...ApiVersionHeader;
  ...RequestIdResponseHeader;
  ...ClientRequestIdHeader;
  ...DateResponseHeader;
  ...EtagResponseHeader;

  /** The created entity properties. */
  #suppress "@azure-tools/typespec-azure-core/bad-record-type" "Union types are not supported"
  @body
  tableEntityProperties: TableEntityProperties;
}

/** Insert entity response with no content */
model InsertEntityResponse {
  /** 204 No Content. Response with no echo. */
  @statusCode statusCode: 204;

  /** Whether the content echo was requested and applied. */
  @header("Preference-Applied")
  contentEcho?: string;

  ...ApiVersionHeader;
  ...RequestIdResponseHeader;
  ...ClientRequestIdHeader;
  ...DateResponseHeader;
  ...EtagResponseHeader;
}
