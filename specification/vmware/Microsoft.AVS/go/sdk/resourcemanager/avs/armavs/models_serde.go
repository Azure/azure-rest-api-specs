// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armavs

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type Addon.
func (a Addon) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Addon.
func (a *Addon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			a.Properties, err = unmarshalAddonPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonArcProperties.
func (a AddonArcProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["addonType"] = AddonTypeArc
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "vCenter", a.VCenter)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonArcProperties.
func (a *AddonArcProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
				err = unpopulate(val, "AddonType", &a.AddonType)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "vCenter":
				err = unpopulate(val, "VCenter", &a.VCenter)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonHcxProperties.
func (a AddonHcxProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["addonType"] = AddonTypeHCX
	populate(objectMap, "offer", a.Offer)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonHcxProperties.
func (a *AddonHcxProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
				err = unpopulate(val, "AddonType", &a.AddonType)
			delete(rawMsg, key)
		case "offer":
				err = unpopulate(val, "Offer", &a.Offer)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonListResult.
func (a AddonListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonListResult.
func (a *AddonListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonProperties.
func (a AddonProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "addonType", a.AddonType)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonProperties.
func (a *AddonProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
				err = unpopulate(val, "AddonType", &a.AddonType)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonSrmProperties.
func (a AddonSrmProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["addonType"] = AddonTypeSRM
	populate(objectMap, "licenseKey", a.LicenseKey)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonSrmProperties.
func (a *AddonSrmProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
				err = unpopulate(val, "AddonType", &a.AddonType)
			delete(rawMsg, key)
		case "licenseKey":
				err = unpopulate(val, "LicenseKey", &a.LicenseKey)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddonVrProperties.
func (a AddonVrProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["addonType"] = AddonTypeVR
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "vrsCount", a.VrsCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddonVrProperties.
func (a *AddonVrProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addonType":
				err = unpopulate(val, "AddonType", &a.AddonType)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "vrsCount":
				err = unpopulate(val, "VrsCount", &a.VrsCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AdminCredentials.
func (a AdminCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nsxtPassword", a.NsxtPassword)
	populate(objectMap, "nsxtUsername", a.NsxtUsername)
	populate(objectMap, "vcenterPassword", a.VcenterPassword)
	populate(objectMap, "vcenterUsername", a.VcenterUsername)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdminCredentials.
func (a *AdminCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nsxtPassword":
				err = unpopulate(val, "NsxtPassword", &a.NsxtPassword)
			delete(rawMsg, key)
		case "nsxtUsername":
				err = unpopulate(val, "NsxtUsername", &a.NsxtUsername)
			delete(rawMsg, key)
		case "vcenterPassword":
				err = unpopulate(val, "VcenterPassword", &a.VcenterPassword)
			delete(rawMsg, key)
		case "vcenterUsername":
				err = unpopulate(val, "VcenterUsername", &a.VcenterUsername)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArmOperationStatus.
func (a ArmOperationStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "error", a.Error)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "percentComplete", a.PercentComplete)
	populateDateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArmOperationStatus.
func (a *ArmOperationStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &a.EndTime)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &a.Error)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "percentComplete":
				err = unpopulate(val, "PercentComplete", &a.PercentComplete)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &a.StartTime)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ArmResource.
func (a ArmResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ArmResource.
func (a *ArmResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AvailabilityProperties.
func (a AvailabilityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secondaryZone", a.SecondaryZone)
	populate(objectMap, "strategy", a.Strategy)
	populate(objectMap, "zone", a.Zone)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailabilityProperties.
func (a *AvailabilityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secondaryZone":
				err = unpopulate(val, "SecondaryZone", &a.SecondaryZone)
			delete(rawMsg, key)
		case "strategy":
				err = unpopulate(val, "Strategy", &a.Strategy)
			delete(rawMsg, key)
		case "zone":
				err = unpopulate(val, "Zone", &a.Zone)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Circuit.
func (c Circuit) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expressRouteID", c.ExpressRouteID)
	populate(objectMap, "expressRoutePrivatePeeringID", c.ExpressRoutePrivatePeeringID)
	populate(objectMap, "primarySubnet", c.PrimarySubnet)
	populate(objectMap, "secondarySubnet", c.SecondarySubnet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Circuit.
func (c *Circuit) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expressRouteID":
				err = unpopulate(val, "ExpressRouteID", &c.ExpressRouteID)
			delete(rawMsg, key)
		case "expressRoutePrivatePeeringID":
				err = unpopulate(val, "ExpressRoutePrivatePeeringID", &c.ExpressRoutePrivatePeeringID)
			delete(rawMsg, key)
		case "primarySubnet":
				err = unpopulate(val, "PrimarySubnet", &c.PrimarySubnet)
			delete(rawMsg, key)
		case "secondarySubnet":
				err = unpopulate(val, "SecondarySubnet", &c.SecondarySubnet)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudLink.
func (c CloudLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudLink.
func (c *CloudLink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudLinkListResult.
func (c CloudLinkListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudLinkListResult.
func (c *CloudLinkListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudLinkProperties.
func (c CloudLinkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "linkedCloud", c.LinkedCloud)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "status", c.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudLinkProperties.
func (c *CloudLinkProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedCloud":
				err = unpopulate(val, "LinkedCloud", &c.LinkedCloud)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Cluster.
func (c Cluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "sku", c.SKU)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Cluster.
func (c *Cluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "sku":
				err = unpopulate(val, "SKU", &c.SKU)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterListResult.
func (c ClusterListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterListResult.
func (c *ClusterListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterProperties.
func (c ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterId", c.ClusterID)
	populate(objectMap, "clusterSize", c.ClusterSize)
	populate(objectMap, "hosts", c.Hosts)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "vsanDatastoreName", c.VsanDatastoreName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterProperties.
func (c *ClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterId":
				err = unpopulate(val, "ClusterID", &c.ClusterID)
			delete(rawMsg, key)
		case "clusterSize":
				err = unpopulate(val, "ClusterSize", &c.ClusterSize)
			delete(rawMsg, key)
		case "hosts":
				err = unpopulate(val, "Hosts", &c.Hosts)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "vsanDatastoreName":
				err = unpopulate(val, "VsanDatastoreName", &c.VsanDatastoreName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdate.
func (c ClusterUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "sku", c.SKU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterUpdate.
func (c *ClusterUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "sku":
				err = unpopulate(val, "SKU", &c.SKU)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterUpdateProperties.
func (c ClusterUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterSize", c.ClusterSize)
	populate(objectMap, "hosts", c.Hosts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterUpdateProperties.
func (c *ClusterUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterSize":
				err = unpopulate(val, "ClusterSize", &c.ClusterSize)
			delete(rawMsg, key)
		case "hosts":
				err = unpopulate(val, "Hosts", &c.Hosts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterZone.
func (c ClusterZone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hosts", c.Hosts)
	populate(objectMap, "zone", c.Zone)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterZone.
func (c *ClusterZone) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hosts":
				err = unpopulate(val, "Hosts", &c.Hosts)
			delete(rawMsg, key)
		case "zone":
				err = unpopulate(val, "Zone", &c.Zone)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterZoneList.
func (c ClusterZoneList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "zones", c.Zones)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterZoneList.
func (c *ClusterZoneList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "zones":
				err = unpopulate(val, "Zones", &c.Zones)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Datastore.
func (d Datastore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Datastore.
func (d *Datastore) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &d.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatastoreListResult.
func (d DatastoreListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatastoreListResult.
func (d *DatastoreListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &d.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatastoreProperties.
func (d DatastoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskPoolVolume", d.DiskPoolVolume)
	populate(objectMap, "elasticSanVolume", d.ElasticSanVolume)
	populate(objectMap, "netAppVolume", d.NetAppVolume)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "status", d.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatastoreProperties.
func (d *DatastoreProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskPoolVolume":
				err = unpopulate(val, "DiskPoolVolume", &d.DiskPoolVolume)
			delete(rawMsg, key)
		case "elasticSanVolume":
				err = unpopulate(val, "ElasticSanVolume", &d.ElasticSanVolume)
			delete(rawMsg, key)
		case "netAppVolume":
				err = unpopulate(val, "NetAppVolume", &d.NetAppVolume)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &d.ProvisioningState)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskPoolVolume.
func (d DiskPoolVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lunName", d.LunName)
	populate(objectMap, "mountOption", d.MountOption)
	populate(objectMap, "path", d.Path)
	populate(objectMap, "targetId", d.TargetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskPoolVolume.
func (d *DiskPoolVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lunName":
				err = unpopulate(val, "LunName", &d.LunName)
			delete(rawMsg, key)
		case "mountOption":
				err = unpopulate(val, "MountOption", &d.MountOption)
			delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &d.Path)
			delete(rawMsg, key)
		case "targetId":
				err = unpopulate(val, "TargetID", &d.TargetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ElasticSanVolume.
func (e ElasticSanVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "targetId", e.TargetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ElasticSanVolume.
func (e *ElasticSanVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "targetId":
				err = unpopulate(val, "TargetID", &e.TargetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Encryption.
func (e Encryption) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "keyVaultProperties", e.KeyVaultProperties)
	populate(objectMap, "status", e.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Encryption.
func (e *Encryption) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyVaultProperties":
				err = unpopulate(val, "KeyVaultProperties", &e.KeyVaultProperties)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionKeyVaultProperties.
func (e EncryptionKeyVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoDetectedKeyVersion", e.AutoDetectedKeyVersion)
	populate(objectMap, "keyName", e.KeyName)
	populate(objectMap, "keyState", e.KeyState)
	populate(objectMap, "keyVaultUrl", e.KeyVaultURL)
	populate(objectMap, "keyVersion", e.KeyVersion)
	populate(objectMap, "versionType", e.VersionType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionKeyVaultProperties.
func (e *EncryptionKeyVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoDetectedKeyVersion":
				err = unpopulate(val, "AutoDetectedKeyVersion", &e.AutoDetectedKeyVersion)
			delete(rawMsg, key)
		case "keyName":
				err = unpopulate(val, "KeyName", &e.KeyName)
			delete(rawMsg, key)
		case "keyState":
				err = unpopulate(val, "KeyState", &e.KeyState)
			delete(rawMsg, key)
		case "keyVaultUrl":
				err = unpopulate(val, "KeyVaultURL", &e.KeyVaultURL)
			delete(rawMsg, key)
		case "keyVersion":
				err = unpopulate(val, "KeyVersion", &e.KeyVersion)
			delete(rawMsg, key)
		case "versionType":
				err = unpopulate(val, "VersionType", &e.VersionType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Endpoints.
func (e Endpoints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hcxCloudManager", e.HcxCloudManager)
	populate(objectMap, "hcxCloudManagerIp", e.HcxCloudManagerIP)
	populate(objectMap, "nsxtManager", e.NsxtManager)
	populate(objectMap, "nsxtManagerIp", e.NsxtManagerIP)
	populate(objectMap, "vcenterIp", e.VcenterIP)
	populate(objectMap, "vcsa", e.Vcsa)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Endpoints.
func (e *Endpoints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hcxCloudManager":
				err = unpopulate(val, "HcxCloudManager", &e.HcxCloudManager)
			delete(rawMsg, key)
		case "hcxCloudManagerIp":
				err = unpopulate(val, "HcxCloudManagerIP", &e.HcxCloudManagerIP)
			delete(rawMsg, key)
		case "nsxtManager":
				err = unpopulate(val, "NsxtManager", &e.NsxtManager)
			delete(rawMsg, key)
		case "nsxtManagerIp":
				err = unpopulate(val, "NsxtManagerIP", &e.NsxtManagerIP)
			delete(rawMsg, key)
		case "vcenterIp":
				err = unpopulate(val, "VcenterIP", &e.VcenterIP)
			delete(rawMsg, key)
		case "vcsa":
				err = unpopulate(val, "Vcsa", &e.Vcsa)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
				err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
				err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExpressRouteAuthorization.
func (e ExpressRouteAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExpressRouteAuthorization.
func (e *ExpressRouteAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExpressRouteAuthorizationListResult.
func (e ExpressRouteAuthorizationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExpressRouteAuthorizationListResult.
func (e *ExpressRouteAuthorizationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExpressRouteAuthorizationProperties.
func (e ExpressRouteAuthorizationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expressRouteAuthorizationId", e.ExpressRouteAuthorizationID)
	populate(objectMap, "expressRouteAuthorizationKey", e.ExpressRouteAuthorizationKey)
	populate(objectMap, "expressRouteId", e.ExpressRouteID)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExpressRouteAuthorizationProperties.
func (e *ExpressRouteAuthorizationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expressRouteAuthorizationId":
				err = unpopulate(val, "ExpressRouteAuthorizationID", &e.ExpressRouteAuthorizationID)
			delete(rawMsg, key)
		case "expressRouteAuthorizationKey":
				err = unpopulate(val, "ExpressRouteAuthorizationKey", &e.ExpressRouteAuthorizationKey)
			delete(rawMsg, key)
		case "expressRouteId":
				err = unpopulate(val, "ExpressRouteID", &e.ExpressRouteID)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GlobalReachConnection.
func (g GlobalReachConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GlobalReachConnection.
func (g *GlobalReachConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GlobalReachConnectionListResult.
func (g GlobalReachConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GlobalReachConnectionListResult.
func (g *GlobalReachConnectionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GlobalReachConnectionProperties.
func (g GlobalReachConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "addressPrefix", g.AddressPrefix)
	populate(objectMap, "authorizationKey", g.AuthorizationKey)
	populate(objectMap, "circuitConnectionStatus", g.CircuitConnectionStatus)
	populate(objectMap, "expressRouteId", g.ExpressRouteID)
	populate(objectMap, "peerExpressRouteCircuit", g.PeerExpressRouteCircuit)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GlobalReachConnectionProperties.
func (g *GlobalReachConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addressPrefix":
				err = unpopulate(val, "AddressPrefix", &g.AddressPrefix)
			delete(rawMsg, key)
		case "authorizationKey":
				err = unpopulate(val, "AuthorizationKey", &g.AuthorizationKey)
			delete(rawMsg, key)
		case "circuitConnectionStatus":
				err = unpopulate(val, "CircuitConnectionStatus", &g.CircuitConnectionStatus)
			delete(rawMsg, key)
		case "expressRouteId":
				err = unpopulate(val, "ExpressRouteID", &g.ExpressRouteID)
			delete(rawMsg, key)
		case "peerExpressRouteCircuit":
				err = unpopulate(val, "PeerExpressRouteCircuit", &g.PeerExpressRouteCircuit)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &g.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcxEnterpriseSite.
func (h HcxEnterpriseSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcxEnterpriseSite.
func (h *HcxEnterpriseSite) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &h.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcxEnterpriseSiteListResult.
func (h HcxEnterpriseSiteListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcxEnterpriseSiteListResult.
func (h *HcxEnterpriseSiteListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcxEnterpriseSiteProperties.
func (h HcxEnterpriseSiteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "activationKey", h.ActivationKey)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populate(objectMap, "status", h.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcxEnterpriseSiteProperties.
func (h *HcxEnterpriseSiteProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activationKey":
				err = unpopulate(val, "ActivationKey", &h.ActivationKey)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &h.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentitySource.
func (i IdentitySource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alias", i.Alias)
	populate(objectMap, "baseGroupDN", i.BaseGroupDN)
	populate(objectMap, "baseUserDN", i.BaseUserDN)
	populate(objectMap, "domain", i.Domain)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "password", i.Password)
	populate(objectMap, "primaryServer", i.PrimaryServer)
	populate(objectMap, "ssl", i.SSL)
	populate(objectMap, "secondaryServer", i.SecondaryServer)
	populate(objectMap, "username", i.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentitySource.
func (i *IdentitySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
				err = unpopulate(val, "Alias", &i.Alias)
			delete(rawMsg, key)
		case "baseGroupDN":
				err = unpopulate(val, "BaseGroupDN", &i.BaseGroupDN)
			delete(rawMsg, key)
		case "baseUserDN":
				err = unpopulate(val, "BaseUserDN", &i.BaseUserDN)
			delete(rawMsg, key)
		case "domain":
				err = unpopulate(val, "Domain", &i.Domain)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &i.Password)
			delete(rawMsg, key)
		case "primaryServer":
				err = unpopulate(val, "PrimaryServer", &i.PrimaryServer)
			delete(rawMsg, key)
		case "ssl":
				err = unpopulate(val, "SSL", &i.SSL)
			delete(rawMsg, key)
		case "secondaryServer":
				err = unpopulate(val, "SecondaryServer", &i.SecondaryServer)
			delete(rawMsg, key)
		case "username":
				err = unpopulate(val, "Username", &i.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IscsiPath.
func (i IscsiPath) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IscsiPath.
func (i *IscsiPath) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &i.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &i.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IscsiPathListResult.
func (i IscsiPathListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IscsiPathListResult.
func (i *IscsiPathListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &i.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IscsiPathProperties.
func (i IscsiPathProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "networkBlock", i.NetworkBlock)
	populate(objectMap, "provisioningState", i.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IscsiPathProperties.
func (i *IscsiPathProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "networkBlock":
				err = unpopulate(val, "NetworkBlock", &i.NetworkBlock)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &i.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedSystemIdentityProperties.
func (m ManagedSystemIdentityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedSystemIdentityProperties.
func (m *ManagedSystemIdentityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
				err = unpopulate(val, "PrincipalID", &m.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
				err = unpopulate(val, "TenantID", &m.TenantID)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagementCluster.
func (m ManagementCluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterId", m.ClusterID)
	populate(objectMap, "clusterSize", m.ClusterSize)
	populate(objectMap, "hosts", m.Hosts)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "vsanDatastoreName", m.VsanDatastoreName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagementCluster.
func (m *ManagementCluster) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterId":
				err = unpopulate(val, "ClusterID", &m.ClusterID)
			delete(rawMsg, key)
		case "clusterSize":
				err = unpopulate(val, "ClusterSize", &m.ClusterSize)
			delete(rawMsg, key)
		case "hosts":
				err = unpopulate(val, "Hosts", &m.Hosts)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &m.ProvisioningState)
			delete(rawMsg, key)
		case "vsanDatastoreName":
				err = unpopulate(val, "VsanDatastoreName", &m.VsanDatastoreName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetAppVolume.
func (n NetAppVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", n.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetAppVolume.
func (n *NetAppVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &n.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
				err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
				err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
				err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
				err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
				err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
				err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
				err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PSCredentialExecutionParameter.
func (p PSCredentialExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "password", p.Password)
	objectMap["type"] = "Credential"
	populate(objectMap, "username", p.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PSCredentialExecutionParameter.
func (p *PSCredentialExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &p.Password)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "username":
				err = unpopulate(val, "Username", &p.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedOperation.
func (p PagedOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedOperation.
func (p *PagedOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicy.
func (p PlacementPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlacementPolicy.
func (p *PlacementPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
			p.Properties, err = unmarshalPlacementPolicyPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicyListResult.
func (p PlacementPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlacementPolicyListResult.
func (p *PlacementPolicyListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicyProperties.
func (p PlacementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "state", p.State)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlacementPolicyProperties.
func (p *PlacementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &p.State)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicyUpdate.
func (p PlacementPolicyUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlacementPolicyUpdate.
func (p *PlacementPolicyUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicyUpdateProperties.
func (p PlacementPolicyUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityStrength", p.AffinityStrength)
	populate(objectMap, "azureHybridBenefitType", p.AzureHybridBenefitType)
	populate(objectMap, "hostMembers", p.HostMembers)
	populate(objectMap, "state", p.State)
	populate(objectMap, "vmMembers", p.VMMembers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlacementPolicyUpdateProperties.
func (p *PlacementPolicyUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityStrength":
				err = unpopulate(val, "AffinityStrength", &p.AffinityStrength)
			delete(rawMsg, key)
		case "azureHybridBenefitType":
				err = unpopulate(val, "AzureHybridBenefitType", &p.AzureHybridBenefitType)
			delete(rawMsg, key)
		case "hostMembers":
				err = unpopulate(val, "HostMembers", &p.HostMembers)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &p.State)
			delete(rawMsg, key)
		case "vmMembers":
				err = unpopulate(val, "VMMembers", &p.VMMembers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloud.
func (p PrivateCloud) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateCloud.
func (p *PrivateCloud) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "identity":
				err = unpopulate(val, "Identity", &p.Identity)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &p.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "sku":
				err = unpopulate(val, "SKU", &p.SKU)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &p.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudListResult.
func (p PrivateCloudListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateCloudListResult.
func (p *PrivateCloudListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudProperties.
func (p PrivateCloudProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availability", p.Availability)
	populate(objectMap, "circuit", p.Circuit)
	populate(objectMap, "dnsZoneType", p.DNSZoneType)
	populate(objectMap, "encryption", p.Encryption)
	populate(objectMap, "endpoints", p.Endpoints)
	populate(objectMap, "extendedNetworkBlocks", p.ExtendedNetworkBlocks)
	populate(objectMap, "externalCloudLinks", p.ExternalCloudLinks)
	populate(objectMap, "identitySources", p.IdentitySources)
	populate(objectMap, "internet", p.Internet)
	populate(objectMap, "managementCluster", p.ManagementCluster)
	populate(objectMap, "managementNetwork", p.ManagementNetwork)
	populate(objectMap, "networkBlock", p.NetworkBlock)
	populate(objectMap, "nsxPublicIpQuotaRaised", p.NsxPublicIPQuotaRaised)
	populate(objectMap, "nsxtCertificateThumbprint", p.NsxtCertificateThumbprint)
	populate(objectMap, "nsxtPassword", p.NsxtPassword)
	populate(objectMap, "provisioningNetwork", p.ProvisioningNetwork)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "secondaryCircuit", p.SecondaryCircuit)
	populate(objectMap, "vcenterCertificateThumbprint", p.VcenterCertificateThumbprint)
	populate(objectMap, "vcenterPassword", p.VcenterPassword)
	populate(objectMap, "virtualNetworkId", p.VirtualNetworkID)
	populate(objectMap, "vmotionNetwork", p.VmotionNetwork)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateCloudProperties.
func (p *PrivateCloudProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availability":
				err = unpopulate(val, "Availability", &p.Availability)
			delete(rawMsg, key)
		case "circuit":
				err = unpopulate(val, "Circuit", &p.Circuit)
			delete(rawMsg, key)
		case "dnsZoneType":
				err = unpopulate(val, "DNSZoneType", &p.DNSZoneType)
			delete(rawMsg, key)
		case "encryption":
				err = unpopulate(val, "Encryption", &p.Encryption)
			delete(rawMsg, key)
		case "endpoints":
				err = unpopulate(val, "Endpoints", &p.Endpoints)
			delete(rawMsg, key)
		case "extendedNetworkBlocks":
				err = unpopulate(val, "ExtendedNetworkBlocks", &p.ExtendedNetworkBlocks)
			delete(rawMsg, key)
		case "externalCloudLinks":
				err = unpopulate(val, "ExternalCloudLinks", &p.ExternalCloudLinks)
			delete(rawMsg, key)
		case "identitySources":
				err = unpopulate(val, "IdentitySources", &p.IdentitySources)
			delete(rawMsg, key)
		case "internet":
				err = unpopulate(val, "Internet", &p.Internet)
			delete(rawMsg, key)
		case "managementCluster":
				err = unpopulate(val, "ManagementCluster", &p.ManagementCluster)
			delete(rawMsg, key)
		case "managementNetwork":
				err = unpopulate(val, "ManagementNetwork", &p.ManagementNetwork)
			delete(rawMsg, key)
		case "networkBlock":
				err = unpopulate(val, "NetworkBlock", &p.NetworkBlock)
			delete(rawMsg, key)
		case "nsxPublicIpQuotaRaised":
				err = unpopulate(val, "NsxPublicIPQuotaRaised", &p.NsxPublicIPQuotaRaised)
			delete(rawMsg, key)
		case "nsxtCertificateThumbprint":
				err = unpopulate(val, "NsxtCertificateThumbprint", &p.NsxtCertificateThumbprint)
			delete(rawMsg, key)
		case "nsxtPassword":
				err = unpopulate(val, "NsxtPassword", &p.NsxtPassword)
			delete(rawMsg, key)
		case "provisioningNetwork":
				err = unpopulate(val, "ProvisioningNetwork", &p.ProvisioningNetwork)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "secondaryCircuit":
				err = unpopulate(val, "SecondaryCircuit", &p.SecondaryCircuit)
			delete(rawMsg, key)
		case "vcenterCertificateThumbprint":
				err = unpopulate(val, "VcenterCertificateThumbprint", &p.VcenterCertificateThumbprint)
			delete(rawMsg, key)
		case "vcenterPassword":
				err = unpopulate(val, "VcenterPassword", &p.VcenterPassword)
			delete(rawMsg, key)
		case "virtualNetworkId":
				err = unpopulate(val, "VirtualNetworkID", &p.VirtualNetworkID)
			delete(rawMsg, key)
		case "vmotionNetwork":
				err = unpopulate(val, "VmotionNetwork", &p.VmotionNetwork)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudUpdate.
func (p PrivateCloudUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", p.Identity)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "sku", p.SKU)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateCloudUpdate.
func (p *PrivateCloudUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &p.Identity)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &p.Properties)
			delete(rawMsg, key)
		case "sku":
				err = unpopulate(val, "SKU", &p.SKU)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &p.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateCloudUpdateProperties.
func (p PrivateCloudUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availability", p.Availability)
	populate(objectMap, "dnsZoneType", p.DNSZoneType)
	populate(objectMap, "encryption", p.Encryption)
	populate(objectMap, "extendedNetworkBlocks", p.ExtendedNetworkBlocks)
	populate(objectMap, "identitySources", p.IdentitySources)
	populate(objectMap, "internet", p.Internet)
	populate(objectMap, "managementCluster", p.ManagementCluster)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateCloudUpdateProperties.
func (p *PrivateCloudUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availability":
				err = unpopulate(val, "Availability", &p.Availability)
			delete(rawMsg, key)
		case "dnsZoneType":
				err = unpopulate(val, "DNSZoneType", &p.DNSZoneType)
			delete(rawMsg, key)
		case "encryption":
				err = unpopulate(val, "Encryption", &p.Encryption)
			delete(rawMsg, key)
		case "extendedNetworkBlocks":
				err = unpopulate(val, "ExtendedNetworkBlocks", &p.ExtendedNetworkBlocks)
			delete(rawMsg, key)
		case "identitySources":
				err = unpopulate(val, "IdentitySources", &p.IdentitySources)
			delete(rawMsg, key)
		case "internet":
				err = unpopulate(val, "Internet", &p.Internet)
			delete(rawMsg, key)
		case "managementCluster":
				err = unpopulate(val, "ManagementCluster", &p.ManagementCluster)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProxyResourceBase.
func (p ProxyResourceBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProxyResourceBase.
func (p *ProxyResourceBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Quota.
func (q Quota) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hostsRemaining", q.HostsRemaining)
	populate(objectMap, "quotaEnabled", q.QuotaEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Quota.
func (q *Quota) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hostsRemaining":
				err = unpopulate(val, "HostsRemaining", &q.HostsRemaining)
			delete(rawMsg, key)
		case "quotaEnabled":
				err = unpopulate(val, "QuotaEnabled", &q.QuotaEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKUType.
func (r ResourceSKUType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacity", r.Capacity)
	populate(objectMap, "family", r.Family)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "size", r.Size)
	populate(objectMap, "tier", r.Tier)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceSKUType.
func (r *ResourceSKUType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacity":
				err = unpopulate(val, "Capacity", &r.Capacity)
			delete(rawMsg, key)
		case "family":
				err = unpopulate(val, "Family", &r.Family)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "size":
				err = unpopulate(val, "Size", &r.Size)
			delete(rawMsg, key)
		case "tier":
				err = unpopulate(val, "Tier", &r.Tier)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptCmdlet.
func (s ScriptCmdlet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptCmdlet.
func (s *ScriptCmdlet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptCmdletListResult.
func (s ScriptCmdletListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptCmdletListResult.
func (s *ScriptCmdletListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptCmdletProperties.
func (s ScriptCmdletProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "audience", s.Audience)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "timeout", s.Timeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptCmdletProperties.
func (s *ScriptCmdletProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audience":
				err = unpopulate(val, "Audience", &s.Audience)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "parameters":
				err = unpopulate(val, "Parameters", &s.Parameters)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "timeout":
				err = unpopulate(val, "Timeout", &s.Timeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecution.
func (s ScriptExecution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecution.
func (s *ScriptExecution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionListResult.
func (s ScriptExecutionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionListResult.
func (s *ScriptExecutionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionParameter.
func (s ScriptExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionParameter.
func (s *ScriptExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptExecutionProperties.
func (s ScriptExecutionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errors", s.Errors)
	populate(objectMap, "failureReason", s.FailureReason)
	populateDateTimeRFC3339(objectMap, "finishedAt", s.FinishedAt)
	populate(objectMap, "hiddenParameters", s.HiddenParameters)
	populate(objectMap, "information", s.Information)
	populate(objectMap, "namedOutputs", s.NamedOutputs)
	populate(objectMap, "output", s.Output)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "retention", s.Retention)
	populate(objectMap, "scriptCmdletId", s.ScriptCmdletID)
	populateDateTimeRFC3339(objectMap, "startedAt", s.StartedAt)
	populateDateTimeRFC3339(objectMap, "submittedAt", s.SubmittedAt)
	populate(objectMap, "timeout", s.Timeout)
	populate(objectMap, "warnings", s.Warnings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptExecutionProperties.
func (s *ScriptExecutionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
				err = unpopulate(val, "Errors", &s.Errors)
			delete(rawMsg, key)
		case "failureReason":
				err = unpopulate(val, "FailureReason", &s.FailureReason)
			delete(rawMsg, key)
		case "finishedAt":
				err = unpopulateDateTimeRFC3339(val, "FinishedAt", &s.FinishedAt)
			delete(rawMsg, key)
		case "hiddenParameters":
			s.HiddenParameters, err = unmarshalScriptExecutionParameterClassificationArray(val)
			delete(rawMsg, key)
		case "information":
				err = unpopulate(val, "Information", &s.Information)
			delete(rawMsg, key)
		case "namedOutputs":
				err = unpopulate(val, "NamedOutputs", &s.NamedOutputs)
			delete(rawMsg, key)
		case "output":
				err = unpopulate(val, "Output", &s.Output)
			delete(rawMsg, key)
		case "parameters":
			s.Parameters, err = unmarshalScriptExecutionParameterClassificationArray(val)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "retention":
				err = unpopulate(val, "Retention", &s.Retention)
			delete(rawMsg, key)
		case "scriptCmdletId":
				err = unpopulate(val, "ScriptCmdletID", &s.ScriptCmdletID)
			delete(rawMsg, key)
		case "startedAt":
				err = unpopulateDateTimeRFC3339(val, "StartedAt", &s.StartedAt)
			delete(rawMsg, key)
		case "submittedAt":
				err = unpopulateDateTimeRFC3339(val, "SubmittedAt", &s.SubmittedAt)
			delete(rawMsg, key)
		case "timeout":
				err = unpopulate(val, "Timeout", &s.Timeout)
			delete(rawMsg, key)
		case "warnings":
				err = unpopulate(val, "Warnings", &s.Warnings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptPackage.
func (s ScriptPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptPackage.
func (s *ScriptPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptPackageListResult.
func (s ScriptPackageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptPackageListResult.
func (s *ScriptPackageListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptPackageProperties.
func (s ScriptPackageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "company", s.Company)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "uri", s.URI)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptPackageProperties.
func (s *ScriptPackageProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "company":
				err = unpopulate(val, "Company", &s.Company)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "uri":
				err = unpopulate(val, "URI", &s.URI)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptParameter.
func (s ScriptParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "optional", s.Optional)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "visibility", s.Visibility)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptParameter.
func (s *ScriptParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
				err = unpopulate(val, "Description", &s.Description)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "optional":
				err = unpopulate(val, "Optional", &s.Optional)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "visibility":
				err = unpopulate(val, "Visibility", &s.Visibility)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptSecureStringExecutionParameter.
func (s ScriptSecureStringExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "secureValue", s.SecureValue)
	objectMap["type"] = ScriptExecutionParameterTypeSecureValue
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptSecureStringExecutionParameter.
func (s *ScriptSecureStringExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "secureValue":
				err = unpopulate(val, "SecureValue", &s.SecureValue)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScriptStringExecutionParameter.
func (s ScriptStringExecutionParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	objectMap["type"] = ScriptExecutionParameterTypeValue
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScriptStringExecutionParameter.
func (s *ScriptStringExecutionParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateType(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateType(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
				err = unpopulateDateType(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
				err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
				err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
				err = unpopulateDateType(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
				err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
				err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResourceBase.
func (t TrackedResourceBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackedResourceBase.
func (t *TrackedResourceBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &t.Location)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &t.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Trial.
func (t Trial) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableHosts", t.AvailableHosts)
	populate(objectMap, "status", t.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Trial.
func (t *Trial) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableHosts":
				err = unpopulate(val, "AvailableHosts", &t.AvailableHosts)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &t.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMHostPlacementPolicyProperties.
func (v VMHostPlacementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityStrength", v.AffinityStrength)
	populate(objectMap, "affinityType", v.AffinityType)
	populate(objectMap, "azureHybridBenefitType", v.AzureHybridBenefitType)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "hostMembers", v.HostMembers)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "state", v.State)
	objectMap["type"] = PlacementPolicyTypeVMHost
	populate(objectMap, "vmMembers", v.VMMembers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMHostPlacementPolicyProperties.
func (v *VMHostPlacementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityStrength":
				err = unpopulate(val, "AffinityStrength", &v.AffinityStrength)
			delete(rawMsg, key)
		case "affinityType":
				err = unpopulate(val, "AffinityType", &v.AffinityType)
			delete(rawMsg, key)
		case "azureHybridBenefitType":
				err = unpopulate(val, "AzureHybridBenefitType", &v.AzureHybridBenefitType)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &v.DisplayName)
			delete(rawMsg, key)
		case "hostMembers":
				err = unpopulate(val, "HostMembers", &v.HostMembers)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &v.State)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "vmMembers":
				err = unpopulate(val, "VMMembers", &v.VMMembers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMVMPlacementPolicyProperties.
func (v VMVMPlacementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityType", v.AffinityType)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "state", v.State)
	objectMap["type"] = PlacementPolicyTypeVMVM
	populate(objectMap, "vmMembers", v.VMMembers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMVMPlacementPolicyProperties.
func (v *VMVMPlacementPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityType":
				err = unpopulate(val, "AffinityType", &v.AffinityType)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &v.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &v.State)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "vmMembers":
				err = unpopulate(val, "VMMembers", &v.VMMembers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachine.
func (v VirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachine.
func (v *VirtualMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineListResult.
func (v VirtualMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineListResult.
func (v *VirtualMachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineProperties.
func (v VirtualMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "folderPath", v.FolderPath)
	populate(objectMap, "moRefId", v.MoRefID)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "restrictMovement", v.RestrictMovement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineProperties.
func (v *VirtualMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, "DisplayName", &v.DisplayName)
			delete(rawMsg, key)
		case "folderPath":
				err = unpopulate(val, "FolderPath", &v.FolderPath)
			delete(rawMsg, key)
		case "moRefId":
				err = unpopulate(val, "MoRefID", &v.MoRefID)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "restrictMovement":
				err = unpopulate(val, "RestrictMovement", &v.RestrictMovement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineRestrictMovement.
func (v VirtualMachineRestrictMovement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "restrictMovement", v.RestrictMovement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineRestrictMovement.
func (v *VirtualMachineRestrictMovement) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "restrictMovement":
				err = unpopulate(val, "RestrictMovement", &v.RestrictMovement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetwork.
func (w WorkloadNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetwork.
func (w *WorkloadNetwork) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSService.
func (w WorkloadNetworkDNSService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDNSService.
func (w *WorkloadNetworkDNSService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSServiceListResult.
func (w WorkloadNetworkDNSServiceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDNSServiceListResult.
func (w *WorkloadNetworkDNSServiceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSServiceProperties.
func (w WorkloadNetworkDNSServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dnsServiceIp", w.DNSServiceIP)
	populate(objectMap, "defaultDnsZone", w.DefaultDNSZone)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "fqdnZones", w.FqdnZones)
	populate(objectMap, "logLevel", w.LogLevel)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDNSServiceProperties.
func (w *WorkloadNetworkDNSServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dnsServiceIp":
				err = unpopulate(val, "DNSServiceIP", &w.DNSServiceIP)
			delete(rawMsg, key)
		case "defaultDnsZone":
				err = unpopulate(val, "DefaultDNSZone", &w.DefaultDNSZone)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "fqdnZones":
				err = unpopulate(val, "FqdnZones", &w.FqdnZones)
			delete(rawMsg, key)
		case "logLevel":
				err = unpopulate(val, "LogLevel", &w.LogLevel)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
				err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &w.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSServiceUpdate.
func (w WorkloadNetworkDNSServiceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDNSServiceUpdate.
func (w *WorkloadNetworkDNSServiceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZone.
func (w WorkloadNetworkDNSZone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDNSZone.
func (w *WorkloadNetworkDNSZone) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZoneListResult.
func (w WorkloadNetworkDNSZoneListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDNSZoneListResult.
func (w *WorkloadNetworkDNSZoneListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZoneProperties.
func (w WorkloadNetworkDNSZoneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dnsServerIps", w.DNSServerIPs)
	populate(objectMap, "dnsServices", w.DNSServices)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "domain", w.Domain)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "sourceIp", w.SourceIP)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDNSZoneProperties.
func (w *WorkloadNetworkDNSZoneProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dnsServerIps":
				err = unpopulate(val, "DNSServerIPs", &w.DNSServerIPs)
			delete(rawMsg, key)
		case "dnsServices":
				err = unpopulate(val, "DNSServices", &w.DNSServices)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "domain":
				err = unpopulate(val, "Domain", &w.Domain)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
				err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "sourceIp":
				err = unpopulate(val, "SourceIP", &w.SourceIP)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDNSZoneUpdate.
func (w WorkloadNetworkDNSZoneUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDNSZoneUpdate.
func (w *WorkloadNetworkDNSZoneUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcp.
func (w WorkloadNetworkDhcp) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcp.
func (w *WorkloadNetworkDhcp) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
			w.Properties, err = unmarshalWorkloadNetworkDhcpEntityClassification(val)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpEntity.
func (w WorkloadNetworkDhcpEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dhcpType", w.DhcpType)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpEntity.
func (w *WorkloadNetworkDhcpEntity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dhcpType":
				err = unpopulate(val, "DhcpType", &w.DhcpType)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
				err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "segments":
				err = unpopulate(val, "Segments", &w.Segments)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpListResult.
func (w WorkloadNetworkDhcpListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpListResult.
func (w *WorkloadNetworkDhcpListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpRelay.
func (w WorkloadNetworkDhcpRelay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dhcpType"] = DhcpTypeEnumRELAY
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	populate(objectMap, "serverAddresses", w.ServerAddresses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpRelay.
func (w *WorkloadNetworkDhcpRelay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dhcpType":
				err = unpopulate(val, "DhcpType", &w.DhcpType)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
				err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "segments":
				err = unpopulate(val, "Segments", &w.Segments)
			delete(rawMsg, key)
		case "serverAddresses":
				err = unpopulate(val, "ServerAddresses", &w.ServerAddresses)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpServer.
func (w WorkloadNetworkDhcpServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dhcpType"] = DhcpTypeEnumSERVER
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "leaseTime", w.LeaseTime)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "segments", w.Segments)
	populate(objectMap, "serverAddress", w.ServerAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpServer.
func (w *WorkloadNetworkDhcpServer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dhcpType":
				err = unpopulate(val, "DhcpType", &w.DhcpType)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "leaseTime":
				err = unpopulate(val, "LeaseTime", &w.LeaseTime)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
				err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "segments":
				err = unpopulate(val, "Segments", &w.Segments)
			delete(rawMsg, key)
		case "serverAddress":
				err = unpopulate(val, "ServerAddress", &w.ServerAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkDhcpUpdate.
func (w WorkloadNetworkDhcpUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkDhcpUpdate.
func (w *WorkloadNetworkDhcpUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			w.Properties, err = unmarshalWorkloadNetworkDhcpEntityClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkGateway.
func (w WorkloadNetworkGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkGateway.
func (w *WorkloadNetworkGateway) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkGatewayListResult.
func (w WorkloadNetworkGatewayListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkGatewayListResult.
func (w *WorkloadNetworkGatewayListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkGatewayProperties.
func (w WorkloadNetworkGatewayProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "path", w.Path)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkGatewayProperties.
func (w *WorkloadNetworkGatewayProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &w.Path)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkListResult.
func (w WorkloadNetworkListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkListResult.
func (w *WorkloadNetworkListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPortMirroring.
func (w WorkloadNetworkPortMirroring) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkPortMirroring.
func (w *WorkloadNetworkPortMirroring) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPortMirroringListResult.
func (w WorkloadNetworkPortMirroringListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkPortMirroringListResult.
func (w *WorkloadNetworkPortMirroringListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPortMirroringProperties.
func (w WorkloadNetworkPortMirroringProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "destination", w.Destination)
	populate(objectMap, "direction", w.Direction)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "source", w.Source)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkPortMirroringProperties.
func (w *WorkloadNetworkPortMirroringProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
				err = unpopulate(val, "Destination", &w.Destination)
			delete(rawMsg, key)
		case "direction":
				err = unpopulate(val, "Direction", &w.Direction)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
				err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &w.Source)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &w.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPortMirroringUpdate.
func (w WorkloadNetworkPortMirroringUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkPortMirroringUpdate.
func (w *WorkloadNetworkPortMirroringUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkProperties.
func (w WorkloadNetworkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkProperties.
func (w *WorkloadNetworkProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPublicIP.
func (w WorkloadNetworkPublicIP) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkPublicIP.
func (w *WorkloadNetworkPublicIP) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPublicIPListResult.
func (w WorkloadNetworkPublicIPListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkPublicIPListResult.
func (w *WorkloadNetworkPublicIPListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkPublicIPProperties.
func (w WorkloadNetworkPublicIPProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "numberOfPublicIPs", w.NumberOfPublicIPs)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "publicIPBlock", w.PublicIPBlock)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkPublicIPProperties.
func (w *WorkloadNetworkPublicIPProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "numberOfPublicIPs":
				err = unpopulate(val, "NumberOfPublicIPs", &w.NumberOfPublicIPs)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "publicIPBlock":
				err = unpopulate(val, "PublicIPBlock", &w.PublicIPBlock)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegment.
func (w WorkloadNetworkSegment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkSegment.
func (w *WorkloadNetworkSegment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentListResult.
func (w WorkloadNetworkSegmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkSegmentListResult.
func (w *WorkloadNetworkSegmentListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentPortVif.
func (w WorkloadNetworkSegmentPortVif) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "portName", w.PortName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkSegmentPortVif.
func (w *WorkloadNetworkSegmentPortVif) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "portName":
				err = unpopulate(val, "PortName", &w.PortName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentProperties.
func (w WorkloadNetworkSegmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectedGateway", w.ConnectedGateway)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "portVif", w.PortVif)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	populate(objectMap, "subnet", w.Subnet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkSegmentProperties.
func (w *WorkloadNetworkSegmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectedGateway":
				err = unpopulate(val, "ConnectedGateway", &w.ConnectedGateway)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "portVif":
				err = unpopulate(val, "PortVif", &w.PortVif)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
				err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &w.Status)
			delete(rawMsg, key)
		case "subnet":
				err = unpopulate(val, "Subnet", &w.Subnet)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentSubnet.
func (w WorkloadNetworkSegmentSubnet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dhcpRanges", w.DhcpRanges)
	populate(objectMap, "gatewayAddress", w.GatewayAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkSegmentSubnet.
func (w *WorkloadNetworkSegmentSubnet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dhcpRanges":
				err = unpopulate(val, "DhcpRanges", &w.DhcpRanges)
			delete(rawMsg, key)
		case "gatewayAddress":
				err = unpopulate(val, "GatewayAddress", &w.GatewayAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkSegmentUpdate.
func (w WorkloadNetworkSegmentUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkSegmentUpdate.
func (w *WorkloadNetworkSegmentUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroup.
func (w WorkloadNetworkVMGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkVMGroup.
func (w *WorkloadNetworkVMGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroupListResult.
func (w WorkloadNetworkVMGroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkVMGroupListResult.
func (w *WorkloadNetworkVMGroupListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroupProperties.
func (w WorkloadNetworkVMGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "members", w.Members)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "revision", w.Revision)
	populate(objectMap, "status", w.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkVMGroupProperties.
func (w *WorkloadNetworkVMGroupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "members":
				err = unpopulate(val, "Members", &w.Members)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "revision":
				err = unpopulate(val, "Revision", &w.Revision)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &w.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVMGroupUpdate.
func (w WorkloadNetworkVMGroupUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", w.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkVMGroupUpdate.
func (w *WorkloadNetworkVMGroupUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVirtualMachine.
func (w WorkloadNetworkVirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "name", w.Name)
	populate(objectMap, "properties", w.Properties)
	populate(objectMap, "systemData", w.SystemData)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkVirtualMachine.
func (w *WorkloadNetworkVirtualMachine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &w.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &w.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &w.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVirtualMachineListResult.
func (w WorkloadNetworkVirtualMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", w.NextLink)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkVirtualMachineListResult.
func (w *WorkloadNetworkVirtualMachineListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &w.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkloadNetworkVirtualMachineProperties.
func (w WorkloadNetworkVirtualMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "provisioningState", w.ProvisioningState)
	populate(objectMap, "vmType", w.VMType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkloadNetworkVirtualMachineProperties.
func (w *WorkloadNetworkVirtualMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &w.ProvisioningState)
			delete(rawMsg, key)
		case "vmType":
				err = unpopulate(val, "VMType", &w.VMType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

